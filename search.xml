<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git</title>
    <url>/git_shell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.创建版本库"></a>1.创建版本库</h4><ol>
<li>git init    把这个目录变成Git可以管理的仓库</li>
<li>git add readme.md    把文件添加到仓库</li>
<li>git commit -m “wrote a readme file”    <code>-m</code>后面输入的是本次提交的说明<a id="more"></a>
<h4 id="2-版本回退"><a href="#2-版本回退" class="headerlink" title="2.版本回退"></a>2.版本回退</h4></li>
<li>修改readme.md内容<br>git add readme.txt<br>git commit -m “append GPL”<br>ps: <code>git log</code>可以查看版本历史记录</li>
<li>git reset –hard HEAD^<br>ps: <code>HEAD^</code>表示上一个版本    <code>HEAD^</code>表示上上个版本    <code>HEAD~100</code>表示往上100个版本</li>
<li>命令行窗口还没有被关掉时，找到某个版本的<code>commit id</code>，也能进行回退。<br>git reset –hard xxxxxxxx<br>命令行窗口被被关掉时，使用<code>git reflog</code>查看记录的每一次命令</li>
</ol>
<h4 id="3-工作区和暂存区"><a href="#3-工作区和暂存区" class="headerlink" title="3.工作区和暂存区"></a>3.工作区和暂存区</h4><ol>
<li>工作区<br>电脑里能看到的目录，比如gittest文件夹就是一个工作区</li>
<li>版本库<br><img data-src="../../../../assets/img/86989.jpg" alt><br>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库<br><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。<br>git add .    添加所有数据<br>git commit -m “understand how stage works”</li>
</ol>
<h4 id="4-管理修改"><a href="#4-管理修改" class="headerlink" title="4.管理修改"></a>4.管理修改</h4><ol>
<li>对readme.txt做一个修改<br>git add readme.md<br>再修改readme.md<br>git commit -m “git tracks changes”    提交</li>
<li>git status<br>然而，第二次修改并没有被提交，第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code><br>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。<br>git diff HEAD – readme.md    查看工作区和版本库里面最新版本的区别</li>
<li>提交第二次修改<br>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></li>
</ol>
<h4 id="5-撤销修改"><a href="#5-撤销修改" class="headerlink" title="5.撤销修改"></a>5.撤销修改</h4><ol>
<li>git checkout – readme.md    丢弃工作区的修改<br>一种是readme.md自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.md已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。</li>
<li>git add后修改<br>git reset HEAD readme.md    把暂存区的修改撤销掉<br>git checkout – readme.md    丢弃工作区的修改</li>
</ol>
<h4 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6.删除文件"></a>6.删除文件</h4><ol>
<li>先添加一个新文件test.txt到Git并且提交<br>git add test.txt<br>git commit -m “add test.txt”</li>
<li>直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删除rm test.txt<br>从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code><br>git rm test.txt<br>git commit -m “remove test.txt”<br>删错了，因为版本库里还有，所以可以把误删的文件恢复到最新版本<br>git checkout – test.txt</li>
</ol>
<h4 id="7-远程仓库"><a href="#7-远程仓库" class="headerlink" title="7.远程仓库"></a>7.远程仓库</h4><ol>
<li>添加远程库<br>在GitHub创建一个Git仓库<br>git remote add origin <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t">git@github.com<i class="fa fa-external-link-alt"></i></span>:xxxxxxxx    关联<br>git push -u origin master    把本地库的所有内容推送到远程库上</li>
<li>从远程库克隆<br>git clone <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t">git@github.com<i class="fa fa-external-link-alt"></i></span>:xxxxxxxxx</li>
</ol>
<h4 id="8-分支管理"><a href="#8-分支管理" class="headerlink" title="8.分支管理"></a>8.分支管理</h4><ol>
<li>创建与合并分支<br>git switch -c dev    创建dev分支，然后切换到dev分支<br>git branch    查看当前分支<br>修改readme.md    git add readme.md    git commit -m “branch test”<br>git switch master    切换回master分支<br>再查看readme.md文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变。<br>git merge dev    把dev分支的工作成果合并到master分支上<br>git branch -d dev    删除dev分支</li>
<li>解决冲突<br>git switch -c feature1    准备新的feature1分支<br>修改readme.md<br>git add readme.md<br>git commit -m “AND simple”    在feature1分支上提交<br>git switch master    切换到master分支<br>在master分支上把readme.md进行不同修改<br>git add readme.md<br>git commit -m “&amp; simple”    在master分支上提交<br>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。<br>git status    查看冲突的文件<br>手动修改文件解决冲突后再提交<br>git add readme.txt<br>git commit -m “conflict fixed”<br>git branch -d feature1    删除feature1分支<br>准备合并dev分支，请注意<code>--no-ff</code>参数，表示禁用Fast forward</li>
<li>Bug分支<br>git stash    把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br>git switch -c issue-101<br>修改Bug，然后提交<br>git add readme.txt<br>git commit -m “fix bug 101”<br>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支<br>git switch master<br>git merge –no-ff -m “merged bug fix 101” issue-101<br>git switch dev<br>git stash pop    删除stash<br>复制一个特定的提交到当前分支<br>git log<br>git cherry-pick 4e4858db453de3da86ee2eafc2</li>
<li>多人协作<br>git remote -v    查看远程库的详细信息<br>多人协作的工作模式通常是这样：<ol>
<li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！<br>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</li>
</ol>
</li>
<li>忽略特殊文件<br>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。<br>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9naXRpZ25vcmU=">https://github.com/github/gitignore<i class="fa fa-external-link-alt"></i></span><br>把<code>.gitignore</code>也提交到Git</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker+Kubernetes</title>
    <url>/docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><p><strong>Chroot</strong></p>
<p>改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。</p>
</li>
<li><p><strong>NameSpace</strong></p>
<p>对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。</p>
</li>
<li><p><strong>Cgroup</strong></p>
<p>限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="容器的5种状态"><a href="#容器的5种状态" class="headerlink" title="容器的5种状态"></a>容器的5种状态</h3><p>初建、运行、停止、暂停、删除。</p>
<p><img data-src="../assets/img/image-20220413161321391.png" alt></p>
<h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>与服务端交互：</p>
<ol>
<li>Docker命令</li>
<li>REST API</li>
<li>SDK</li>
</ol>
<h3 id="Docker服务端"><a href="#Docker服务端" class="headerlink" title="Docker服务端"></a>Docker服务端</h3><p>dockerd(Docker Daemon)：负责响应和处理来自客户端的请求，然后将其转化为具体操作。</p>
<p>containerd：通过containerd-shim启动并管理runC</p>
<p>runC：用来运行容器的轻量级工具</p>
<h3 id="docker-attach-exec"><a href="#docker-attach-exec" class="headerlink" title="docker attach/exec"></a>docker attach/exec</h3><p>docker attach：给一个正在运行的容器分配了stdin、stdout、stderr，所有终端窗口同(显示一样的内容；同时阻塞)，使用exit退出时原容器也会退出，可以使用Ctrl+C。</p>
<p>docker exec：相当于fork了一个和容器相同NameSpace的进程。</p>
<h2 id="镜像与容器的区别"><a href="#镜像与容器的区别" class="headerlink" title="镜像与容器的区别"></a>镜像与容器的区别</h2><p>docker image inspect &lt; image &gt; 查看镜像分层</p>
<p><strong>镜像中的层都是只读的，容器在镜像上多了一个读写层。</strong></p>
<p>docker commit 可以基于运行时的容器生成新的镜像，将读写层数据写到新的镜像中。</p>
<p><strong>所有写入或修改运行时容器的数据都存储在读写层，当容器停止运行时，读写层的数据也会同时删除掉。</strong></p>
<p>写时复制：因为镜像层的数据是只读的，所以我们运行同一个镜像的多个容器副本时，可以共享镜像存储层，节省磁盘。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p><img data-src="../assets/img/image-20220429133157063.png" alt></p>
<p>将镜像层(只读)组织成多个目录(branch)，运行时容器文件作为一层容器层(读写)覆盖在镜像层之上，最后通过联合挂载技术呈现。</p>
<p><strong>联合挂载：</strong>同一个挂载点同时挂载多个文件系统，将挂载点的源目录与挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层文件和目录。</p>
<h3 id="OverlayFS"><a href="#OverlayFS" class="headerlink" title="OverlayFS"></a>OverlayFS</h3><p><img data-src="../assets/img/image-20220429141408096.png" alt></p>
<p>将镜像层(只读)称为lowerdir，容器层(读写)称为upperdir，最后联合挂载为mergedir，在容器上的改动，在upperdir、mergeddir中都会体现。</p>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="docker0网桥"><a href="#docker0网桥" class="headerlink" title="docker0网桥"></a>docker0网桥</h3><p><img data-src="../assets/img/image-20220524114018238.png" alt></p>
<p>启动Docker Daemon进程之后，会多出一个docker0的网卡，连接容器网段和宿主机网段，IP: 172.17.0.1/16(可修改)。</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>Docker会在宿主机系统上增加一些iptables规则，用来管理Docker容器与容器之间及外界的通信。</p>
<ul>
<li>外界访问Docker是通过iptables做DNAT实现的，DNAT将SNAT中的Source转成Destiantion，表示目的地址转换。</li>
</ul>
<h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><ul>
<li><p><strong>bridge模式</strong></p>
<p>默认网络模式，所有Docker容器连接到docker0网桥或自定义网桥上，所有的Docker容器处于同一个子网。</p>
</li>
<li><p><strong>host模式</strong></p>
<p>Docker容器和宿主机使用同一个网络协议栈(同一个network namespace)，和宿主机共享网卡、IP、端口等信息。性能更好，但没做网络隔离。</p>
</li>
<li><p><strong>overlay模式</strong></p>
<p>在多个Docker Daemon之间创建一个分布式网络，允许容器之间加密通讯，需要处理容器之间和主机之间的网络包。</p>
</li>
<li><p>macvlan模式</p>
<p>网卡虚拟化技术，可以在同一个物理网卡上虚拟出多个网卡，通过不同的Mac地址在数据链路层进行网络数据的转发。</p>
</li>
<li><p>none模式</p>
<p>除了自带的IO网卡(loopback 127.0.0.1)外没有其它任何网卡、IP等信息，需要自己添加网卡。</p>
</li>
</ul>
<h2 id="容器间网络通信：link"><a href="#容器间网络通信：link" class="headerlink" title="容器间网络通信：link"></a>容器间网络通信：link</h2><p>将新创建出来的Docker容器与已有的容器之间创建一个安全通道来做数据交互。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name mysql mysql:latest</span><br><span class="line">docker run --name busybox --link mysql:mysql busybox:latest </span><br><span class="line"><span class="meta">#</span><span class="bash">--link name or id:<span class="built_in">alias</span>，第一个参数是目标容器的名字或者ID，第二个<span class="built_in">alias</span>相当于在busybox Docker容器中访问MySQL Docker容器的host。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>host文件修改</p>
<p>容器/etc/hosts文件中多了一条<code>172.17.0.2 mysql e47e603ffb17</code>记录</p>
</li>
<li><p>环境变量</p>
<p>通过link建立连接之后，会在接收容器额外设置一些环境变量保存源容器的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # env | grep MYSQL</span><br><span class="line">MYSQL_PORT_33060_TCP=tcp://172.17.0.2:33060</span><br><span class="line">MYSQL_ENV_MYSQL_MAJOR=8.0</span><br><span class="line">MYSQL_PORT_3306_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_ENV_MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">MYSQL_ENV_GOSU_VERSION=1.7</span><br><span class="line">MYSQL_PORT_3306_TCP_PORT=3306</span><br><span class="line">MYSQL_PORT_3306_TCP_PROTO=tcp</span><br><span class="line">MYSQL_PORT_33060_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_PORT=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_3306_TCP=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_33060_TCP_PORT=33060</span><br><span class="line">MYSQL_ENV_MYSQL_VERSION=8.0.19-1debian9</span><br><span class="line">MYSQL_PORT_33060_TCP_PROTO=tcp</span><br><span class="line">MYSQL_NAME=/busybox/mysql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Docker数据存储模式"><a href="#Docker数据存储模式" class="headerlink" title="Docker数据存储模式"></a>Docker数据存储模式</h2><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>Volume会把文件存储在宿主机的指定位置(Linux：/var/lib/docker/volumes/)，这些文件只能由Docker进程修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-4-5-centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test -v my-vol:/data nginx:latest</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test --mount type=volume,src=myvol,target=/data nginx:latest</span><br></pre></td></tr></table></figure>

<p>-v/–volume：volume的名字(匿名可忽略):容器内的挂载点</p>
<p>type=volume,src=&lt; VOLUME-NAME&gt;,dst=&lt; CONTAINER-PATH&gt;,volume-driver=local</p>
<h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>可以将文件存储到宿主机的任意位置，而且别的应用程序也可以修改。</p>
<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>只支持linux，只会将数据存储在宿主机的内存中，并不会落盘，容器停止，数据就会被清除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -it --name test --mount type=tmpfs,target=/data,tmpfs-mode=1770 nginx:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>tmpfs-size：指定tmpfs的大小，默认不受限制，单位byte</li>
<li>tmpfs-mode：Linux系统的文件模式，默认1777，任何用户都可以写</li>
</ul>
<h2 id="为什么说Docker是单进程模型？"><a href="#为什么说Docker是单进程模型？" class="headerlink" title="为什么说Docker是单进程模型？"></a>为什么说Docker是单进程模型？</h2><p>不管是在容器还是虚拟机中都有一个1号进程(容器：entrypoint启动进程；虚拟机：systemd进程)，然后其它进程都是1号进程的子进程，或子进程的子进程等等。</p>
<h3 id="回收子进程资源"><a href="#回收子进程资源" class="headerlink" title="回收子进程资源"></a>回收子进程资源</h3><ol>
<li>父进程通过系统调用wait()或waitpid()来等待子进程结束，从而回收子进程的资源；</li>
<li>异步：子进程结束之后向父进程发送SIGCCHILD信号，基于此父进程注册一个SIGCHILD信号的处理函数进行子进程的资源回收。</li>
</ol>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，并且父进程没有对子进程残留的资源进行回收，就会产生僵尸进程。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程先于子进程退出，产生孤儿进程。虚拟机会将孤儿进程的父进程设置为1号进程即systemd进程，然后由systemd对孤儿进程的资源进行回收，而容器的1号进程为entrypoint启动进程，无法处理。</p>
<p><strong>如何避免？</strong></p>
<p>Kubernetes：可以将多个容器编排到一个pod里，共享同一个Linux NameSpace，本质是k8s实例化出一个pause镜像，其它容器加入这个镜像实例化出的NameSpace实现NameSpace共享。</p>
<p>pod中的1号进程变成了pause，其它容器的entrypoint变成了1号进程的子进程。</p>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1>]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
        <tag>云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM&amp;垃圾回收</title>
    <url>/jvmAndgc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-JRE、JDK"><a href="#1-JRE、JDK" class="headerlink" title="1.JRE、JDK"></a>1.JRE、JDK</h4><ul>
<li>JRE：Java的运行时环境，JVM的标准加上实现的一大堆基础类库。</li>
<li>JDK：包含JRE，还提供了一些小工具，如Javac、Java、Jar。</li>
</ul>
<h4 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2.JVM"></a>2.JVM</h4><a id="more"></a>

<p><img data-src="../../../../assets/img/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JDK8).png" alt></p>
<h4 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3.类的加载过程"></a>3.类的加载过程</h4><ul>
<li><p>加载<br>将外部的.class文件加载到方法区。</p>
</li>
<li><p>验证<br>不能将任何的.class文件都加载，不符合规范的将抛出java.lang.VerifyError错误。(如低版本的JVM无法加载一些高版本的类库)</p>
</li>
<li><p>准备<br>为一些类变量分配内存，并将其初始化为默认值。此时，实例对象还没有分配内存，所以这些动作是在方法区上进行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">code-snippet <span class="number">1</span>：</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="comment">//类变量</span></span><br><span class="line">         <span class="keyword">static</span> <span class="keyword">int</span> a ;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">             System.out.println(a);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">a:<span class="number">0</span></span><br><span class="line">code-snippet <span class="number">2</span>：</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//局部变量</span></span><br><span class="line">         <span class="keyword">int</span> a ;</span><br><span class="line">         System.out.println(a);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">编译错误</span><br></pre></td></tr></table></figure>

<p><strong>类变量有两次赋初始值的过程：1.准备阶段，赋予初始值(也可以是指定值)    2.初始化阶段，赋予程序员指定的值</strong></p>
<p><strong>局部变量不存在准备阶段，如果没有赋予初始值就不能使用</strong></p>
</li>
<li><p>解析<br>将符号引用替换成直接引用<br>符号引用：一种定义，可以是任何字面上的含义<br>直接引用：直接指向目标的指针、相对变量，直接引用的对象都存在于内存中</p>
<ul>
<li>类或接口的解析</li>
<li>类方法的解析</li>
<li>接口方法的解析</li>
<li>字段解析</li>
</ul>
</li>
<li><p>初始化<br>初始化成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         a = <span class="number">1</span>;</span><br><span class="line">         b = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(a); <span class="comment">//a:1</span></span><br><span class="line">         System.out.println(b);	<span class="comment">//b:0</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>static语句块只能访问到定义在static语句块之前的变量</li>
<li>JVM会保证在子类的初始化方法执行之前，父类的初始化方法已经执行完毕</li>
</ol>
<p><strong>类初始化顺序</strong></p>
<ol>
<li>父类静态变量、静态代码块(只有第一次加载类时执行)</li>
<li>子类静态变量、静态代码块(只有第一次加载类时执行)</li>
<li>父类非静态代码块</li>
<li>父类构造器</li>
<li>子类非静态代码块</li>
<li>子类构造器</li>
</ol>
</li>
</ul>
<h4 id="4-clinit和init"><a href="#4-clinit和init" class="headerlink" title="4.clinit和init"></a>4.clinit和init</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"1"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"2"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">         <span class="keyword">static</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"a"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"b"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         A ab = <span class="keyword">new</span> B();</span><br><span class="line">         ab = <span class="keyword">new</span> B();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	1</span></span><br><span class="line"><span class="comment">//	a</span></span><br><span class="line"><span class="comment">//	2</span></span><br><span class="line"><span class="comment">//	b</span></span><br><span class="line"><span class="comment">//	2</span></span><br><span class="line"><span class="comment">//	b</span></span><br></pre></td></tr></table></figure>

<p>  <img data-src="../../../../assets/img/CgqCHl9ZjveAemjoAAB4J1dCVDo17.jpeg" alt></p>
<p>static字段和static代码块属于类，在类的初始化阶段就被执行，类的信息存放在方法区，同一个类加载器只有一份，所以上面的<strong>static只会执行一次</strong>，对应clinit方法。</p>
<p>对象初始化，在new一个新对象时，会调用构造方法来初始化对象的属性，对应<strong>init，每次新建对象都会执行</strong>。</p>
<h4 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h4><p><img data-src="../../../../assets/img/Cgq2xl4cQNeAG0ECAAA_CbVCY1M014.png" alt><br>除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给其父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。</p>
<h4 id="6-引用级别"><a href="#6-引用级别" class="headerlink" title="6.引用级别"></a>6.引用级别</h4><ul>
<li><p>强引用<br>当内存空间不足时，JVM抛出OutOfMemoryError。即使程序异常终止，这种对象也不会被回收，是最普通最强硬的一种存在，只有在和GC Roots断绝关系时才会被消灭掉。</p>
</li>
<li><p>软引用<br>用于维护一些可有可无的对象。在内存足够时，软引用对象不会被回收，内存不足时，系统会回收软引用对象。如果回收了软引用对象仍然没有足够的内存，才会抛出内存溢出异常。软引用可以和引用队列联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。</p>
</li>
<li><p>弱引用<br>垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，它拥有更短的生命周期。</p>
</li>
<li><p>虚引用<br>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用必须和引用队列联合使用，当垃圾回收准备回收一个对象时，如果发现它还有虚引用，就会在回收对象之前，把这个虚引用加入到与之关联的引用队列中。</p>
</li>
</ul>
<h4 id="7-典型OOM场景"><a href="#7-典型OOM场景" class="headerlink" title="7.典型OOM场景"></a>7.典型OOM场景</h4><p><img data-src="../../../../assets/img/Cgq2xl4heqWAZMlOAAA-Cqk2QcM143.png" alt><br>除了程序计数器，其它区域都有可能会发生OOM，但最常见的还是发生在堆上。   </p>
<ul>
<li>内存容量太小了，需要扩容，或者需要调整堆的空间</li>
<li>错误的引用的方式，发生了内存泄漏。如线程池里的线程，在复用的情况下忘记清理ThreadLocal的内容。</li>
<li>接口没有进行范围校验，外部传参超出范围。比如数据库查询时的每页条数等。</li>
<li>对堆外内存无限制的使用。这种情况更加严重，会造成操作系统内存耗尽。</li>
</ul>
<h4 id="8-垃圾回收算法"><a href="#8-垃圾回收算法" class="headerlink" title="8.垃圾回收算法"></a>8.垃圾回收算法</h4><ol>
<li><p>标记清除</p>
<ul>
<li>标记：从根集合扫描，对存活的对象进行标记</li>
<li>清除：从堆内粗从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
</li>
<li><p>标记整理</p>
<ul>
<li>标记：从根集合扫描，对存活的对象进行标记</li>
<li>整理：移动所有存活的对象，按照内存地址排序，内存地址以后的内存全部回收。</li>
</ul>
</li>
<li><p>复制算法<br>分对象面和空闲面，对象在对象面创建，回收时，存活的对象被从对象面复制到空闲面，后将对象面所有对象清除。</p>
</li>
<li><p>分代收集<br>把死的快的对象所占区域，叫作年轻代。其他活的长的对象所占的区域，叫作老年代。</p>
<ul>
<li><p>年轻代：使用复制算法<br><img data-src="../../../../assets/img/Cgq2xl4lQuiAHhjjAAAr3JIdyLA146.jpg" alt><br>年轻代分为：一个伊甸园空间(Eden)，两个幸存者空间(Survivor)<br>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC(Minoe GC)。</p>
<ol>
<li><p>在Eden区执行了第一次GC之后，存活的对象会移动到其中一个Survivor区(from)</p>
</li>
<li><p>Eden再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区，接下来清空from区就可以了。</p>
<p>Eden：from：to = 8：1：1    -XX:SurvivorRatio 默认为8</p>
<p>TLAB：JVM默认给每个线程开辟一个buffer区域来加速对象分配，这个buffer就放在Eden区。对象的分配优先在TLAB上分配，但通常TLAB很小，所以对象比较大时，会在Eden的共享区域进行分配。</p>
</li>
</ol>
</li>
<li><p>老年代：使用标记清除、标记整理算法</p>
</li>
</ul>
</li>
</ol>
<h4 id="9-对象如何进入老年代"><a href="#9-对象如何进入老年代" class="headerlink" title="9.对象如何进入老年代"></a>9.对象如何进入老年代</h4><ol>
<li><p>提升<br>每当发生一次Minor GC，存活下的对象年龄会加1，达到阈值(-XX:+MaxTenuringThreshold，最大值为15)，就会提升到老年代。</p>
</li>
<li><p>分配担保<br>每次存活的对象，都会放入其中一个幸存区，默认比例为10%。但无法保证每次存活的对象小于10%，当Survivor空间不够，就需要依赖其他内存(老年代)进行分配担保。</p>
</li>
<li><p>大对象直接在老年代分配<br>超过某个大小的对象将直接在老年代分配，-XX:PretenureSizeThreshold进行配置，默认为0。</p>
</li>
<li><p>动态对象年龄判定<br>有的垃圾回收算法，并不需要年龄达到15，会使用一些动态的计算方法，如幸存区中相同年龄对象大小的和大于幸存区的一半，大于或等于age的对象将直接进入老年代</p>
</li>
</ol>
<p><img data-src="../../../../assets/img/Cgq2xl4lQuiAM7ZPAABnAlb8gZ8269.jpg" alt></p>
<h4 id="10-垃圾回收器"><a href="#10-垃圾回收器" class="headerlink" title="10.垃圾回收器"></a>10.垃圾回收器</h4><ul>
<li><p>年轻代垃圾收集器</p>
<ol>
<li><p>Serial垃圾收集器<br>处理GC的只有一条线程，并且在垃圾回收过程中暂停一切用户线程。</p>
</li>
<li><p>ParNew垃圾收集器<br>Serial的多线程版本，多条GC线程并行的进行垃圾清理，清理过程中依然要停止用户线程。</p>
</li>
<li><p>Parallel Scavenge垃圾收集器<br>另一个多线程版本的垃圾回收器。与ParNew的主要区别：</p>
<ul>
<li>Parallel Scacenge：追求CPU吞吐量，适合没有交互的后台计算。弱交互强计算。</li>
<li>ParNew：追求降低用户停顿时间，适合交互式应用。强交互弱计算。</li>
</ul>
</li>
</ol>
</li>
<li><p>老年代垃圾收集器</p>
<ol>
<li><p>Serial Old垃圾收集器<br>与年轻代的Serial垃圾收集器对应，都是单线程版本，同样适用客户端使用。<br>年轻代的Serial，使用复制算法，老年代的Serial Old，使用标记-整理算法。</p>
</li>
<li><p>Parallel Old<br>Parallel Scavenge的老年代版本，追求CPU吞吐量。</p>
</li>
<li><p>CMS垃圾收集器<br>垃圾收集时用户线程和GC线程可以并发执行。</p>
</li>
</ol>
</li>
</ul>
<h4 id="11-CMS回收过程"><a href="#11-CMS回收过程" class="headerlink" title="11.CMS回收过程"></a>11.CMS回收过程</h4><p>Minor GC：发生在年轻代的GC</p>
<p>Major GC：发生在老年代的GC</p>
<p>Full GC：全堆垃圾回收，如Metaspace区引起年轻代和老年代的回收</p>
<p>CMS(主要并发标记清除收集器)，年轻代使用复制算法，老年代使用标记-清除算法</p>
<ol>
<li><p><strong>初始标记</strong><br>初始标记阶段，只标记直接关联GC root的对象，不用向下追溯。最耗时的就是tracing阶段，极大地缩短了初始标记阶段，所以该过程时间较短，这个过程是STW的。</p>
</li>
<li><p><strong>并发标记</strong><br>在初始标记的基础上，进行并发标记。tracing，标记所有可达的对象。这个阶段会比较久，但却可以和用户线程并行。</p>
<ul>
<li>有些对象，从新生代晋升到了老年代</li>
<li>有些对象，直接分配到了老年代</li>
<li>老年代或者新生代的对象引用发生了变化</li>
</ul>
</li>
<li><p>并发预清理<br>不需要STW，目的是缩短重新标记的时间。这个时候，老年代中被标记为dirty的卡页中的对象，就会被重新标记，然后清除掉dirty的状态。由于这个阶段也是可以并发的，有可能还会有处于dirty状态的卡页。</p>
</li>
<li><p>并发可取消的预清理<br>重新标记阶段是STW的，所以会有很多次预清理动作。可以在满足某些条件时，可以终止，如迭代次数、有用工作量、消耗的系统时间等。</p>
<p>意图：避免回扫年轻代的大量对象；当满足重新标记时，自动退出。</p>
</li>
<li><p><strong>重新标记</strong><br>CMS尝试在年轻代尽可能空的情况下运行重新标记，以免接连多次发生STW。这是CMS垃圾回收阶段的第二次STW阶段，目标是完成老年代中所有存活对象的标记。</p>
</li>
<li><p><strong>并发清理</strong><br>用户线程被重新激活，目标时删掉不可达对象。</p>
<p>由于CMS并发清理阶段用户线程还在运行中，CMS无法在当次GC中处理它们，只好留在下一处GC时再清理掉，这一部分垃圾称为”浮动垃圾”。</p>
</li>
<li><p>并发重置<br>与用户线程并发执行，重置CMS算法相关的内部数据，为下一次GC循环做准备。</p>
</li>
</ol>
<h4 id="12-内存碎片"><a href="#12-内存碎片" class="headerlink" title="12.内存碎片"></a>12.内存碎片</h4><p>  CMS执行过程中，用户线程还在运行，如果老年代空间快满了，才开始回收，用户线程可能会产生”Concurrent Mode Failure”的错误，这时会临时启用Serial Old收集器来重新进行老年代垃圾收集，这样STW会很久。</p>
<p>CMS对老年代回收的时候，并没有内存的整理阶段。程序长时间运行后，碎片太多，如果你申请一个稍大的对象，就会引起分配失败。(1) UseCMSCompactAtFullCollection(默认开启)，在进行Full GC时，进行碎片整理。内存碎片整理是无法并发的，STW时间较长。(2)CMSFullGCsBeforeCompation(默认为0)，每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。</p>
<h4 id="13-CMS"><a href="#13-CMS" class="headerlink" title="13.CMS"></a>13.CMS</h4><p>优势：</p>
<ol>
<li>低延迟，尤其对大堆来说。大部分垃圾回收过程并发执行。</li>
</ol>
<p>劣势：</p>
<ol>
<li>内存碎片问题。Full GC的整理阶段，会造成较长时间的停顿。</li>
<li>需要预留空间，用来收集”浮动垃圾”。</li>
<li>使用更多的CPU资源。</li>
</ol>
<h4 id="14-G1"><a href="#14-G1" class="headerlink" title="14.G1"></a>14.G1</h4><p><img data-src="../../../../assets/img/CgpOIF4lSamARPiHAABC8ugXMK8124.jpg" alt></p>
<p>G1也是有Eden区和Survivor区的概念的，但内存上不是连续的。小区域(Region)的大小是固定的，名字叫做小队区，小队区可以是Eden，也可以是Survivor，还可以是Old。Region大小（-XX:G1HeapRegionSize=<n>M)一致，为1M-32M字节间的一个2的幂指数。如果对象太大，大小超过Region 50%的对象，将会分配在Humongous Region。垃圾最多的小堆区，会被优先收集。<br>-XX:MaxGCPauseMills=10</n></p>
<h4 id="15-卡表与RSet"><a href="#15-卡表与RSet" class="headerlink" title="15.卡表与RSet"></a>15.卡表与RSet</h4><ul>
<li><p>卡表<br>老年代被分成众多的卡页(一般是2的次幂)，卡表就是用于标记卡页状态的一个集合，每个卡表对应一个卡页。如果年轻代有对象分配，而且老年代有对象指向这个新对象，那么这个老年代对象所对应内存的卡页，就会标识为dirty，卡表只需要很小的存储空间就可以保留这些状态。垃圾回收时，就可以先读卡表，进行快速判断。</p>
</li>
<li><p>RSet<br>RSet是一个空间换时间的数据结构。卡表是一种points-out(我引用了谁对象)的结构，而RSet是一种points-into(谁引用了我的对象)的结构。RSet类似一个Hash，key是引用的Region地址，value是引用它的对象的卡页集合</p>
</li>
</ul>
<h4 id="16-G1回收过程"><a href="#16-G1回收过程" class="headerlink" title="16.G1回收过程"></a>16.G1回收过程</h4><ol>
<li><p>年轻代回收<br>JVM启动时，G1会先准备好Eden区，程序在运行时不断创建到Eden区，当所有的Eden区满了，启动一次年轻代垃圾回收过程。年轻代是一个STW过程，它的跨代引用使用RSet来追溯，会一次回收掉年轻代的所有Region。</p>
</li>
<li><p>并发标记<br>当整个堆内存使用达到一定比例(-XX:InitatingHeapOccupancyPercent    默认45%)，启动并发标记阶段。为混合回收提供标记服务，类似CMS的垃圾回收过程。</p>
</li>
<li><p>混合回收<br>通过并发标记阶段，已经统计了老年代的垃圾占比，在Minor GC之后，如果占比达到阈值(-XX:G1HeapWastePercent    默认是堆大小的5%，该参数可以调整Mixed GC的频率)，下次就会触发混合回收。参数G1MixedGCCountTarget：一次并发标记之后，最多执行Mixed GC的次数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis是如何防止SQL注入的</title>
    <url>/16852/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-MyBatis概述"><a href="#1-MyBatis概述" class="headerlink" title="1.MyBatis概述"></a>1.MyBatis概述</h3><p>​    MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<h3 id="2-SQL-注入攻击概述"><a href="#2-SQL-注入攻击概述" class="headerlink" title="2.SQL 注入攻击概述"></a>2.SQL 注入攻击概述</h3><a id="more"></a>

<p>​    SQL注入攻击，简称SQL攻击或注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是<strong>在输入的字符串之中注入SQL指令</strong>，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p>
<p>​    最常见的就是我们在应用程序中使用<strong>字符串联结方式组合 SQL 指令</strong>，有心之人就会写一些特殊的符号，恶意篡改原本的 SQL 语法的作用，达到注入攻击的目的。</p>
<p>举个例子:</p>
<p>比如验证用户登录需要 username 和 password，编写的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> (<span class="keyword">name</span> = <span class="string">'"+ username +"'</span>) <span class="keyword">and</span> (pw = <span class="string">'"+ password +"'</span>);</span><br></pre></td></tr></table></figure>

<p>username 和 password 字段被恶意填入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">username = "1' OR '1'='1";</span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">password = "1' OR '1'='1";</span><br></pre></td></tr></table></figure>

<p>将导致原本的 SQL 字符串被填为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> (<span class="keyword">name</span> = <span class="string">'1'</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span>) <span class="keyword">and</span> (pw = <span class="string">'1'</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>

<p>实际上运行的 SQL 语句将变成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>也就是不再需要 username 和 password 账密即达到登录的目的，结果不言而喻。</p>
<h3 id="3-MyBatis-解决-SQL-注入问题"><a href="#3-MyBatis-解决-SQL-注入问题" class="headerlink" title="3.MyBatis 解决 SQL 注入问题"></a>3.MyBatis 解决 SQL 注入问题</h3><p><strong>#{}和${}的区别是什么？</strong></p>
<p>  (1）mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
<p>（2）mybatis在处理${}时，就是把${}替换成变量的值。</p>
<p>（3）使用#{}可以有效的防止SQL注入，提高系统安全性。原因在于：预编译机制。<strong>预编译完成之后，SQL的结构已经固定，即便用户输入非法参数，也不会对SQL的结构产生影响，从而避免了潜在的安全风险。</strong></p>
<p>（4）预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p>
<p>　MyBatis框架作为一款半自动化的持久层框架，其SQL语句都要我们自己手动编写，这个时候当然需要防止SQL注入。其实，MyBatis的SQL是一个具有“<strong>输入+输出</strong>”的功能，类似于函数的结构，参考上面的两个例子。其中，parameterType表示了输入的参数类型，resultType表示了输出的参数类型。回应上文，如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username, <span class="keyword">password</span>, <span class="keyword">role</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=? <span class="keyword">and</span> <span class="keyword">password</span>=?</span><br></pre></td></tr></table></figure>

<p>　　不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了<strong>预编译功能</strong>，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为<strong>SQL注入只能对编译过程起作用</strong>，所以这样的方式就很好地避免了SQL注入的问题。</p>
<p><strong>底层实现原理</strong></p>
<p>​    MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的<strong>PreparedStatement</strong>类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。</p>
<p><strong>在使用MyBatis框架时，有以下场景极易产生SQL注入</strong></p>
<ol>
<li><p>SQL语句中的一些部分，例如<strong>order by字段</strong>、表名等，是<strong>无法使用预编译语句</strong>的。这种场景极易产生SQL注入。推荐开发在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面(<strong>手动过滤，添加白名单</strong>)。</p>
</li>
<li><p>like参数注入。使用如下SQL语句可防止SQL注入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">like concat('%',<span class="comment">#&#123;title&#125;, '%')，</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in之后参数的SQL注入。使用如下SQL语句可防止SQL注入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">id in</span><br><span class="line">&lt;foreach collection="ids" item="item" open="("separator="," close=")"&gt;</span><br><span class="line"><span class="comment">#&#123;item&#125; </span></span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap分析</title>
    <url>/HashMap/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>HashMap位于<code>java.util</code>包中，HashMap基于Map接口实现，元素以<strong>键值对</strong>的方式存储，并且允许使用null键和null值，因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是<strong>无序</strong>的，和放入的顺序并不能相同。HashMap是<strong>线程不安全</strong>的。它的底层为哈希表结构（链表散列：<strong>数组+链表</strong>）实现，结合数组和链表的优点。JDK1.8之后，当链表长度超过 <strong>8</strong> 时，<strong>链表转换为红黑树</strong>。</p>
<a id="more"></a>
<p>HashMap主要属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">  <span class="comment">//HashMap的初始容量大小为16(1&lt;&lt;4)，指的是存储元素的数组大小，即桶的数量</span></span><br><span class="line">  <span class="comment">//为啥是16呢?	因为在使用2的幂的数字的时候，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。这是为了实现均匀分布。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">//HashMap的最大容量(1&lt;&lt;30)</span></span><br><span class="line">  <span class="comment">//使用位与运算速度更快</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1073741824</span>;</span><br><span class="line">  <span class="comment">//默认负载因子0.75</span></span><br><span class="line">  <span class="comment">//当HashMap中的数据量/HashMap的总容量=0.75或者指定值时，HashMap的总容量自动扩展一倍</span></span><br><span class="line">  <span class="comment">//负载因子代表了hash表中元素的填满程度。加载因子越大，填满的元素越多，但是冲突的机会增大了，链表越来越长，查询速度会降低。反之，如果加载因子过小，冲突的机会减小了，但是hash表过于稀疏。冲突越大，查找的成本就越高。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75F</span>;</span><br><span class="line">  <span class="comment">//由链表转换成树的阈值:8</span></span><br><span class="line">  <span class="comment">//在存储数据时，当某一个桶中链表的长度&gt;=8时，链表结构会转换成红黑树结构(其实还要求桶的中数量&gt;=64)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">//红黑树转为链表的阈值:6</span></span><br><span class="line">  <span class="comment">//当在扩容(resize())时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量&lt;6时，则将红黑树转换成链表</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">//最小树形化容量阈值:64</span></span><br><span class="line">  <span class="comment">//当哈希表中的容量&gt;该值时，才允许链表转换成红黑树</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Node"><a href="#2-Node" class="headerlink" title="2.Node"></a>2.Node</h3><p>JDK 1.8采用的是Node数组，实质上还是Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个<strong>单向的链表结构</strong>，它具有<code>Next</code>指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。<br>一个桶中链表的长度&lt;8时:<br><img data-src="../../../../assets/img/100918.jpg" alt><br>一个桶中链表的长度&gt;=8时:<br><img data-src="../../../../assets/img/424113.png" alt><br><img data-src="../../../../assets/img/64447.png" alt><br>数组存储区间是连续的，<strong>占用内存严重</strong>，故<strong>空间复杂度很大</strong>。但数组的<strong>二分查找时间复杂度小</strong>，为O(1)；数组的特点是：<strong>寻址容易，插入和删除困难</strong>；<br>链表存储区间离散，占用内存比较宽松，故<strong>空间复杂度很小</strong>，但<strong>时间复杂度很大</strong>，达O(n)。链表的特点是：<strong>寻址困难，插入和删除容易</strong>。<br>HashMap的设计正是分别结合了数组和链表的优点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-hash算法"><a href="#3-hash算法" class="headerlink" title="3.hash算法"></a>3.hash算法</h3><p>首先获取对象的hashCode()值，然后将hashCode值右移16位，然后将右移后的值与原来的hashCode做<strong>异或</strong>(^)运算，返回结果。(其中h&gt;&gt;&gt;16，在JDK1.8中，优化了高位运算的算法，使用了零扩展，无论正数还是负数，都在高位插入0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-put"><a href="#4-put" class="headerlink" title="4.put()"></a>4.put()</h3><p>HashMap并没有直接提供putVal接口给用户调用，而是提供的put方法，而put方法就是通过putVal来插入元素的。<br><img data-src="../../../../assets/img/hashmap_put.png" alt></p>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//put函数的核心处理函数</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//HashMap是懒加载，所有的put先检查table数组是否已经初始化，没有初始化则进行扩容数组初始化table数组，保证table数组一定初始化</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//通过hash算法(n - 1) &amp; hash找到数组下标得到数组元素，为空则新建</span></span><br><span class="line">       <span class="comment">//(n-1)&amp;hash就等价于hash%n。&amp;运算的效率高于%运算。</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//找到数组元素，hash相等同时key相等，则直接覆盖，执行赋值操作</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">// hash值不相等，即key不相等</span></span><br><span class="line">           <span class="comment">//判断链表是否是红黑树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//放入树中</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//遍历当前的链表，一直遍历到链表末尾</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">//到达链表的尾部</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//在尾部插入结点(JDK1.8之前采用头插法，JDK1.8之后采用尾插法，使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环)</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//当链表长度超过8(阈值)，就会将链表便转化为红黑树</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">//用新值替换旧值</span></span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//记录修改次数</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//判断是否需要扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>HashMap的数据存储实现流程</strong></p>
<ol>
<li><p>根据key计算得到key.hash = <code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>；</p>
</li>
<li><p>根据key.hash计算得到桶数组的索引index = key.hash &amp; (table.length - 1)，这样就找到该key的存放位置了<br> ① 如果该位置没有数据，用该数据新生成一个节点保存新数据，返回null；<br> ② 如果该位置有数据是一个红黑树，那么执行相应的插入 / 更新操作；<br> ③ 如果该位置有数据是一个链表，分两种情况一是该链表没有这个节点，另一个是该链表上有这个节点，注意这里判断的依据是key.hash是否一样：<br> 如果该链表没有这个节点，那么采用尾插法新增节点保存新数据，返回null；如果该链表已经有这个节点了，那么找到该节点并更新新数据，返回老数据。<br> 注意：<br> HashMap的put会返回key的上一次保存的数据，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"A"</span>)); <span class="comment">// 打印null</span></span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"AA"</span>)); <span class="comment">// 打印A</span></span><br><span class="line">System.out.println(map.put(<span class="string">"a"</span>, <span class="string">"AB"</span>)); <span class="comment">// 打印AA</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-get"><a href="#5-get" class="headerlink" title="5.get()"></a>5.get()</h3><p>HashMap同样并没有直接提供getNode接口给用户调用，而是提供的get方法，而get方法就是通过getNode来取得元素的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//若table已经初始化，长度大于0，根据hash寻找table中的项也不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//永远检查第一个node，桶中第一项(数组元素)相等</span></span><br><span class="line">        <span class="comment">//在Hashmap1.8中，无论是存元素还是取元素，都是优先判断bucket上第一个元素是否匹配，而在1.7中则是直接遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//一次就匹配到了，直接返回，</span></span><br><span class="line">        	<span class="comment">//否则进行搜索</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//红黑树搜索/查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表搜索(查找)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基本流程:</strong></p>
<ol>
<li>根据key计算hash;</li>
<li>检查数组是否为空，为空返回null;</li>
<li>根据hash计算bucket位置，如果bucket第一个元素是目标元素，直接返回。否则执行4;</li>
<li>如果bucket上元素大于1并且是树结构，则执行树查找。否则执行5;</li>
<li>如果是链表结构，则遍历寻找目标</li>
</ol>
<h3 id="6-resize"><a href="#6-resize" class="headerlink" title="6.resize()"></a>6.resize()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//定义了一个临时Node类型的数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//判断目前的table数组是否为空，记录下当前数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="comment">//如果已达到最大容量不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//通过位运算扩容到原来的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//用构造器初始化了阈值，将阈值直接赋值给容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//初始化新的Node类型数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//当原来的table不为空，需要将数据迁移到新的数组里面去</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//开始对原table进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//取出这个数组第一个不为空的元素</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将旧的hash桶数组在j结点处设置为空，把空间释放掉，方便gc</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e后面没有Node结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//计算相应的hash值，把节点存储到新table的对应位置处</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">///如果e是红黑树的类型，按照红黑树的节点移动</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;<span class="comment">//将Node结点的next赋值给next</span></span><br><span class="line">                        <span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算为0</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算不为0</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/resize_01.png" alt><br><img data-src="../../../../assets/img/resize_02.png" alt><br><img data-src="../../../../assets/img/resize_03.png" alt></p>
<h3 id="7-面试题"><a href="#7-面试题" class="headerlink" title="7.面试题"></a>7.面试题</h3><ol>
<li>Object若不重写hashcode()的话，hashcode是如何计算出来的？<br>Object的hashcode()方法是本地方法，该方法直接返回对象的内存地址，如果不重写hashcode()，则任何对象的hashcode都不相等。(然而hashmap想让部分值的hashcoe值相等，所以需要重写)</li>
<li>为什么重写equals()还要重写hashcode()？<br>HashMap中比较key先求出key的hashcode()，比较其值是否相等，相等则比较equals()，若相等则认为它们是相等的，若equals()不相等则认为它们是不相等的。<br>如果只重写equals()不重写hashcode()，就会导致相同的key值被认为不同(如果不重写hashcode()，则任何对象的hashcode都不相等)，就会在HashMap中存储相同的key值(map中key值不能相同)。<br>①如果两个对象相同（equals()比较返回true)，那么它们的hashcode值一定相同；<br>②如果两个对象的hashcode值相同，它们并不一定相同(equals()比较返回false)</li>
</ol>
]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>源码</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/27273/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Redis概述"><a href="#1-Redis概述" class="headerlink" title="1.Redis概述"></a>1.Redis概述</h3><p>redis是一款高性能的NOSQL系列的非关系型数据库</p>
<h4 id="1-1-什么是NoSQL"><a href="#1-1-什么是NoSQL" class="headerlink" title="1.1 什么是NoSQL"></a>1.1 什么是NoSQL</h4><p>​    NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。<br>​    随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了<strong>解决大规模数据集和多重数据种类</strong>带来的挑战，尤其是大数据应用难题。</p>
<h5 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1 NOSQL和关系型数据库比较"></a>1.1.1 NOSQL和关系型数据库比较</h5><a id="more"></a>

<p><strong>优点：</strong><br>            (1) 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。<br>            (2) 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。<br>            (3) 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。<br>            (4) 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</p>
<p><strong>缺点：</strong><br>            (1) 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。<br>            (2) 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。<br>            (3) 不提供关系型数据库对事务的处理。</p>
<h5 id="1-1-2-非关系型数据库的优势"><a href="#1-1-2-非关系型数据库的优势" class="headerlink" title="1.1.2 非关系型数据库的优势"></a>1.1.2 非关系型数据库的优势</h5><p>​            (1) 性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。<br>​            (2) 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
<h5 id="1-1-3-关系型数据库的优势"><a href="#1-1-3-关系型数据库的优势" class="headerlink" title="1.1.3 关系型数据库的优势"></a>1.1.3 关系型数据库的优势</h5><p>​            (1) 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。<br>​            (2) 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<h5 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4 总结"></a>1.1.4 总结</h5><p>​        关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行<strong>弥补</strong>。<br>​        <strong>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</strong></p>
<h4 id="1-2-主流的产品"><a href="#1-2-主流的产品" class="headerlink" title="1.2 主流的产品"></a>1.2 主流的产品</h4><p><strong>常见的关系型数据库:</strong> <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9PcmFjbGUvMzAxMjA3">Oracle<i class="fa fa-external-link-alt"></i></span>、DB2、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NeVNRTC80NzEyNTE=">MySQL<i class="fa fa-external-link-alt"></i></span>、[SQL Server](<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NaWNyb3NvZnQ=">https://baike.baidu.com/item/Microsoft<i class="fa fa-external-link-alt"></i></span> SQL Server/2947866)</p>
<p><strong>常见的非关系型数据库:</strong> Redis、MongodDB、HBase、Neo4J</p>
<p>(1) 键值(Key-Value)存储数据库<br>        相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB<br>            典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>            数据模型： 一系列键值对<br>            优势： 快速查询<br>            劣势： 存储的数据缺少结构化</p>
<p>(2) 列存储数据库<br>        相关产品：Cassandra, HBase, Riak<br>            典型应用：分布式的文件系统<br>            数据模型：以列簇式存储，将同一列数据存在一起<br>            优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>            劣势：功能相对局限</p>
<p>(3) 文档型数据库<br>        相关产品：CouchDB、MongoDB<br>            典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>            数据模型： 一系列键值对<br>            优势：数据结构要求不严格<br>            劣势： 查询性能不高，而且缺乏统一的查询语法</p>
<p>(4) 图形(Graph)数据库<br>        相关数据库：Neo4J、InfoGrid、Infinite Graph<br>            典型应用：社交网络<br>            数据模型：图结构<br>            优势：利用图结构相关算法。<br>            劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p>
<h4 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h4><p>​    Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：<br>​        (1) 字符串类型 string<br>​        (2) 哈希类型 hash<br>​        (3) 列表类型 list<br>​        (4) 集合类型 set<br>​        (5) 有序集合类型 sortedset</p>
<p><strong>redis的应用场景</strong></p>
<ul>
<li><strong>缓存</strong>（数据查询、短连接、新闻内容、商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li><strong>任务队列（秒杀、抢购、12306等等）</strong></li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h3 id="2-常用命令操作"><a href="#2-常用命令操作" class="headerlink" title="2.常用命令操作"></a>2.常用命令操作</h3><h4 id="2-1-redis的数据结构"><a href="#2-1-redis的数据结构" class="headerlink" title="2.1 redis的数据结构"></a><strong>2.1 redis的数据结构</strong></h4><p>redis存储的是：key, value格式的数据，其中key都是字符串，value有5种不同的数据结构</p>
<p>value的数据结构：<br>    (1) 字符串类型 string<br>    (2) 哈希类型 hash ： map格式<br>    (3) 列表类型 list ： linkedlist格式。支持重复元素<br>    (4) 集合类型 set  ： 不允许重复元素<br>    (5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</p>
<p><strong>字符串类型 string</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">存储： set key value</span><br><span class="line">		127.0.0.1:6379&gt; set username zhangsan</span><br><span class="line">		OK</span><br><span class="line">获取： get key</span><br><span class="line">		127.0.0.1:6379&gt; get username</span><br><span class="line">		"zhangsan"</span><br><span class="line">删除： del key</span><br><span class="line">		127.0.0.1:6379&gt; del age</span><br><span class="line">		(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>哈希类型 hash</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">存储： hset key field value</span><br><span class="line">		127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">		(integer) 1</span><br><span class="line">		127.0.0.1:6379&gt; hset myhash password 123</span><br><span class="line">		(integer) 1</span><br><span class="line"></span><br><span class="line">获取： hget key field: 获取指定的field对应的值</span><br><span class="line">		127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">		"lisi"</span><br><span class="line"></span><br><span class="line">	  hgetall key：获取所有的field和value</span><br><span class="line">		127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">		1) "username"</span><br><span class="line">		2) "lisi"</span><br><span class="line">		3) "password"</span><br><span class="line">		4) "123"</span><br><span class="line"></span><br><span class="line">删除： hdel key field</span><br><span class="line">		127.0.0.1:6379&gt; hdel myhash username</span><br><span class="line">		(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>列表类型 list: 可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">添加：</span><br><span class="line">	lpush key value: 将元素加入列表左表</span><br><span class="line"></span><br><span class="line">	rpush key value：将元素加入列表右边	</span><br><span class="line">		127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">		(integer) 1</span><br><span class="line">		127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">		(integer) 2</span><br><span class="line">		127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">		(integer) 3</span><br><span class="line"></span><br><span class="line">获取：</span><br><span class="line">	lrange key start end ：范围获取</span><br><span class="line">		127.0.0.1:6379&gt; lrange myList 0 -1</span><br><span class="line">		(1) "b"</span><br><span class="line">		(2) "a"</span><br><span class="line">		(3) "c"</span><br><span class="line"></span><br><span class="line">删除：</span><br><span class="line">	lpop key： 删除列表最左边的元素，并将元素返回</span><br><span class="line"></span><br><span class="line">	rpop key： 删除列表最右边的元素，并将元素返回</span><br></pre></td></tr></table></figure>

<p><strong>集合类型 set : 不允许重复元素</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">存储：sadd key value</span><br><span class="line">			127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">			(integer) 1</span><br><span class="line">			127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">			(integer) 0</span><br><span class="line"></span><br><span class="line">获取：smembers key:获取set集合中所有元素</span><br><span class="line">			127.0.0.1:6379&gt; smembers myset</span><br><span class="line">			(1) "a"</span><br><span class="line"></span><br><span class="line">删除：srem key value:删除set集合中的某个元素	</span><br><span class="line">			127.0.0.1:6379&gt; srem myset a</span><br><span class="line">			(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">存储：zadd key score value</span><br><span class="line">				127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">				(integer) 1</span><br><span class="line">				127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">				(integer) 1</span><br><span class="line">				127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">				(integer) 1</span><br><span class="line">获取：zrange key start end [withscores]</span><br><span class="line">				127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">				(1) "lisi"</span><br><span class="line">				(2) "zhangsan"</span><br><span class="line">				(3) "wangwu"</span><br><span class="line"></span><br><span class="line">				127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">				(1) "zhangsan"</span><br><span class="line">				(2) "60"</span><br><span class="line">				(3) "wangwu"</span><br><span class="line">				(4) "80"</span><br><span class="line">				(5) "lisi"</span><br><span class="line">				(6) "500"</span><br><span class="line"></span><br><span class="line">删除：zrem key value</span><br><span class="line">				127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">				(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="2-2-通用命令"><a href="#2-2-通用命令" class="headerlink" title="2.2 通用命令"></a>2.2 通用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. keys * : 查询所有的键</span><br><span class="line">2. type key ： 获取键对应的value的类型</span><br><span class="line">3. del key：删除指定的key value</span><br></pre></td></tr></table></figure>

<h3 id="3-Java客户端-Jedis"><a href="#3-Java客户端-Jedis" class="headerlink" title="3.Java客户端 Jedis"></a>3.Java客户端 Jedis</h3><h4 id="3-1-Jedis操作各种redis中的数据结构"><a href="#3-1-Jedis操作各种redis中的数据结构" class="headerlink" title="3.1 Jedis操作各种redis中的数据结构"></a>3.1 Jedis操作各种redis中的数据结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line"> 		Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">			<span class="comment">//2. 操作</span></span><br><span class="line">			jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"> 		<span class="comment">//3. 关闭连接</span></span><br><span class="line"> 		jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>字符串类型 string</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">//存储</span></span><br><span class="line">      jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">      <span class="comment">//获取</span></span><br><span class="line">      String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">      System.out.println(username);</span><br><span class="line">      <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">      jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);<span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>哈希类型 hash: map格式</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// 存储hash</span></span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">      jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line">      <span class="comment">// 获取hash</span></span><br><span class="line">      String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">      System.out.println(name);</span><br><span class="line">      	        <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">      Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// keyset</span></span><br><span class="line">      Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line">      <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">          <span class="comment">//获取value</span></span><br><span class="line">          String value = user.get(key);</span><br><span class="line">          System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>列表类型 list:  linkedlist格式 支持重复元素</strong></p>
<p>​    lpush / rpush<br>​    lpop / rpop<br>​    lrange start end : 范围获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// list 存储</span></span><br><span class="line">      jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从左边存</span></span><br><span class="line">      jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);<span class="comment">//从右边存</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// list 弹出</span></span><br><span class="line">      String element1 = jedis.lpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element1);</span><br><span class="line">	</span><br><span class="line">      String element2 = jedis.rpop(<span class="string">"mylist"</span>);<span class="comment">//c</span></span><br><span class="line">      System.out.println(element2);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">// list 范围获取</span></span><br><span class="line">      List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mylist2);</span><br><span class="line">	</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>集合类型 set: 不允许重复元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// set 存储</span></span><br><span class="line">      jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line">      <span class="comment">// set 获取</span></span><br><span class="line">      Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">      System.out.println(myset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>有序集合类型 sortedset: 不允许重复元素，且元素有顺序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 获取连接</span></span><br><span class="line">      Jedis jedis = <span class="keyword">new</span> Jedis();<span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">      <span class="comment">//2. 操作</span></span><br><span class="line">      <span class="comment">// sortedset 存储</span></span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">      jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line">      <span class="comment">// sortedset 获取</span></span><br><span class="line">      Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">      System.out.println(mysortedset);</span><br><span class="line">      <span class="comment">//3. 关闭连接</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-jedis连接池-JedisPool"><a href="#3-2-jedis连接池-JedisPool" class="headerlink" title="3.2 jedis连接池: JedisPool"></a>3.2 jedis连接池: JedisPool</h4><pre><code>* 使用：
    1. 创建JedisPool连接池对象
2. 调用方法 getResource()方法获取Jedis连接</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">      JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">      config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">      JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">		</span><br><span class="line">      <span class="comment">//2.获取连接</span></span><br><span class="line">      Jedis jedis = jedisPool.getResource();</span><br><span class="line">      <span class="comment">//3. 使用</span></span><br><span class="line">      jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line">     	<span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">      jedis.close();</span><br></pre></td></tr></table></figure>

<p><strong>连接池工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL执行慢分析及SQL语句优化</title>
    <url>/31546/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-SQL语句执行速度慢"><a href="#1-SQL语句执行速度慢" class="headerlink" title="1.SQL语句执行速度慢"></a>1.SQL语句执行速度慢</h3><p>一个SQL语句执行的速度很慢, 分两种情况讨论:</p>
<ul>
<li><p>大多数情况下很正常, 偶尔很慢, 则有如下原因:</p>
<ol>
<li>数据库在刷新脏页</li>
<li>执行的时候, 遇到锁, 如表锁, 行锁</li>
</ol>
</li>
<li><p>一直执行很慢, 则有如下原因</p>
</li>
</ul>
<a id="more"></a>

<ol>
<li>没有用上索引: 例如该字段没有索引, 由于对字段进行运算, 函数操作导致无法使用索引<ol start="2">
<li>数据库选错了索引</li>
</ol>
</li>
</ol>
<h3 id="2-SQL语句的优化"><a href="#2-SQL语句的优化" class="headerlink" title="2.SQL语句的优化"></a>2.SQL语句的优化</h3><ol>
<li><p>设置合适的字段属性</p>
<p> 字段的长度越小, 占用的内存越小, 性能就越好; 例如,中国的手机号码为11位, vachar的长度设置为11位即可</p>
</li>
<li><p>使用join语法</p>
<p>join语法分为内连接, 左(外)连接, 右(外)连接</p>
</li>
<li><p>尽量少使用select *</p>
<p>select *会进行全表查询, 消耗的性能较大</p>
</li>
<li><p>在查找唯一一条数据的时候, 使用limit 1, 在查找到数据的时候会终止查找</p>
</li>
<li><p>使用limit分页</p>
</li>
<li><p>尽量少使用排序order by, order by DESC, order by ASC</p>
</li>
<li><p>避免进行类型转换</p>
</li>
<li><p>使用索引</p>
<ul>
<li><p>优点: 加快索引速度</p>
</li>
<li><p>缺点: 创建索引和维护索引需要耗费时间和精力</p>
<p>​          索引需要占用空间</p>
<p>​          进行数据的增删改查时需要动态维护索引</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis五种数据类型的底层结构</title>
    <url>/redisfive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RedisObject:  </p>
<p>Redis 中只有一个 K，一个 V。其中 K 绝对是字符串对象，而 V 可以是 String、List、Hash、Set、ZSet 任意一种。</p>
<a id="more"></a>

<img data-src="../../../../assets/img/16e68ee882352143.jpg" style="zoom: 50%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型 string list set hash zset等 4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式 4bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU 时间 24bit</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; </span><br><span class="line">    <span class="comment">// 引用计数  4byte</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向对象的指针  8byte	指针指向具体的数据，如set test hello，ptr指向的就是存储hello的字符串。</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>encoding：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对象编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0    <span class="comment">// 编码为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1    <span class="comment">// 编码为整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2     <span class="comment">// 编码为哈希表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3 <span class="comment">// 编码为 zipmap(2.6 后不再使用)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">// 编码为双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5    <span class="comment">// 编码为压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6     <span class="comment">// 编码为整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7    <span class="comment">// 编码为跳跃表</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>lru</p>
<p>记录对象最后一次被命令程序访问的时间，通过lru时间和当前时间可以计算某个对象的空转时间；利用object idletiem命令可以显示空转时间(单位为秒)，且不会改变该对象的lru。</p>
</li>
<li><p>refcount</p>
<p>该对象被引用的次数，目前共享对象只支持整数值的字符串对象。</p>
</li>
</ul>
<h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><p>三种编码方式：</p>
<ul>
<li><p>int：存储的字符串全是数字</p>
</li>
<li><p>embstr：存储的字符串长度小于44个字符</p>
</li>
<li><p>raw：存储的字符串长度大于44个字符</p>
<img data-src="../../../../assets/img/927112.png" style="zoom:50%;">

<p>embstr类型，它的数据指针和SDS对象在内存地址是连在一起的；但对于raw类型，二者在内存地址不是连续的。</p>
</li>
</ul>
<p>SDS封装char[]，一个SDS最大512M</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span>  </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len; <span class="comment">// 标记char[]的长度  </span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//标记char[]中未使用的元素个数  </span></span><br><span class="line">	<span class="keyword">char</span> buf[]; <span class="comment">// 存放元素的坑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis底层对SDS做的优化</p>
<ul>
<li><p>预空间分配</p>
<p>SDS长度(len的值)小于1MB，那么程序将分配和len属性同样大小的未使用空间，此时 free和len属性值相同。假如SDS的len将变成15字节，则程序也会分配15字节的未使用空间，SDS的buf数组的实际长度变为15+15+1=31字节(额外一个字节用户保存空字符串)</p>
<p>SDS长度(len的值)大于等于1MB，程序会分配1MB的未使用空间。如进行修改之后，SDS的len变成30MB，那么它的实际长度为30MB+1MB+1byte</p>
</li>
<li><p>惰性释放空间</p>
<p>当执行sdstrim(截取字符串)之后，SDS不会立即释放多出来的空间，如果下次在进行字符串拼接操作，且拼接的没有刚才释放的大，就会使用刚才的空间，不需要再重新申请空间。</p>
</li>
<li><p>二进制安全</p>
<p>C语言通过是否存在空字符\0来判断是否已经是字符串的结尾。某些情况下(如使用空格进行分割一段字符串、或图片、视频等二进制文件)时，就会出现问题。SDS通过len字段判断，因此具备二进制安全性。</p>
</li>
</ul>
<h4 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h4><p>quickList(快速列表，是zipList压缩列表和linkedList双端链表的组合)，最大长度2^32-1，自测两端插入和弹出，并可以获得指定位置(或范围)的元素，可以充当数组、队列和栈。</p>
<ul>
<li>lpush+lpop 先进后出的栈</li>
<li>lpush+rpop 先进先出的队列</li>
<li>lpush+ltrim 有限集合</li>
<li>lpush+Brpop 消息队列</li>
</ul>
<ol>
<li><p>linkedList</p>
<p><img data-src="../../../../assets/img/61997662.png" alt></p>
<img data-src="../../../../assets/img/20678379.jpg" style="zoom: 50%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义链表节点的结构体 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表包含节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点复制函数，用于链表转移复制时对节点value拷贝的实现，一般情况下使用等号，某些特殊情况下给这个函数赋值NULL即表示使用等号进行节点转移</span></span><br><span class="line">    vode *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点释放函数，用于释放一个节点所占用的内存空间，默认赋值NULL，即使用Redis自带的zfree函数进行内存空间释放</span></span><br><span class="line">    vode *(*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点对比函数，用于对比两个链表节点的value是否相等，相等返回1，不相等返回0</span></span><br><span class="line">    vode *(*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取前置节点、后置节点、表头节点和表尾节点的复杂度都是O(1)，获取节点数量也是O(1)。与双端链表相比，压缩列表可以节省空间，但进行修改或增删操作时，复杂度较高；因此节点数量较少时，可以使用压缩列表，但节点数量较多时，还是使用双端链表。</p>
</li>
<li><p>zipList</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">    <span class="comment">//压缩列表占用字符数</span></span><br><span class="line">    int32 zlbytes;</span><br><span class="line">    <span class="comment">//最后一个元素距离起始位置的偏移量，用于快速定位最后一个节点</span></span><br><span class="line">    int32 zltail_offset;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    int16 zllength;</span><br><span class="line">    <span class="comment">//元素内容</span></span><br><span class="line">    T[] entries;</span><br><span class="line">    <span class="comment">//结束位 0xFF</span></span><br><span class="line">    int8 zlend;</span><br><span class="line">&#125;ziplist</span><br><span class="line">    </span><br><span class="line">typede <span class="class"><span class="keyword">struct</span> <span class="title">entry</span>&#123;</span></span><br><span class="line">    <span class="comment">//前一个entry的长度，倒序遍历可以通过这个参数定位到上一个entry的位置</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prelen;</span><br><span class="line">    <span class="comment">//元素类型编码</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding;</span><br><span class="line">    <span class="comment">//元素内容</span></span><br><span class="line">    optional <span class="keyword">byte</span>[] content;</span><br><span class="line">&#125;entry</span><br></pre></td></tr></table></figure>

<img data-src="../../../../assets/img/815422.png" style="zoom:67%;">

<p>zltail_offset这个参数可以快速定位到最后一个entry节点的位置，然后开始倒序遍历，即ziplist支持双向遍历。zipList遍历的时候，先根据zlbytes和zltail_offset定位到最后一个entry的位置，然后根据根据entry的prelen时确定前一个entry的位置。</p>
<p>zipList相比linkedList少了pre和next两个指针16个字节(64位系统1个指针就是8个字节)，linkedList每个节点内存都是单独分配，家具内存碎片化，zipList是由连续的内存组成的。</p>
<ul>
<li><p>连锁更新</p>
<p>entry的prelen字段：前一个节点的长度小于254个字节时，prelen长度为1字节；前一个节点的长度大于254个字节时，prelen长度为5字节</p>
<img data-src="../../../../assets/img/257464978.png" style="zoom: 50%;">

<p>假设现在有一组压缩列表，长度都在250~253字节之间，突然新增一个entry节点，这个entry节点长度大于等于254字节。由于新的entry节点大于等于254字节，这个entry节点的prelen为5个字节，随后会导致其余的所有entry节点的prelen增大为5字节；同样地，删除操作也会导致出现<strong>连锁更新</strong>这种情况。</p>
</li>
<li><p>zipList与linkedList的区别</p>
<p>当列表中元素的长度较小或数量较少时，通常采用zipList，当列表中元素长度较大或者数量较多时，使用linkedList</p>
<ol>
<li>双向链表linkedList便于在列表的两端进行push和pop，插入节点复杂度很低，但内存开销比较大。(额外保存prev和next指针；内存碎片)</li>
<li>zipList存储在一块连续的内存上，所以存储效率高，但插入和删除操作需要频繁的申请和释放内存。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>3.2版本之后List使用quickList代替了zipList和linkedList，是zipList和linkedList的混合体。它将linkedList按段切分，每一段使用zipList来紧凑存储，多个zipList之间使用双向指针串接起来。</p>
<img data-src="../../../../assets/img/12ss239.png" style="zoom: 80%;">

<p>quickList内部默认单个zipList长度为8k字节，即redis.conf中list-max-ziplist-size的值为-2，超过这个阈值就会重新生成一个zipList来存储数据。当list-max-ziplist-size为正数n时，表示每个quicklist节点上的ziplist最多包含n个数据项。</p>
<ul>
<li><p>压缩深度</p>
<p>quickList可以使用LZF算法对zipList进一步压缩，压缩后的zipList结构为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">ziplist_compressed</span>&#123;</span></span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    int32 <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//元素内容</span></span><br><span class="line">    <span class="keyword">byte</span>[] compressed_data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时quicList为：</p>
<img data-src="../../../../assets/img/83331710.png" style="zoom:50%;">

<p>redis.conf中list-compress-depth表示一个quickList两端不被压缩的节点的个数(指quickList双向链表节点个数，而不是zipList里数据项个数)，quickList默认压缩深度为0，即不开启压缩；当list-compress-depth为1，表示quickList的两端各有1个节点不进行压缩，中间节点进行压缩；当list-compress-dept为2，表示quickList的首尾各有2个节点不进行压缩，中间节点进行压缩；由此类推，对于quickList来说，首尾两个节点永远不会被压缩。</p>
</li>
</ul>
<h4 id="3-Hash"><a href="#3-Hash" class="headerlink" title="3.Hash"></a>3.Hash</h4><ul>
<li><p>dict</p>
<p>底层可以是zipList或hashtable(字典也叫哈希表)，hash中元素数量小于512个且所有键值对的键和值字符串长度都小于64字节时，才会使用zipList。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//类型特定函数，包括一些自定义函数，这些函数使得key和value能够存储</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;<span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//两张hash表 </span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;<span class="comment">//rehash索引，字典没有进行rehash时，此值为-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">//正在迭代的迭代器数量</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<ul>
<li>type和private这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对于的一些复制、比较函数也不一样。</li>
<li>rehashidx，这是一个辅助变量，用于记录rehash过程的进度，以及是否正在进行rehash等信息，等于-1时，表示dict此时没有rehash过程。</li>
<li>iterators，记录此时dict有几个迭代器正在进行遍历过程。</li>
</ul>
</li>
<li><p>dictht</p>
<p>dict本质上是对dicht的一个简单封装</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table;<span class="comment">//存储数据的dicEntry类型的数组 二维</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//数组的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表的大小的掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//// 哈希表中中元素个数</span></span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dicthtEntry</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;<span class="comment">//键</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> val;</span><br><span class="line">        <span class="keyword">unit64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;v;<span class="comment">//值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>；//指向下一个节点的指针</span></span><br><span class="line"><span class="class">&#125;<span class="title">dictEntry</span>;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<img data-src="../../../../assets/img/713878.png" style="zoom: 67%;">

<ul>
<li><p>扩容与缩容</p>
<p><strong>渐进式hash</strong></p>
<ol>
<li>假设当前数据在dictht[0]中，那么首先未dictht[1]分配足够的空间，如果是扩容，则dictht[1]的大小按照扩容规则进行扩容，如果是缩减，则dictht[1]的大小按照缩减规则进行缩减。</li>
<li>在字典dict中维护一个变量，rehashidx=0，表示rehash正式开始。</li>
<li>rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，还会顺带将dictht[0]哈希表在rehashidx索引上的所有键值对rehash到dichth[1]，当一次rehash工作完成之后，程序将rehashidx属性的值+1。同时在serverCron中调用rehash相关函数，在1ms的时间内，进行rehash处理，每次仅处理少量的转移任务(100个元素)。</li>
<li>当dichth[0]的所有键值对都会被rehash至dichth[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li>
</ol>
<ul>
<li><p>每次对字典执行增删改查才会触发rehash，万一某段时间没有任何命令请求命令呢？</p>
<p>Redis有一个定时器，会定时判断rehash是否完成，如果没有完成，则继续hash。</p>
</li>
<li><p>如果是添加操作，会将新的数据直接添加到dichth[1]上，而对于删除、更改、查询操作，会直接在dictht[0]上进行，当dictht[0]上查询不到时，会接着去dictht[1]上查找，如果再找不到，则表明不存在该K-V值。</p>
</li>
<li><p>优点：采用分而治之的思想，将rehash操作分散到每一次到hash表的操作上及定时函数上，避免了集中式hash带来的性能压力。</p>
</li>
<li><p>缺点：在rehash过程中，需要保存两个hash表，对内存的占用比较大，如果在Redis服务器本来内存满了的时候，突然进行rehash会造成大量的key被抛弃。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><p>无序且存储元素不重复。当value是整数时，且数据量不大时使用inset存储，其他情况用字典dict来存储。</p>
<ul>
<li><p>inset</p>
<img data-src="../../../../assets/img/691122.png" style="zoom: 67%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">inset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;<span class="comment">//编码方式 有三种 默认 INSET_ENC_INT16 会根据插入数据的大小选择不一样的类型来存储</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;<span class="comment">//集合元素个数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];<span class="comment">//实际存储元素的数组，元素类型并不一定是ini8_t类型，柔性数组不占intset结构体大小，并且数组中的元素从小到大排列</span></span><br><span class="line">&#125;inset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))   <span class="comment">//16位，2个字节，表示范围-32,768~32,767</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))   <span class="comment">//32位，4个字节，表示范围-2,147,483,648~2,147,483,647</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))   <span class="comment">//64位，8个字节，表示范围-9,223,372,036,854,775,808~9,223,372,036,854,775,807</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>inset升级过程</p>
<ol>
<li>了解旧的存储格式，计算出目前已有元素占用大小，计算规则是length*encoding，如4 * 16=64</li>
<li>确定新的编码格式，当原有的编码格式不能存储下新增的数据时，此时就要选择新的合适的编码格式</li>
<li>根据新的编码格式计算出需要新增的内存大小，然后从尾部将数据插入</li>
<li>根据新的编码格式重置之前的值，此时contents存在两种编码格式的值，需要统一，从插入新数据的位置开始，从后向前将之前的数据按照新的编码格式进行移动和设置。从后往前是为了防止数据被覆盖。<ul>
<li>优点：根据存入的数据选择合适的编码方式，且只在必要的时候进行升级操作，节省内存。</li>
<li>缺点：耗费系统资源，不支持降级。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="5-SortedSet"><a href="#5-SortedSet" class="headerlink" title="5.SortedSet"></a>5.SortedSet</h4><p>常用作排行榜等功能，以用户id为value，关注事件或者分数作为score进行排序。zipList和skipList两种不同的实现：</p>
<ol>
<li><p>zipList</p>
<img data-src="../../../../assets/img/10660324.png" style="zoom: 80%;">

<ul>
<li>[score,value]键值对数量少于128个</li>
<li>每个元素的长度小于64字节</li>
</ul>
</li>
<li><p>skipList</p>
<img data-src="../../../../assets/img/2127064.png" style="zoom: 80%;">

<p>不满足以上两个条件时使用跳表、组合了hash和skipList，hash用来存储value到score的映射，这样就可以在O(1)时间内找到value对应的分数；skipList按照从小到大的顺序存储分数；skipList每个元素的值都是[score,value]对。</p>
</li>
</ol>
<ul>
<li><p>skipList</p>
<p>空间换时间</p>
<p>跳表一个节点最高可以达到64层，一个跳表中最多可以存储2^64个元素。跳表中，每个节点都是一个skipListNode，每个跳表的节点也都会维护一个score值，这个值在跳表中是按照从小到大的顺序排列好的。</p>
<img data-src="../../../../assets/img/46487426.png" style="zoom: 80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>;</span></span><br><span class="line">    <span class="comment">//尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//跳表中元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<img data-src="../../../../assets/img/333718.png" style="zoom: 80%;">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedf <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    sds ele;<span class="comment">// 具体的数据 每个节点所保存的数据是唯一的，但节点的分数可以是一样的。两个相同分数的节点是按照元素的字典序进行排列的；</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">// 分数 从小到大排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针，用于从表尾向表头遍历，每个节点只有一个，即每次只能后退一步</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//前进指针forward，指向下一个节点</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">//跨度span用来计算当前节点在跳表中的一个排名</span></span><br><span class="line">    &#125;level[];<span class="comment">//层级数组 最大32</span></span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>

<img data-src="../../../../assets/img/RedisskipList跳表.png" style="zoom: 80%;">

</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Sping Cloud Alibaba</title>
    <url>/SpringCloudAlibaba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-主要功能"><a href="#1-主要功能" class="headerlink" title="1.主要功能"></a>1.主要功能</h3><ul>
<li><p>服务限流降级</p>
</li>
<li><p>服务注册与发现</p>
</li>
<li><p>分布式配置管理</p>
</li>
<li><p>消息驱动能力</p>
</li>
<li><p>分布式事务</p>
<a id="more"></a>

<p>Spring Cloud Alibaba使用@GlobalTransactional注解，高效并且零入侵地解决分布式事务问题。</p>
</li>
</ul>
<h3 id="2-主要组件"><a href="#2-主要组件" class="headerlink" title="2.主要组件"></a>2.主要组件</h3><ul>
<li><p>Sentinel<br>Sentinel把流量作为切入点，从流量控制、熔断降级、系统负载等多个维度保障服务的稳定性。Sentinel主要分为两部分，客户端在我们的程序中集成，控制台基于Spring Boot开发，打包后直接运行。利用Sertinel流量控制功能可以<strong>对网关、服务进行过载保护</strong>，另一个核心功能是<strong>熔断降级</strong>，与Hystrix一致。</p>
</li>
<li><p>Nacos<br>Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。主要功能有<strong>注册中心</strong>和<strong>配置中心</strong>。<strong>Nacos可以代替Eureka和Apollo</strong>。</p>
</li>
<li><p>RocketMQ<br>分布式消息系统，基于高可用分布式集群技术，提供低延时、高可靠的消息发布与订阅服务。使用消息队列可以让服务之间更加<strong>解耦</strong>，还可以进行<strong>流量削峰</strong>，还可以用<strong>事务消息来实现分布式事务</strong>。</p>
</li>
<li><p>Dubbo<br>Java RPC框架，Spring Cloud Alibaba体系中，服务之间的通信可以使用Dubbo进行远程调用。Rest的优势：通用性强、无语言限制、调试方便，但一般都是JSON格式，报文较大，Dubbo是<strong>二进制传输</strong>，性能更好。Spring Cloud Alibaba中可以将Dubbo和Feign结合使用，即服务可以暴露Dubbo协议，也可以暴露Rest协议，调用方选择对应的协议进行调用，对于性能要求高的使用Dubbo，其它的使用Rest。</p>
</li>
<li><p>Seata<br>分布式事务解决方案，提供了AT、TCC等事务模式。</p>
</li>
</ul>
<h3 id="3-技术选型推荐"><a href="#3-技术选型推荐" class="headerlink" title="3.技术选型推荐"></a>3.技术选型推荐</h3><ul>
<li>服务注册与发现：Nacos</li>
<li>服务熔断限流：Sentinel</li>
<li>服务通信调用：Feign</li>
<li>配置中心：Nacos</li>
<li>服务网关：Spring Cloud Gateway</li>
<li>分布式事务：Seata</li>
<li>消息队列：RocketMQ</li>
<li>调用链监控：Sleuth+Zipkin</li>
<li>分布式任务调度：XXL-JOB</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Sping Cloud组件扩展</title>
    <url>/SpringCloud_02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Apollo"><a href="#1-Apollo" class="headerlink" title="1.Apollo"></a>1.Apollo</h3><p>统一管理配置信息，增强配置管理的服务能力。<br><img data-src="../../../../assets/img/CgotOV28B1WAF4S2AACIYGiePW0196.png" alt><br>使用配置中心管理配置后，可以将配置信息从项目转移到配置中心，一般一个项目会有一个唯一的标识ID，通过这个ID从配置中心获取对应的配置内容。</p>
<a id="more"></a>

<ol>
<li>拉取<br>项目在启动的时候通过配置中心拉取配置信息。</li>
<li>推送<br>在配置中心修改配置后，可以实时地推送给客户端进行更新。</li>
</ol>
<p>解决的问题：每个节点都要重启、格式不规范、容易被错改、没有历史记录、安全性不高</p>
<h4 id="1-1-主要功能"><a href="#1-1-主要功能" class="headerlink" title="1.1 主要功能"></a>1.1 主要功能</h4><ul>
<li>统一管理不同环境、不同集群的配置</li>
<li>配置修改实时生效，即热发布功能</li>
<li>版本发布管理</li>
<li>灰度发布</li>
<li>权限管理、发布审核、操作审计</li>
<li>提供Java和.Net原生客户端，轻松集成、操作简单</li>
<li>提供开放平台API</li>
<li>部署简单</li>
</ul>
<p><strong>Apollo 和 Spring Cloud Config 对比</strong><br><img data-src="../../../../assets/img/CgoB5l28B1WASOkYAAA7y7Kuj4o675.png" alt></p>
<h4 id="1-2-概念介绍"><a href="#1-2-概念介绍" class="headerlink" title="1.2 概念介绍"></a>1.2 概念介绍</h4><ul>
<li><p>应用<br>应用指项目，标识用appId来指定，Spring Boot项目中建议直接配置在application.yml中。</p>
</li>
<li><p>环境<br>Apollo客户端在运行时除了需要知道项目当前的身份标识，还需要知道当前项目对应的环境，从而根据环境去配置中心获取对应的配置。可以通过Java System Property或配置文件指定，目前支持的环境有Local、DEV、FAT(测试环境)、UAT(集成环境)、PRO(生产环境)。</p>
</li>
<li><p>集群<br>不同的集群可以有不同的配置文件，可以通过Java System Property或配置文件来指定。</p>
</li>
<li><p>命名空间<br>可以用来对配置做分类，不同类型的配置存放在不同的命名空间中，如数据库配置文件、消息队列配置、业务相关配置等。命名空间还可以让多个项目共用一份配置，如Redis集群。</p>
</li>
<li><p>权限控制</p>
</li>
</ul>
<h4 id="1-3-架构设计"><a href="#1-3-架构设计" class="headerlink" title="1.3 架构设计"></a>1.3 架构设计</h4><p><img data-src="../../../../assets/img/CgoB5l28B1eAT_QKAAIrr-cSeiQ864.png" alt></p>
<ul>
<li><p>Config Service<br>服务于Client对配置的操作，提供配置的查询、更新接口(基于Http long polling)</p>
</li>
<li><p>Admin Service<br>服务于后台Portal(Web管理端)，提供配置管理接口</p>
</li>
<li><p>Meta Server<br><strong>Meta Server是对Eureka的一个封装，提供了HTTP接口获取Admin Service和Config Service的服务信息。</strong>部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致。</p>
</li>
<li><p>Eureka<br>用于提供服务注册和发现，Config Service和Admin Service都会向Eureka注册服务。Eureka在部署时和Config Service在一个JVM进程中，即<strong>Config Service包含了Meta Server和Eureka</strong>。</p>
</li>
<li><p>Portal<br>后台Web界面管理配置，通过Meta Server获取Admin Service服务列表(IP+Port)进行配置的管理，客户端做负载均衡。</p>
</li>
<li><p>Cilent<br>Apollo提供的客户端，用于项目中对配置的获取、更新。<strong>通过Meta Server获取Config Service服务列表</strong>(IP+Port)进行配置的管理，客户端内做负载均衡。</p>
</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li>注册、续约、取消，也就是服务注册的操作，Config Service和Admin Service都会注册到Eureka中。</li>
<li>服务发现的逻辑，Client需要指定所有的Config Service，Portal需要知道所有的Admin Service，然后才能发起对应的操作。查找服务列表是通过负载进行转发到Meta Server.</li>
<li>Meta Server去Eureka中获取对应的服务列表。</li>
<li>当获取到对应的服务信息后，就可以直接发起远程调用了。</li>
</ol>
<p><strong>推送设计：</strong><br><img data-src="../../../../assets/img/CgotOV28B1eAVl80AADzD_Lkc-w754.png" alt><br>在Portal中进行配置的编辑和发布操作后，Portal会调用Admin Service提供的接口进行发布操作。Admin Service收到请求后，发送ReleaseMessage给各个Config Service，通知Config Service配置发生了变化。Config Service收到ReleaseMessage后，通知对应的客户端，基于HTTP长连接实现。</p>
<p><strong>消息设计：</strong><br><img data-src="../../../../assets/img/CgoB5l28B1iAJa9tAACfTre4O3g300.png" alt><br>ReleaseMessage消息是通过MySQL实现了一个简单的消息队列。Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，Config Service会启动一个线程定时扫描ReleaseMessage表，去查看是否有新的消息记录。Config Service发现有新的消息记录，那么就会通知所有的消息监听器，消息监听器得到配置发布的信息后，则会通知对应的客户端。</p>
<p><strong>客户端设计：</strong><br><img data-src="../../../../assets/img/CgotOV28B1iAHJTnAAFK5jsOc0Q150.png" alt><br>客户端和服务端保持了一个长连接，编译配置的实时更新推送。定时拉取配置是客户端本地的一个定时任务，默认5分钟1次，也可以通过在运行时指定System Property:apollo.refreshInterval来进行覆盖，单位是分钟，采用推送+定时拉取的方式就等于双保险。客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中。客户端会把从服务取到的配置在本地文件系统中缓存一份，当服务或网络不可用时可以使用本地配置，也就是本地开发模式env=Local。</p>
<h3 id="2-分布式链路跟踪"><a href="#2-分布式链路跟踪" class="headerlink" title="2.分布式链路跟踪"></a>2.分布式链路跟踪</h3><p><img data-src="../../../../assets/img/CgotOV3TXSmAClJKAAGdgZ3eA9U538.png" alt><br>分布式链路跟踪的关键在于如何将请求经过的服务节点都关联起来。</p>
<h4 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h4><ul>
<li><p>Span<br>基本工作单元，如发送RPC请求是一个新的Span、发送HTTP请求是一个新的Span、内部方法调用也是一个新的Span。</p>
</li>
<li><p>Trace<br>一次分布式调用的链路信息，每次调用链路信息都会在请求入口处生成一个TraceId。</p>
</li>
<li><p>Annotation<br>用于记录事件的信息。在Annotation中会有CS、SR、SS、CR这些信息。</p>
</li>
<li><p>CS<br>Client Sent，客户端发送一个请求，这个Annotation表示Span的开始。</p>
</li>
<li><p>SR<br>Server Received，服务端获得请求并开始处理，用SR的时间减去CS的时间即网络延迟时间。</p>
</li>
<li><p>SS<br>Server Sent，在请求处理完成时将响应发送回客户端，SR-SS，即服务端处理请求所需的时间。</p>
</li>
<li><p>CR<br>Client Recevied，表示Span结束，客户端从服务端收到响应，CR-CS，即全部时间。</p>
</li>
</ul>
<h4 id="2-2-请求追踪过程分解"><a href="#2-2-请求追踪过程分解" class="headerlink" title="2.2 请求追踪过程分解"></a>2.2 请求追踪过程分解</h4><p><img data-src="../../../../assets/img/CgoB5l3TXSqAAotuAARIqATiaa4975.png" alt></p>
<ol>
<li>当一个请求访问SERVICE1时，此时没有Trace和Span，会生成Trace和Span，如图所示生成Trace ID是X，Span ID是A。</li>
<li>接着SERVICE1请求SERVICE2，这是一次远程请求，会生成一个新的Span，Span ID为B，Trace ID不变还是X。Span B处于CS状态，当请求到达SERVICE2后，SERVICE2有内部操作，生成了一个新的Span，Span ID为C，Trace ID不变。</li>
<li>SERVICE2处理完后向SERVICE3发起请求，生成新的Span，Span ID为D，Span D处于CS状态，SERVICE3接收请求后，Span D处于RS状态，同时SERVICE内部操作也会生成新的Span，Span ID为E。</li>
<li>SERVICE3处理完后，需要将结果响应给调用方，此时Span D处于SS状态，当SERVICE2收到响应后，Span D处于CR状态。</li>
</ol>
<p>一次请求会经过多个服务，会产生多个Span，但Trace ID只有一个。</p>
<h4 id="2-3-Spring-Cloud-Sleuth"><a href="#2-3-Spring-Cloud-Sleuth" class="headerlink" title="2.3 Spring Cloud Sleuth"></a>2.3 Spring Cloud Sleuth</h4><ul>
<li>可以添加链路信息到日志中</li>
<li>链路数据可直接上报给Zipkin</li>
<li>内置了很多框架的埋点，如Zuul、Feign、Hystrix</li>
</ul>
<h4 id="2-4-Zipkin"><a href="#2-4-Zipkin" class="headerlink" title="2.4 Zipkin"></a>2.4 Zipkin</h4><p><img data-src="../../../../assets/img/CgotOV3TXSqAJOtrAAFNEaemXPk128.png" alt><br>收集数据、查询数据。</p>
<ul>
<li><p>Collector<br>Zipkin的数据收集器，进行数据验证、存储。</p>
</li>
<li><p>Storage<br>存储组件，Zipkin默认在内存中存储数据，数据落地的话支持ElasticSearch和MySQL。</p>
</li>
<li><p>Search<br>Zipkin的查询API，用于查找和检索数据，主要使用者为Web UI。</p>
</li>
<li><p>Web UI<br>提供可视化的操作界面，直观的查询链路跟踪数据。</p>
</li>
</ul>
<p>链路跟踪的信息会通过Transport传递给Zipkin的Collector，Transport支持的方式有HTTP和MQ进行传输。</p>
<h4 id="2-5-Sleuth关联整个请求链路日志"><a href="#2-5-Sleuth关联整个请求链路日志" class="headerlink" title="2.5 Sleuth关联整个请求链路日志"></a>2.5 Sleuth关联整个请求链路日志</h4><p>集成Spring Cloud Sleuth后，会在原始的日志加上一些链路的信息。</p>
<ul>
<li><p>application name<br>应用名称，即application.yml里的spring.application.name参数配置的属性。</p>
</li>
<li><p>traceId<br>为请求分配的唯一请求号，用来标识一条请求链路。</p>
</li>
<li><p>spanId<br>基本的工作单元，一个请求可以包含多个步骤，每个步骤有自己的Span ID，一次请求只有一个Trace ID和多个Span Id。</p>
</li>
<li><p>export<br>布尔类型，表示是否将该信息输出到Zipkin进行收集和展示。</p>
</li>
</ul>
<h4 id="2-6-使用技巧"><a href="#2-6-使用技巧" class="headerlink" title="2.6 使用技巧"></a>2.6 使用技巧</h4><ul>
<li><p>抽样采集数据<br>spring.sleuth.sampler.probability=10<br>请求次数：Zipkin数据条数=10：1</p>
</li>
<li><p>RabbitMQ代替HTTP发送调用链路数据<br>删除配置spring.zipkin.base-url，在启动Zipkin服务时指定RabbitMQ信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -DRABBIT_ADDRESSES=192.168.10.124:5672 -DRABBIT_USER=admin -DRABBIT_PASSWORD=123456 -jar zipkin.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>ElasticSearch存储调用链数据<br>启动Zipkin的时候指定存储类型为ES，指定ES的URL信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -DSTORAGE_TYPE=elasticsearch -DES_HOSTS=http://localhost:9200 -jar zipkin.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动埋点检测性能</p>
</li>
<li><p>Hystrix埋点分析</p>
</li>
</ul>
<h3 id="3-微服务安全认证"><a href="#3-微服务安全认证" class="headerlink" title="3.微服务安全认证"></a>3.微服务安全认证</h3><h4 id="3-1-常用的认证方式"><a href="#3-1-常用的认证方式" class="headerlink" title="3.1 常用的认证方式"></a>3.1 常用的认证方式</h4><ul>
<li><p>session<br>用户登陆后将信息存储在服务端，客户端通过cookie中的sessionId来标识对应的用户。</p>
<p>缺点：</p>
<ol>
<li>服务端需要保存每个用户的登录信息，如果用户量非常的，服务端的存储压力也会增大。</li>
<li>多节点时，通过负载均衡器进行转发，session可能会丢失。</li>
</ol>
<p>解决办法：<br>session复制，Nginx可以设置黏性Cookie来保证一个用户的请求只访问同一个节点；session集中存储，如存储在Redis中。</p>
</li>
<li><p>HTTP Basic Authentication<br>HTTP基本认证，客户端会在请求头中增加Authorization，Authorization是用户名和密码Base64加密后的内容，服务端获取Authorization Header中的用户名与密码进行验证。</p>
</li>
<li><p>Token<br>与HTTP Basic Authentication类似，与session不同，session只是一个key，会话信息存储在服务端。而Token中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，服务端拿到Token后进行解密获取用户信息。</p>
</li>
</ul>
<h4 id="3-2-JWT认证"><a href="#3-2-JWT认证" class="headerlink" title="3.2 JWT认证"></a>3.2 JWT认证</h4><p><strong>简介：</strong><br>JWT(JSON Web Token)<br>如用户登录时，基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个Token，用户可以使用这个Token访问服务器上受保护的资源。</p>
<p>JWT由三部分构成：头部(Header)、消息体(Payload)、签名(Signature)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">token = encodeBase64(header) + <span class="string">'.'</span> + encodeBase64(payload) + <span class="string">'.'</span> + encodeBase64(signature)</span><br></pre></td></tr></table></figure>

<p>头部信息：令牌类型、签名算法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"alg"</span>: <span class="string">"HS256"</span>, <span class="attr">"typ"</span>: <span class="string">"JWT"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>消息体：应用需要的信息，如用户的id</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>: <span class="string">"1234567890"</span>, <span class="attr">"name"</span>: <span class="string">"John Doe"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>签名：用来判断消息在传递的路径上是否被篡改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HMACSHA256( base64UrlEncode(header)  + <span class="string">"."</span> +  base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure>

<p><strong>JWT认证流程：</strong><br><img data-src="../../../../assets/img/CgotOV3WUG2ARl98AAD_xcd-ElM857.png" alt><br>客户端需要调用服务端提供的认证接口来获取 Token。获取 Token 的流程如图所示，客户端会首先发起一个认证的请求到网关，网关会将请求转发到后端的用户服务中，在用户服务中验证身份后，就会根据用户的信息生成一个 Token 返回给客户端，这样客户端就获取了后面请求的通行证。然后，客户端会将获取的 Token 存储起来，在下次请求时带上这个 Token，一般会将 Token 放入请求头中进行传递。当请求到达网关后，会在网关中对 Token 进行校验，如果校验成功，则将该请求转发到后端的服务中，在转发时会将 Token 解析出的用户信息也一并带过去，这样在后端的服务中就不用再解析一遍 Token 获取的用户信息，这个操作统一在网关进行的。如果校验失败，那么就直接返回对应的结果给客户端，不会将请求进行转发。</p>
<p>在网关中，验证过滤器会对 /oauth/token 这个认证 API 进行放行，不进行验证。<br><strong>用户信息的全局传递扩展：</strong><br>不需要加参数，直接通过请求头进行传递，在服务内部通过ThreadLocal进行上下文传递。主要流程：从网关传递到后端服务，后端服务接受数据后存储到ThreadLocal中，服务会调用其它服务，如果用Feign调用可以利用Feign的拦截器传递数据，如果用RestTemplate的拦截器传递数据也一样。</p>
<h4 id="3-3-Token的使用"><a href="#3-3-Token的使用" class="headerlink" title="3.3 Token的使用"></a>3.3 Token的使用</h4><p><strong>Token注销</strong><br><img data-src="../../../../assets/img/CgoB5l3WUIGADfX2AAEhrMGcQDk308.png" alt><br>Token的有效期存储在Token本身中，只有解析出Token的信息，才能获取到Token的有效时间，不能修改。Token的有效期越短，安全性越高。还可以在用户退出登录时，进行Token的注销操作，如将注销的Token放入Redis中进行一层过滤，即在网关中验证Token有效性时先从Redis中判断Token是否存在，如果存在，直接拦截。Token放入Redis的过期时间一般会设置为Token剩余的有效时间。</p>
<p><strong>使用建议</strong></p>
<ul>
<li>设置较短(合理)的过期时间</li>
<li>注销的Token及时清除(放入Redis中做一层过滤)</li>
<li>监控Token的使用频率</li>
<li>核心功能敏感操作可以使用动态验证(验证码)</li>
<li>网络环境、浏览器信息等识别</li>
<li>加密密钥支持动态修改</li>
<li>加密密钥支持动态修改</li>
</ul>
<h4 id="3-4-内部服务之间的认证"><a href="#3-4-内部服务之间的认证" class="headerlink" title="3.4 内部服务之间的认证"></a>3.4 内部服务之间的认证</h4><p><img data-src="../../../../assets/img/CgotOV3WUJuAU4JXAAEXJfEgv9o814.png" alt></p>
<ol>
<li><p>IP白名单<br>如用户服务只能某些IP或IP段访问，IP白名单可以采用配置中心来存储，具备实时刷新的能力。</p>
</li>
<li><p>内部同样使用Token进行验证<br>服务在启动时就可以在统一的认证服务中申请Token，申请需要的认证信息可以放在配置中心。这样服务启动时就有了能够访问其他服务的Token，在调用时带上Token，被调用的服务中进行Token的校验。<br>对于Token的失效更新：</p>
<ol>
<li>在请求时如果返回的Token已经失效，那么可以重新获取Token后再发起调用，这种在并发量大时需要加锁，不然会发生同时申请多个Token的情况。</li>
<li>定时更新，如Token有效期1个小时，那么定时任务可以50分钟更新一次。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Sping Cloud相关组件了解</title>
    <url>/SpringCloud_01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Eureka"><a href="#1-Eureka" class="headerlink" title="1.Eureka"></a>1.Eureka</h3><p>如果需要实现完整的服务注册与服务发现的功能，我们需要有注册中心来统一存储和管理服务信息，应用程序需要将自身的信息注册到注册中心，也就是服务提供者和服务消费者的信息。整个过程中包含的操作有<strong>注册、拉取、心跳、剔除</strong>等动作。</p>
<a id="more"></a>

<p><img data-src="../../../../assets/img/CgoB5l2DSRmATTQnAACaxgMS0KY966.png" alt></p>
<ul>
<li>注册中心：用来集中存储管理服务信息。</li>
<li>服务提供者：通过API供其他方调用服务。</li>
<li>服务消费者：需要调用其他方的API获取服务。</li>
</ul>
<p>项目启动后Eureka Client会向Eureka Server发送请求，进行注册，并将自身信息发送给Eureka Server。注册成功后，每隔一定的时间，Eureka Client会向Eureka Server<strong>发送心跳来续约服务</strong>，汇报健康状态。如果客户端长时间没有续约，那么Eureka Server大约在90秒内从服务器注册表中清除客户端的信息。应用程序停止时Eureka Client会通知Eureka Server移除相关信息，<strong>信息移除</strong>成功后，对应的客户端会更新服务的信息，这样就不会调用已经下线的服务，但操作<strong>具有延迟</strong>，有可能会调到已经失效的服务，所以在客户端会开启<strong>失败重试</strong>功能来避免这个问题。Eureka Serve集群保证高可用，Eureka Server没有集成其它第三方存储，而是存储在内存中。所以Eureka Server之间会将注册信息复制到集群中的Eureka Serve的所有节点。这样数据才是共享状态，任何的Eureka Client都可以在任何一个Eureka Server节点查找到注册信息。</p>
<h4 id="1-1-Eureka注册表"><a href="#1-1-Eureka注册表" class="headerlink" title="1.1 Eureka注册表"></a>1.1 Eureka注册表</h4><p>Eureka的注册信息是存储在<strong>ConcurrentHashMap</strong>中的，Map的key是服务名称，value是一个Map。value的Map的key是服务实例的ID，value是Lease类，Lease中存储了实例的注册时间、上线时间等信息，还有具体的实例信息，如IP、端口、健康检查的地址等信息。</p>
<p>Eureka将注册的服务信息存储在内存中的原因：性能高；部署简单，不需要依赖于第三方存储。<br>劣势：扩容难度高，每个Eureka Server都全量的存储一份注册表，假如存储空间不够了，需要扩容，那么所有的Eureka Server节点都必须扩容，必须采用的内存配置。</p>
<p>Eureka核心操作主要有注册、续约、下线、移除，接口为com.netflix.eureka.lease.LeaseManager，这些操作都是针对注册表的操作，也就是Map的操作。</p>
<h4 id="1-2-自我保护机制"><a href="#1-2-自我保护机制" class="headerlink" title="1.2 自我保护机制"></a>1.2 自我保护机制</h4><p>自我保护机制是为了<strong>避免因网络分区故障而导致服务不可用</strong>的问题。<br><img data-src="../../../../assets/img/CgoB5l2DSRqAP1FMAACHP1JLl1g494.png" alt><br><img data-src="../../../../assets/img/CgotOV2DSRqACgusAAB-W41DoEM379.png" alt><br>自我保护机制带来的问题：若服务提供者B真的下线了，由于Eureka Serve自我保护机制打开，不会移除任务信息，当服务消费者对服务提供者B进行调用时，就会出错。出现<strong>某些有问题的实例没能及时移除掉</strong>的情况，服务消费者可以通过<strong>Ribbon来进行重试</strong>，保证调用能够成功。</p>
<p>自我保护开启的条件：AbstractInstanceRegistry中有两个字段，numberOfRenewsPerMinThreshold(期望最小每分钟能够续租的次数)、expectedNumberOfClientsSendingRenews(期望的服务实例数)。假如有10个实例，每个实例每分钟续约2次，那么10x2x0.85=17，即每分钟至少有17次续约才是正常的。</p>
<h4 id="1-3-健康检查"><a href="#1-3-健康检查" class="headerlink" title="1.3 健康检查"></a>1.3 健康检查</h4><p><img data-src="../../../../assets/img/CgoB5l2DSRqALpz-AADDQMq9ysI107.png" alt><br>Eureka Client会定时发送心跳给Eureka Server来证明自己是否处于健康的状态。但某些场景下，服务处于存活状态，却已经不能对外提供服务，如数据库出问题了，但心跳正常，客户端在请求时还会请求到这个出问题的实例。可以在项目中集成Actuator，统一管理应用的健康状态，将这个状态反馈给Eureka Server。</p>
<h3 id="2-Ribbon"><a href="#2-Ribbon" class="headerlink" title="2.Ribbon"></a>2.Ribbon</h3><h4 id="2-1-负载均衡"><a href="#2-1-负载均衡" class="headerlink" title="2.1 负载均衡"></a>2.1 负载均衡</h4><p>负载均衡是一种基础的网络服务，它的核心原理是按照指定的负载均衡算法，将请求分配到后端服务集群上，从而为系统提供并行处理和高可用的能力。</p>
<ul>
<li><p><strong>集中式负载均衡：</strong>在消费者和提供者中间使用独立的代理方式进行负载，有硬件的负载均衡器，如F5，也有软件，如Nginx。客户端不需要关心对应服务实例的信息，只需要与负载均衡器进行交互，服务实例扩容或者缩容，客户端不需要修改任何代码。<br><img data-src="../../../../assets/img/CgoB5l2Nux-AfPsoAADd9v--bG8534.png" alt></p>
</li>
<li><p><strong>客户端负载均衡：</strong>需要自己维护服务实例信息，然后通过某些负载均衡算法，从实例中选取一个实例，直接进行访问。<br>区别：对服务实例信息的维护。集中式负载均衡的信息是集中进行维护的，如Nginx，都会在配置文件中进行指定。客户端负载均衡的信息是在客户端本地进行维护的，可以手动配置，最常见的是从注册中心拉取。</p>
</li>
</ul>
<h4 id="2-2-Ribbon"><a href="#2-2-Ribbon" class="headerlink" title="2.2 Ribbon"></a>2.2 Ribbon</h4><p><img data-src="../../../../assets/img/CgotOV2Nux-AO2PcAAEcl4M1Zi4629.png" alt><br><img data-src="../../../../assets/img/CgoB5l2NuyCALoefAAAdV1DlSHY088.png" alt><br>使用方式：</p>
<ol>
<li>原生API</li>
<li>Ribbon+RestTemplate</li>
<li>Ribbon+Feign<br>通过给加了@LoadBalanced的RestTemplate添加拦截器，拦截器中通过Ribbon选取服务实例，然后将请求地址中的服务名称替换成Ribbon选取服务实例的IP和端口。</li>
</ol>
<h4 id="2-3-负载均衡策略"><a href="#2-3-负载均衡策略" class="headerlink" title="2.3 负载均衡策略"></a>2.3 负载均衡策略</h4><ol>
<li>内置负载均衡策略</li>
</ol>
<ul>
<li>RoundRobinRule：轮询算法</li>
<li>RandomRule：随机算法</li>
<li>BestAvailableRule：选择一个最小的并发请求server，如果有A、B两个实例，当A有4个请求正在处理中，B有2个，下次请求会选择B，适用于服务所在机器配置相同的情况。</li>
<li>WeightedResponseTimeRule：根据请求的响应时间计算权重，如果响应时间越长，那么对应的权重越低，权重越低的服务器，被选择的可能性就越低。</li>
</ul>
<ol start="2">
<li>自定义负载均衡算法<ol>
<li>实现IRule接口或继承AbstractLoadBanlancerRule</li>
<li>实现choose方法</li>
<li>指定Ribbon的算法类<br>使用场景：</li>
</ol>
<ul>
<li>定制与业务更匹配的策略。</li>
<li>灰度发布</li>
<li>多版本隔离</li>
<li>故障隔离</li>
</ul>
</li>
</ol>
<h4 id="2-4-饥饿加载模式"><a href="#2-4-饥饿加载模式" class="headerlink" title="2.4 饥饿加载模式"></a>2.4 饥饿加载模式</h4><p>Ribbon在进行客户端负载均衡时并不是启动时就加载上下文，而是<strong>第一次请求时才去创建</strong>的，因此第一次调用会比较慢，有可能会引起调用超时。可以指定Ribbon客户端的名称，在启动时加载这些子应用程序上下文。</p>
<p>初始化后进行了缓存操作，getContext()方法中，如果在contexts中不存在才会创建，创建时会用synchronized加锁，并进行二次判断，防止并发下出现创建多次的问题，最后进行增加操作。如果有的话就直接从contexts获取返回。contexts就是一个ConcurrentHashMap。</p>
<h3 id="3-Hystrix"><a href="#3-Hystrix" class="headerlink" title="3.Hystrix"></a>3.Hystrix</h3><h4 id="3-1-服务雪崩"><a href="#3-1-服务雪崩" class="headerlink" title="3.1 服务雪崩"></a>3.1 服务雪崩</h4><p>微服务架构下，会存在服务之间相互依赖调用的情况，当<strong>某个服务不可用</strong>时，很容易因为<strong>服务之间的依赖关系</strong>使故障扩大，甚至<strong>造成整个系统不可用</strong>，这种现象称为服务雪崩效应。</p>
<p>产生原因：</p>
<ul>
<li><p>服务提供者<br>代码的Bug问题，由于某些代码导致CPU飙升，将资源耗尽等；服务器出现问题，磁盘出问题，导致数据读写特别慢，拉高了响应时间；慢SQL语句问题；请求量太大，超出系统本身的承受能力。</p>
</li>
<li><p>服务消费者<br>同步调用等待结果导致资源耗尽；自己既是服务消费者也是服务提供者。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>服务提供者<br>代码Bug问题：测试、Code Review等方式；慢SQL问题：数据库性能优化；服务器硬件故障问题：加大运维粒度，通过监控等手段提前预防；请求量超出承受能力：扩容或限流</p>
</li>
<li><p>服务消费者<br>资源隔离、快速失败。</p>
</li>
</ul>
<h4 id="3-2-容错实现"><a href="#3-2-容错实现" class="headerlink" title="3.2 容错实现"></a>3.2 容错实现</h4><p>设计原则：<br><img data-src="../../../../assets/img/CgotOV2gPgGAP-qzAABk99lb2oU443.png" alt><br><img data-src="../../../../assets/img/CgoB5l2gPgGAF353AAFVH3psdO4196.png" alt></p>
<ul>
<li>封装请求：将用户的操作进行统一封装，目的在于进行统一控制。</li>
<li>资源隔离：将对应的资源按照指定的类型进行隔离，如线程池和信号量。</li>
<li>失败回退：备用方案，当请求失败后，Hystrix会让用户自定义备用方案。</li>
<li>断路器：决定了请求是否需要真正的执行，如果断路器打开，那么所有的请求都将失败，执行回退逻辑。如果断路器关闭，那么请求将正常执行。</li>
<li>指标监控：对请求的生命周期进行监控。</li>
</ul>
<p>工作原理：<br><img data-src="../../../../assets/img/CgotOV2gPgGATT0XAAHyJjjmin8233.png" alt></p>
<ol>
<li>构建一个HystrixCommand或者HystrixObservableCommand对象，将请求包装到Command对象中。</li>
<li>执行构建好的命令。</li>
<li>判断当前请求是否有缓存，如果有就直接返回缓存的内容。</li>
<li>判断断路器是否打开，如果打开，跳到第8步，获取fallback方法，执行fallback逻辑。如果没有打开，执行第5步。</li>
<li>如果是线程池隔离模式，判断线程池队列的容量；如果是信号量隔离模式，会判断信号量的值是否已经被使用完。如果线程池和信号量都已经满了，同样请求不被执行，直接跳到第8步。</li>
<li>执行HystrixObservableCommand.construct()或HystrixCommand.run()方法，正在执行的请求逻辑就封装在construct()或run()方法中。</li>
<li>请求过程中，若出现异常或者超时，会直接到第8步，执行成功就返回结果。执行结果会将数据上报给断路器，断路器会根据上报的数据来判断断路器是否打开</li>
<li>fallback</li>
</ol>
<h4 id="3-3-Hystrix使用"><a href="#3-3-Hystrix使用" class="headerlink" title="3.3 Hystrix使用"></a>3.3 Hystrix使用</h4><ol>
<li>HystrixCommand注解方式</li>
<li>在Feign中使用</li>
<li>在Zuul中使用</li>
</ol>
<p>Hystrix配置：<br><img data-src="../../../../assets/img/CgotOV2gPgKAYjAMAABpYDXLwZU519.png" alt></p>
<h4 id="3-4-Hystrix隔离机制"><a href="#3-4-Hystrix隔离机制" class="headerlink" title="3.4 Hystrix隔离机制"></a>3.4 Hystrix隔离机制</h4><ul>
<li><p>线程池隔离：当用户请求A服务后，A服务需要调用其它服务，这个时候可以为不同的服务创建独立的线程池，假如A需要调用B和C，那么可以创建两个独立的线程池，将调用B服务的线程池丢入到一个线程池，将调用C服务的线程丢入另一个线程池，这样起隔离效果，就算其中某个线程池请求满了，无法处理请求了，对另一个线程池页没有影响。使用线程隔离。需要调整好线程池参数，否则和信号量一样，并发量大的时候性能上不去。设置最大线程数，默认为10，队列大小决定了能够堆积多少请求，但请求不能一直堆积，所有还需要设置一个阈值来进行拒绝。</p>
</li>
<li><p>信号量隔离：信号量就算一个计数器，如初始化是100，那么每次请求过来时信号量就会减1，当信号量计数为0时，请求就会被拒绝，等之前的请求处理完成后，信号量就会加1。起到了限流的作用，信号量隔离是在请求主线程中执行的。</p>
<p>线程池隔离的特点是<strong>Command运行在独立的线程池中</strong>，可以支持超时，是单独的线程，支持异步。信号量隔离运行在调用的主线程中，不支持超时，只能同步调用。</p>
</li>
</ul>
<h4 id="3-5-使用技巧"><a href="#3-5-使用技巧" class="headerlink" title="3.5 使用技巧"></a>3.5 使用技巧</h4><ul>
<li><p>配置可以对接配置中心进行动态调整</p>
</li>
<li><p>回退逻辑中可以手动埋点或者通过输出日志进行告警</p>
</li>
<li><p>使用线程池隔离模式再用ThreadLocal会有坑<br>被隔离的方法会包装成一个Command丢入到独立的线程中执行，这个时候就是从A线程切换到了B线程，ThreadLocal的数据就会丢失。</p>
</li>
<li><p>网关中尽量用信号隔离</p>
</li>
<li><p>插件机制可以实现很多扩展</p>
</li>
<li><p>Hystrix各种超时配置方式</p>
</li>
<li><p>commandKey、groupKey、threadPoolKey的使用<br>在使用HystrixCommand注解时，会配置commandKey、groupKey、threadPoolKey。commandKey表示封装的command的名称，可以给指定的commandKey进行参数的设置。groupKey是将一组command进行分组，如果没有设置threadPoolKey的话，那么线程池的名称会用groupKey。threadPollKey是线程池的名称，多个command的threadPoolKey相同，那么会使用同一个线程池。</p>
</li>
</ul>
<h3 id="4-Feign"><a href="#4-Feign" class="headerlink" title="4.Feign"></a>4.Feign</h3><p>Feign是一个声明式的REST客户端，Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好Http请求的参数、格式、地址等信息。Feign会完全代理HTTP请求，Spring Cloud对Feign进行了封装，使其支持SpringMVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡，与Hystrix组合使用，支持熔断回退。</p>
<h4 id="4-1-重要组件"><a href="#4-1-重要组件" class="headerlink" title="4.1 重要组件"></a>4.1 重要组件</h4><p><img data-src="../../../../assets/img/CgotOV2oGbmAMIEfAAFD417806k525.png" alt></p>
<ul>
<li><p>Contract 契约组件<br>Contract允许用户自定义契约去解析注解信息，如在Spring Cloud中使用Feign，可以使用SpringMVC的注解来定义Feign的客户端。</p>
</li>
<li><p>Encoder 编码组件<br>通过该组件可以将请求信息采用指定的编码方式来进行编码后传输。</p>
</li>
<li><p>Decoder 编码组件</p>
<p>Decoder将相应数据解码成对象。</p>
</li>
<li><p>ErrorDecoder 异常解码器<br>当被调用方发生异常后，可以在ErrorDecoder中将响应的数据转换成具体的异常返回给调用方，适合内部服务之间调用，但不想通过指定的字段来判断是否成功的场景，直接用自定义异常代替。</p>
</li>
<li><p>Logger 日志记录<br>Logger组件负责Feign中记录日志的，可以指定Logger的级别及自定义日志的输出。</p>
</li>
<li><p>Client 请求执行组件<br>Client是负责HTTP请求执行的组件，Feign将请求信息封装好后会交由Client来执行，Feign中默认的Client是通过JDK的HttpURLConnection发起请求的，每次发起请求的适合，都会建立新的HttpURLConnection链接，性能很差。可以扩展该接口，使用Apache HttpClient等基于连接池的高性能HTTP客户端。</p>
</li>
<li><p>Retryer 重试组件<br>Retryer是负责重试的组件，Feign内置了重试器，当HTTP请求出现IO异常时，Feign会限定最大重试次数来进行重试操作。</p>
</li>
<li><p>InvocationHandlerFactory 代理<br>IncocationHandlerFactory采用JDK的动态代理方式生成代理对象，定义的Feign接口，当调用这个接口中定义的方法时，实际上是去调用远程的HTTP API，这里用了动态代理的方式，当调用某个方法时，会进入代理中正在的去调用远程HTTP API。</p>
</li>
<li><p>RequestInterceptor 请求拦截器<br>可以为Feign添加多个拦截器，在请求执行前设置一些扩展的参数信息。</p>
</li>
<li><p>QueryMapEncoder 参数查询<br>QueryMapEncoder是针对实体类参数查询的编码器，可以基于QueryMapEncoder将实体类生成对应的查询参数。</p>
</li>
</ul>
<h4 id="4-2-Feign执行过程"><a href="#4-2-Feign执行过程" class="headerlink" title="4.2 Feign执行过程"></a>4.2 Feign执行过程</h4><p><img data-src="../../../../assets/img/CgoB5l2oGbmACVdMAACewrpciZo953.png" alt><br>定义对应的接口类，在接口类上使用Feign自带的注解来标识HTTP的参数信息，当调用接口对应的方法时，Feign内部会基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，负责动态代理的组件是InvocationHandlerFactory。根据Contract规则，解析接口类的注解信息，翻译成Feign内部能识别的信息。Spring Cloud OpenFeign中就扩展了SpringMVCContract。MethodHandler在执行的时候会生成Request对象，在构建Request对象的时候会为其设置拦截器，交由Client执行前记录一些日志，Client执行完成后也记录一些日志，然后使Decoder进行相应结果的解码操作，并返回结果。</p>
<h4 id="4-3-使用技巧"><a href="#4-3-使用技巧" class="headerlink" title="4.3 使用技巧"></a>4.3 使用技巧</h4><ul>
<li><p>继承特性<br>将API的定义提取出来封装成一个单独的接口，给API的实现方和调用方共用。</p>
</li>
<li><p>拦截器<br>添加自己的拦截器来实现某些场景下的需求，实现RequestInterceptor接口，在apply方法中编写自己的逻辑。</p>
</li>
<li><p>GET请求多参数传递<br>一般超过3个以上的参数会封装在一个实体类中，在Spring Cloud Open Feign中要支持对象接收多个参数，需要增加@SpringQueryMap注解。</p>
</li>
<li><p>日志配置<br>Feign日志级别：</p>
<ol>
<li>NONE：不输出日志</li>
<li>BASIC：只输出请求方法的URL和响应的状态码及执行的时间</li>
<li>HEADERS：将BASIC和请求头信息输出</li>
<li>FULL：会输出全部完整的请求信息</li>
</ol>
</li>
<li><p>异常解码器</p>
</li>
</ul>
<h3 id="5-Zuul"><a href="#5-Zuul" class="headerlink" title="5.Zuul"></a>5.Zuul</h3><p>API网关是对外提供服务的一个入口，并且隐藏了内部架构的实现。可以为我们管理大量的API接口，负责对接用户、协议适配、安全认证、路由转发、流量限制、日志监控、防止爬虫、灰度发布等功能。</p>
<ul>
<li><p>动态路由<br><img data-src="../../../../assets/img/CgotOV2yzFKAbTymAAE9eECzbLs575.png" alt><br>将客户端的请求路由到后端不同的服务上，如果没有网关去做统一的路由，那么客户端就要关注后端N个服务。</p>
</li>
<li><p>请求监控<br><img data-src="../../../../assets/img/CgoB5l2yzFKAMhJuAADDrRk--Cs646.png" alt><br>对整个系统的请求进行监控，详细的记录请求响应日志，可以实时的统计当前系统的访问量及监控状态。</p>
</li>
<li><p>认证鉴权<br>统一对访问请求做认证，拒绝非法请求，保护后端的服务。</p>
</li>
<li><p>压力测试<br><img data-src="../../../../assets/img/CgoB5l2yzFKAe9wtAAEaJgA80DA706.png" alt><br>动态的将测试请求转发到后端服务的集群中，还可以识别测试流量和真实流量，用来做一些特殊的处理。</p>
</li>
<li><p>灰度发布<br><img data-src="../../../../assets/img/CgotOV2yzFKAVLC_AAE1Ij_9Yow275.png" alt><br>当需要发布新版本时，通过测试请求对1.1版本的服务进行测试，若没发现问题，可以将正常的请求转发过来，若有问题，不影响用户使用的1.0版本。</p>
</li>
</ul>
<h4 id="5-1-过滤器"><a href="#5-1-过滤器" class="headerlink" title="5.1 过滤器"></a>5.1 过滤器</h4><p>过滤器可以对请求或响应结果进行处理，Zuul支持动态加载、编译、运行这些过滤器。</p>
<ul>
<li>pre过滤器：可以在请求被路由器之前调用。适用于身份认证的场景，认证通过后再继续执行下个流程。</li>
<li>route过滤器：在路由请求时被调用。适用于灰度发布的场景，在将要路由的时候可以做一些自定义的逻辑。</li>
<li>post过滤器：在route和error过滤器之后被调用。将请求路由到达具体的服务之后执行，适用于添加响应头，记录响应日志等应用场景。</li>
<li>error过滤器：处理请求发生错误时被调用。在执行过程中发送错误时会进入error过滤器，可以用来统一记录错误信息。</li>
</ul>
<p><strong>自定义过滤器</strong>：<br>继承ZuulFilter，然后重写ZuulFilter的四个方法<br><img data-src="../../../../assets/img/CgotOV2yzFKARVycAADyi7HDY0s663.png" alt><br>shouldFilter方法决定了是否执行该过滤器，true为执行，false不执行，可以利用配置中心实现动态的开启或关闭过滤器。filterType方法是要返回过滤器的类型，可选择为pre、route、post、error四种类型。过滤器可以有多个，先后顺序可以通过filterOrder来指定过滤器的执行顺序，数字越小，优先级越高。业务逻辑写在run方法中。</p>
<h4 id="5-2-请求生命周期"><a href="#5-2-请求生命周期" class="headerlink" title="5.2 请求生命周期"></a>5.2 请求生命周期</h4><p><img data-src="../../../../assets/img/CgotOV2yzFKALGjnAAEfSfAim3o535.png" alt><br>请求先进入pre过滤器，在pre过滤器执行完后，进入routing过滤器，开始路由到具体的服务中，路由完成后，接着到了post过滤器，然后将请求结果返回给客户端。如果过程中出现异常，则会进入error过滤器。源码对应ZuulServlet。</p>
<h4 id="5-3-Zuul容错与回退"><a href="#5-3-Zuul容错与回退" class="headerlink" title="5.3 Zuul容错与回退"></a>5.3 Zuul容错与回退</h4><h4 id="5-4-使用技巧"><a href="#5-4-使用技巧" class="headerlink" title="5.4 使用技巧"></a>5.4 使用技巧</h4><ul>
<li><p>内置端点<br>当@EnableZuulProxy与Spring Boot Actuator配合使用时，Zuul会暴露一个路由管理端点/routes。借助这个端点，可以直观的查看及管理Zuul的路由。还有一个/filters端点可以查看Zuul中所有过滤器的信息。</p>
</li>
<li><p>文件上传<br>通过Zuul上传文件，超过1M的文件会上传失败，配置max-file-size和max-request-size，Zuul中需要配置，最终接受文件的服务也要配置。或在网关请求地址前面上加上/zuul，可以绕过Spring DispatcherServlet上传大文件。Zuul服务不用再配置，但接收文件的服务还是要配置文件上传大小。在上传大文件时，时间较长，可以设置Ribbon的ConnectTimeOut和ReadTimeOut。如果Zuul的Hystrix隔离模式为线程的话需要设置Hystrix的超时时间。</p>
</li>
<li><p>请求响应输出</p>
</li>
<li><p>Zuul Debug</p>
</li>
<li><p>跨域配置</p>
</li>
<li><p>关闭Zuul全局路由转发<br>配置zuul.ignored-service=*关闭路由转发，配置zuui.ignoredPatterns忽略不想暴露的API。</p>
</li>
<li><p>动态过滤器<br>定期扫描存放Groovy Filter文件的目录，如果发现有新Groovy Filter文件或者Groovy Filter源码有改动，那么就会对Groovy文件进行编译加载。首先在项目中增加Groovy的依赖，然后在项目启动后设置Groovy的动态加载任务，定时动态加载指定目录的Groovy文件。<br><img data-src="../../../../assets/img/CgotOV2yzFOAAazFAAGQ15EC0VY427.png" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>top K问题的优化解法</title>
    <url>/1060/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="top-K问题的优化解法"><a href="#top-K问题的优化解法" class="headerlink" title="top K问题的优化解法"></a>top K问题的优化解法</h3><p>​    在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。</p>
<a id="more"></a>

<p><strong>100亿数据找出最大的1000个数字</strong></p>
<p><strong>对于海量数据处理，思路基本上是：必须分块处理，然后再合并起来。</strong></p>
<h4 id="1-局部淘汰法"><a href="#1-局部淘汰法" class="headerlink" title="1.局部淘汰法"></a>1.局部淘汰法</h4><p>​    用一个容器保存前1000个数，然后将剩余的所有数字一一与容器内的最小数字相比，如果所有后续的元素都比容器内的1000个数还小，那么容器内这个1000个数就是最大1000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O(n+m^2)，其中m为容器的大小。</p>
<p>​    这个容器可以用（小顶堆）<strong>最小堆</strong>来实现。我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了（1亿的logN值是26-27的一个浮点数）。基本的思路就是<strong>先从文件中取出1000个元素构建一个小顶堆数组k，然后依次对剩下的100亿-1000个数字进行遍历m，如果m大于小顶堆的根元素，即k[0]，那么用m取代k[0]，对新的数组进行重新构建组成一个新的小顶堆。</strong>这个算法的时间复杂度是O((100亿-1000)log(1000))，即O((N-M)logM)，空间复杂度是M</p>
<p>这个算法优点是性能尚可，<strong>空间复杂度低</strong>，<strong>IO读取比较频繁</strong>，对系统压力大。</p>
<h4 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2.分治法"></a>2.分治法</h4><p>(1) 将100亿个数据分为1000个大分区，每个区1000万个数据</p>
<p>(2) 每个大分区再细分成100个小分区。总共就有1000*100=10万个分区</p>
<p>(3) 计算每个小分区上最大的1000个数</p>
<p>(4) 合并每个大分区细分出来的小分区。每个大分区有100个小分区，我们已经找出了每个小分区的前1000个数。将这100个分区的1000*100个数合并，找出每个大分区的前1000个数</p>
<p>(5) 合并大分区。我们有1000个大分区，上一步已找出每个大分区的前1000个数。我们将这1000*1000个数合并，找出前1000.这1000个数就是所有数据中最大的1000个数</p>
<h4 id="3-Hash法"><a href="#3-Hash法" class="headerlink" title="3.Hash法"></a>3.Hash法</h4><p>​    如果这1亿个数据里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的1000个数。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发常用命令</title>
    <url>/Vue_shell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-创建vue脚手架项目"><a href="#1-创建vue脚手架项目" class="headerlink" title="1.创建vue脚手架项目"></a>1.创建vue脚手架项目</h4>   <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">vue <span class="keyword">init</span> webpack 项目名</span><br></pre></td></tr></table></figure>

<h4 id="2-axios"><a href="#2-axios" class="headerlink" title="2.axios"></a>2.axios</h4><ol>
<li><p>安装axios</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置main.js中引入axios</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http=axios;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li>使用axios<br>在需要发送异步请求的位置:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.get(</span><br><span class="line">        <span class="string">"url"</span></span><br><span class="line">      )</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-ElementUI"><a href="#3-ElementUI" class="headerlink" title="3.ElementUI"></a>3.ElementUI</h4><ol>
<li><p>安装ElementUI</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置main.js中引入ElementUI</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vue脚手架中使用elementui</span></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="4-项目打包"><a href="#4-项目打包" class="headerlink" title="4.项目打包"></a>4.项目打包</h4><ol>
<li><p>打包<br>在项目根目录中执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p><code>注意:vue脚手架打包的项目必须在服务器上运行不能直接双击运行</code></p>
</li>
<li><p>打包之后当前项目中变化<br>在打包之后项目中出现dist目录,dist目录就是vue脚手架项目生产目录或者说是直接部署目录</p>
</li>
<li><p>与后端合并部署<br>复制dist目录到Java工程resource下的static文件夹,index.html中修改路径</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">/dist/static/css/app...../</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">text/javascript</span> <span class="attr">src</span>=<span class="string">/dist/static/js/ma....</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问项目<br>浏览器访问:  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2Rpc3QvaW5kZXguaHRtbA==">http://localhost:8080/dist/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>一个Java对象的大小怎么计算？</title>
    <url>/javaobjectsize/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个Java对象的大小怎么计算？"><a href="#一个Java对象的大小怎么计算？" class="headerlink" title="一个Java对象的大小怎么计算？"></a>一个Java对象的大小怎么计算？</h2><p><strong>对象头+实例数据+对其填充</strong></p>
<p><strong>对象头</strong></p>
<ol>
<li>MarkWord：用于存储对象运行时的数据，如hashCode、锁状态标志、GC分代年龄等。<strong>64位操作系统占8字节，32位操作系统占4字节。</strong></li>
<li>对象元数据指针(kclass)：对象指向类的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。<strong>开启压缩指针占4字节，未开启占8字节。</strong></li>
<li>数组长度：<strong>只有数组对象才有，占4字节。</strong></li>
</ol>
<a id="more"></a>

<p><strong>实例数据</strong></p>
<p>实例数据可能包括两种：</p>
<ol>
<li><p>8种基本数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>Reference</td>
<td>4</td>
</tr>
</tbody></table>
</li>
<li><p>对象</p>
</li>
</ol>
<p><strong>对其填充(Padding)</strong></p>
<p>Java对象内存起始地址必须为8的整数倍，即Java对象大小必须为8的整数倍。当对象头+实例数据大小不为8的整数倍时，将会使用对其填充。</p>
<p>如64位，开启压缩指针的虚拟机上new Object()实际大小：</p>
<p>Mark Word(8B) + kclass(4B) + Padding(4B) = 16B</p>
<p><strong>例子</strong></p>
<ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mark Word(8B) + kclass(4B) + i(4B) = 16B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mark Word(8B) + kclass(4B) + i(4B) + j(4B) + s(4B) + b(1B) + c(2B) + Padding(5B) = 32B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HotSpot创建的对象的字段会默认按从长到短，引用排最后排序：long/double --&gt; int/float --&gt; short/char --&gt; byte/boolean --&gt;Reference</span></span><br><span class="line"><span class="comment">//Mark Word(8B) + kclass(4B) + i1(4B) + i2(4B) + b1(1B) + b2(1B) + b3(1B) + Padding(1B) + s(4B) + obj(4B) = 32B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i1; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b1; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b2; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i2;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b3;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP</title>
    <url>/spring_aop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-AOP概述"><a href="#1-AOP概述" class="headerlink" title="1.AOP概述"></a>1.AOP概述</h3><h4 id="1-1-什么是AOP？"><a href="#1-1-什么是AOP？" class="headerlink" title="1.1 什么是AOP？"></a>1.1 什么是AOP？</h4><p>AOP(Aspect Oriented Programming 面向切面编程)，通过<strong>预编译</strong>方式和<strong>运行期动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>，提高程序的<strong>可重用性</strong>，同时提高了<strong>开发的效率</strong>。<br>常用于日志记录，性能统计，安全控制，事务处理，异常处理等等。</p>
<a id="more"></a>
<h4 id="1-2-AOP术语"><a href="#1-2-AOP术语" class="headerlink" title="1.2 AOP术语"></a>1.2 AOP术语</h4><p><strong>切面</strong>(Aspect)：由横切关注点构成的特殊对象。<br><strong>连接点</strong>(Join Point)：连接点是指在<strong>程序执行过程中某个特定的点</strong>，比如某方法调用的时候或者处理异常的时候；<br><strong>通知</strong>(Advice)：指在切面的某个特定的连接点上<strong>执行的动作</strong>。<br>Spring切面可以应用5种通知：</p>
<ul>
<li><strong>前置通知</strong>(Before):在目标方法或者说连接点被<strong>调用前</strong>执行的通知；</li>
<li><strong>后置通知</strong>(After)：指在某个连接点<strong>完成后</strong>执行的通知；</li>
<li><strong>返回通知</strong>(After-returning)：指在某个连接点<strong>成功执行之后</strong>执行的通知；</li>
<li><strong>异常通知</strong>(After-throwing)：指在方法<strong>抛出异常后</strong>执行的通知；</li>
<li><strong>环绕通知</strong>(Around)：指包围一个连接点通知，在被通知的方法<strong>调用之前和之后执行自定义的方法</strong>。</li>
</ul>
<p><strong>切点</strong>(Pointcut)：指匹配连接点的断言。通知与一个切入点表达式关联，并在满足这个切入的连接点上运行，例如：当执行某个特定的名称的方法。<br>引入(Introduction)：引入也被称为内部类型声明，声明额外的方法或者某个类型的字段。<br>目标对象(Target Object)：目标对象是被一个或者多个切面<strong>所通知的对象</strong>。<br>AOP代理(AOP Proxy)：向目标对象应用通知之后创建的对象。<br>织入(Wearving)：增强添加到目标类具体连接点上的过程。AOP有三种织入的方式：编译期织入、类装载期织入、动态代理织入(spring采用动态代理织入)。</p>
<h4 id="1-3-通知执行顺序"><a href="#1-3-通知执行顺序" class="headerlink" title="1.3 通知执行顺序"></a>1.3 通知执行顺序</h4><ul>
<li>正常情况<br>@Around -&gt;@Before-&gt;主方法体-&gt;@Around中pjp.proceed()-&gt;@After-&gt;@AfterReturning</li>
<li>存在异常<ol>
<li>异常在Around中pjp.proceed()之前<br>@Around -&gt; @After -&gt; @AfterThrowing</li>
<li>异常在Around中pjp.proceed()之后<br>@Around -&gt;@Before-&gt;主方法体-&gt;@Around中pjp.proceed()-&gt;@After-&gt;@AfterThrowing<h4 id="1-4-实现原理"><a href="#1-4-实现原理" class="headerlink" title="1.4 实现原理"></a>1.4 实现原理</h4></li>
</ol>
</li>
</ul>
<ol>
<li>JDK动态代理(JDK提供，只能代理<strong>接口</strong>)<br> 使用动态代理可以为一个或多个接口在运行期动态生成实现对象，生成的对象中实现接口的方法时可以添加增强代码，从而实现AOP。缺点是<strong>只能针对接口进行代理</strong>，另外由于动态代理是<strong>通过反射实现的，有时可能要考虑反射调用的开销</strong>。</li>
<li>CGLib动态代理: (适用CGLib工具)<br>采用<strong>动态的字节码生成技术</strong>，运行时动态生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP 。<h4 id="1-5-Pointcut切入点的语法"><a href="#1-5-Pointcut切入点的语法" class="headerlink" title="1.5 Pointcut切入点的语法"></a>1.5 Pointcut切入点的语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、使用within表达式匹配</span></span><br><span class="line"><span class="comment"> * 下面示例表示匹配com.example.controller包下所有的类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.example.controller..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutWithin</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、this匹配目标指定的方法，此处就是HelloController的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.example.controller.HelloController)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、target匹配实现UserInfoService接口的目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.leo.service.UserInfoService)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutTarge</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、bean匹配所有以Service结尾的bean里面的方法，</span></span><br><span class="line"><span class="comment"> * 注意：使用自动注入的时候默认实现类首字母小写为bean的id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*ServiceImpl)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、args匹配第一个入参是String类型的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"args(String, ..)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutArgs</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、<span class="doctag">@annotation</span>匹配是<span class="doctag">@Controller</span>类型的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.springframework.stereotype.Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutAnnocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、<span class="doctag">@within</span>匹配<span class="doctag">@Controller</span>注解下的方法，要求注解的<span class="doctag">@Controller</span>级别为<span class="doctag">@Retention</span>(RetentionPolicy.CLASS)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(org.springframework.stereotype.Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutWithinAnno</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、<span class="doctag">@target</span>匹配的是<span class="doctag">@Controller</span>的类下面的方法，要求注解的<span class="doctag">@Controller</span>级别为<span class="doctag">@Retention</span>(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@target(org.springframework.stereotype.Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutTargetAnno</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、<span class="doctag">@args</span>匹配参数中标注为<span class="doctag">@Sevice</span>的注解的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@args(org.springframework.stereotype.Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutArgsAnno</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、使用excution表达式</span></span><br><span class="line"><span class="comment"> * execution(</span></span><br><span class="line"><span class="comment"> *  modifier-pattern?           //用于匹配public、private等访问修饰符</span></span><br><span class="line"><span class="comment"> *  ret-type-pattern            //用于匹配返回值类型，不可省略</span></span><br><span class="line"><span class="comment"> *  declaring-type-pattern?     //用于匹配包类型</span></span><br><span class="line"><span class="comment"> *  name-pattern(param-pattern) //用于匹配类中的方法，不可省略</span></span><br><span class="line"><span class="comment"> *  throws-pattern?             //用于匹配抛出异常的方法</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下面的表达式解释为：匹配com.example.controller.HelloController类中以hello开头的修饰符为public返回类型任意的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(public * com.example.controller.HelloController.hello*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-AOP实践"><a href="#2-AOP实践" class="headerlink" title="2.AOP实践"></a>2.AOP实践</h3><h4 id="2-1-HTTP接口鉴权"><a href="#2-1-HTTP接口鉴权" class="headerlink" title="2.1 HTTP接口鉴权"></a>2.1 HTTP接口鉴权</h4><p>需求：</p>
<ol>
<li>可以定制地为某些指定的 HTTP RESTful api 提供权限验证功能。</li>
<li>当调用方的权限不符时, 返回错误。<br>相关依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-1-1-自定义注解"><a href="#2-1-1-自定义注解" class="headerlink" title="2.1.1 自定义注解"></a>2.1.1 自定义注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AuthChecker &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AuthChecker</code> 注解是一个方法注解，它用于注解 RequestMapping 方法。</p>
<h5 id="2-1-2-aspect的实现"><a href="#2-1-2-aspect的实现" class="headerlink" title="2.1.2 aspect的实现"></a>2.1.2 aspect的实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAopAdviseDefine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个 Pointcut, 使用切点表达式函数来描述对哪些Join point使用advice.</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.annotation.AuthChecker)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义advice</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">checkAuth</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span>&#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        <span class="comment">//检查用户所传递的 token 是否合法</span></span><br><span class="line">        String token = getToken(request);</span><br><span class="line">        <span class="keyword">if</span> (!token.equalsIgnoreCase(<span class="string">"111"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"token不合法！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cookie.getName().equalsIgnoreCase(<span class="string">"token"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-Controller"><a href="#2-1-3-Controller" class="headerlink" title="2.1.3 Controller"></a>2.1.3 Controller</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/aop/http"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"alive"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"服务一切正常"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AuthChecker</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"登录成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-4-测试"><a href="#2-1-4-测试" class="headerlink" title="2.1.4 测试"></a>2.1.4 测试</h5><p><img data-src="../../../../assets/img/222715.jpg" alt><br>token缺失/不正确：<br><img data-src="../../../../assets/img/222716.jpg" alt><br>token正确：<br><img data-src="../../../../assets/img/222717.jpg" alt></p>
<h4 id="2-2-方法调用日志"><a href="#2-2-方法调用日志" class="headerlink" title="2.2 方法调用日志"></a>2.2 方法调用日志</h4><p>需求:</p>
<ol>
<li>某个服务下的方法的调用需要有log记录调用的参数以及返回结果。</li>
<li>当方法调用出异常时，有特殊处理，例如打印异常 log，报警等。<h5 id="2-2-1-aspect-的实现"><a href="#2-2-1-aspect-的实现" class="headerlink" title="2.2.1 aspect 的实现"></a>2.2.1 aspect 的实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAopAdviseDefine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个Pointcut, 使用切点表达式函数来描述对哪些 Join point 使用 advise.</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.example.service..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poincut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义advise</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"poincut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMethodInvokeParam</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---Before method &#123;&#125; invoke, param: &#123;&#125;---"</span>,</span><br><span class="line">            joinPoint.getSignature().toShortString(),</span><br><span class="line">            joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"poincut()"</span>,returning = <span class="string">"message"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMethodInvokeResult</span><span class="params">(JoinPoint joinPoint,Object message)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---After method &#123;&#125; invoke, result: &#123;&#125;---"</span>,</span><br><span class="line">                joinPoint.getSignature().toShortString(),</span><br><span class="line">                joinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"poincut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMethodInvokeException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---method &#123;&#125; invoke exception: &#123;&#125;---"</span>,</span><br><span class="line">                joinPoint.getSignature().toShortString(),</span><br><span class="line">                exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-2-2-Service"><a href="#2-2-2-Service" class="headerlink" title="2.2.2 Service"></a>2.2.2 Service</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LogMethod</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---LogService: logMethod invoked, param: &#123;&#125;---"</span>, param);</span><br><span class="line">        <span class="keyword">return</span> random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---LogService: exceptionMethod invoked---"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Something bad happened!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalServiceImpl</span> <span class="keyword">implements</span> <span class="title">NormalService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---NormalService: someMethod invoked---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LogAdviseTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NormalService normalService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logService.LogMethod(<span class="string">"LogMethod Test!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logService.exceptionMethod();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        normalService.normalMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/103636.jpg" alt></p>
<h4 id="2-3-方法耗时统计"><a href="#2-3-方法耗时统计" class="headerlink" title="2.3 方法耗时统计"></a>2.3 方法耗时统计</h4><p>需求:</p>
<ol>
<li>为服务中的每个方法调用进行调用耗时记录.</li>
<li>将方法调用的时间戳, 方法名, 调用耗时上报到监控平台<h5 id="2-3-1-aspect-实现"><a href="#2-3-1-aspect-实现" class="headerlink" title="2.3.1 aspect 实现"></a>2.3.1 aspect 实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpiredAopAdviseDefine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.example.service.impl.ExpiredServiceImpl)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodInvokeExpiredTime</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ProceedingJoinPoint proceedingJoinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// StopWatch 任务执行时间监视器</span></span><br><span class="line">            StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            <span class="comment">// 开始</span></span><br><span class="line">            stopWatch.start();</span><br><span class="line">            Object proceed = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="comment">// 结束</span></span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="comment">// 上报到监控平台</span></span><br><span class="line">            reportToMonitorSystem(</span><br><span class="line">                proceedingJoinPoint.getSignature().toShortString(),</span><br><span class="line">                stopWatch.getTotalTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportToMonitorSystem</span><span class="params">(String methodName, <span class="keyword">long</span> expiredTime)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---method &#123;&#125; invoked, expired time: &#123;&#125; ms---"</span>,</span><br><span class="line">            methodName,</span><br><span class="line">            expiredTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-3-2-Service"><a href="#2-3-2-Service" class="headerlink" title="2.3.2 Service"></a>2.3.2 Service</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpiredServiceImpl</span> <span class="keyword">implements</span> <span class="title">ExpiredService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expiredTimeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"---SomeService: someMethod invoked---"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟耗时任务</span></span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">500</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-测试"><a href="#2-3-3-测试" class="headerlink" title="2.3.3 测试"></a>2.3.3 测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExpiredAdviseTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExpiredService expiredService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExpiredTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        expiredService.expiredTimeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/111548.jpg" alt></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>面向切面编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tree命令导出文件夹/文件的目录树</title>
    <url>/shell_tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Windows和Linux都有tree命令，主要功能是创建文件列表，将所有文件以树的形式列出来</p>
<h3 id="1-Windows的tree命令"><a href="#1-Windows的tree命令" class="headerlink" title="1.Windows的tree命令"></a>1.Windows的tree命令</h3><p>使用tree命令导出windows的文件夹/文件的目录树</p>
<a id="more"></a>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">TREE [<span class="string">drive:</span>][<span class="symbol">path</span>] [/F] [/A]</span><br><span class="line">/F   显示每个文件夹中文件的名称。（带扩展名）</span><br><span class="line">/A   使用 ASCII 字符，而不使用扩展字符。(如果要显示中文，例如 tree /f /A &gt;tree.txt)</span><br><span class="line">tree /f &gt; list.txt  将带扩展名的文件目录输出到list.txt文件中</span><br></pre></td></tr></table></figure>

<h3 id="2-Linux的tree命令"><a href="#2-Linux的tree命令" class="headerlink" title="2.Linux的tree命令"></a>2.Linux的tree命令</h3><p>Linux下的tree就比较强大了，但一般系统并不自带这个命令，需要手动下载安装：sudo apt-get install tree 。</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">a 显示所有文件和目录。</span></span><br><span class="line"><span class="ruby">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span></span><br><span class="line"><span class="ruby">-C 在文件和目录清单加上色彩，便于区分各种类型。</span></span><br><span class="line"><span class="ruby">-d 显示目录名称而非内容。</span></span><br><span class="line"><span class="ruby">-D 列出文件或目录的更改时间。</span></span><br><span class="line"><span class="ruby">-f 在每个文件或目录之前，显示完整的相对路径名称。</span></span><br><span class="line"><span class="ruby">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"="</span>,<span class="string">"@"</span>,<span class="string">"|"</span>号。</span></span><br><span class="line"><span class="ruby">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span></span><br><span class="line"><span class="ruby">-i 不以阶梯状列出文件或目录名称。</span></span><br><span class="line"><span class="ruby">-I 不显示符合范本样式的文件或目录名称。</span></span><br><span class="line"><span class="ruby">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span></span><br><span class="line"><span class="ruby">-n 不在文件和目录清单加上色彩。</span></span><br><span class="line"><span class="ruby">-N 直接列出文件和目录名称，包括控制字符。</span></span><br><span class="line"><span class="ruby">-p 列出权限标示。</span></span><br><span class="line"><span class="ruby">-P 只显示符合范本样式的文件或目录名称。</span></span><br><span class="line"><span class="ruby">-q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</span></span><br><span class="line"><span class="ruby">-s 列出文件或目录大小。</span></span><br><span class="line"><span class="ruby">-t 用文件和目录的更改时间排序。</span></span><br><span class="line"><span class="ruby">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span></span><br><span class="line"><span class="ruby">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>执行命令行<code>tree /f &gt; tree.txt</code></p>
<p><img data-src="../../../../assets/img/105116.jpg" alt></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>四种常见的排序算法</title>
    <url>/23116/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p><strong>思想:</strong> 每一趟将待排序序列中最大元素移到最后，剩下的为新的待排序序列, 重复上述步骤直到排完所有元素。这只是冒泡排序的一种, 当然也可以从后往前排</p>
<p><strong>平均时间复杂度:</strong> O(n^2)     </p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p><strong>思想:</strong> 每一趟从待排序序列选择一个最小的元素放在已排好序列的末尾, 剩下的为待排序序列, 重复上述步骤直至完成排序</p>
<p><strong>平均时间复杂度:</strong> O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//默认第一个是最小的。</span></span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="comment">//记录最小的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="comment">//通过与后面的数据进行比较得出，最小值和下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后将最小值与本次循环的，开始值交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">        <span class="comment">//说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。每次只需要找无需的最小值，做替换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p><strong>思想:</strong> 1. 默认从第二个数据开始比较。</p>
<p>　　  2.如果第二个数据比第一个小，则交换。然后在用第三个数据比较，如果比前面小，则插入（狡猾）。否则，退出循环</p>
<p>　　  3.说明：默认将第一数据看成有序列表，后面无序的列表循环每一个数据，如果比前面的数据小则插入（交换）。否则退出</p>
<p><strong>平均时间复杂度:</strong>  O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//外层循环，从第二个开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//内存循环，与前面排好序的数据比较，如果后面的数据小于前面的则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不小于，说明插入完毕，退出内层循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p><strong>采用分治法的思想：</strong>首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。</p>
<p><strong>平均时间复杂度:</strong>  O(n*log(n))  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pivot:位索引;p_pos:轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot, p_pos, i, temp;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            p_pos = low;</span><br><span class="line">            pivot = arr[p_pos];</span><br><span class="line">            <span class="keyword">for</span> (i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">                    p_pos++;</span><br><span class="line">                    temp = arr[p_pos];</span><br><span class="line">                    arr[p_pos] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = arr[low];</span><br><span class="line">            arr[low] = arr[p_pos];</span><br><span class="line">            arr[p_pos] = temp;</span><br><span class="line">            <span class="comment">//分而治之</span></span><br><span class="line">            quickSort(arr, low, p_pos - <span class="number">1</span>);<span class="comment">//排序左半部分</span></span><br><span class="line">            quickSort(arr, p_pos + <span class="number">1</span>, high);<span class="comment">//排序右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"> 	    d.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注-各排序时间复杂度"><a href="#注-各排序时间复杂度" class="headerlink" title="注: 各排序时间复杂度"></a>注: 各排序时间复杂度</h3><table>
<thead>
<tr>
<th>排序方法        平均情况        最好情况            最坏情况        辅助空间        稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序         O(n^2)                  O(n)               O(n^2)            O(1)                稳定</td>
</tr>
<tr>
<td>选择排序         O(n^2)                 O(n^2)            O(n^2)            O(1)              不稳定</td>
</tr>
<tr>
<td>插入排序         O(n^2)                  O(n)               O(n^2)             O(1)                稳定</td>
</tr>
<tr>
<td>希尔排序O(n*log(n))~O(n^2)      O(n^1.3)       O(n^2)            O(1)              不稳定</td>
</tr>
<tr>
<td>堆排序          O(n<em>log(n))          O(n</em>log(n))       O(n*log(n))         O(1)              不稳定</td>
</tr>
<tr>
<td>归并排序       O(n<em>log(n))        O(n</em>log(n))       O(n*log(n))          O(n)                稳定</td>
</tr>
<tr>
<td>快速排序       O(n<em>log(n))        O(n</em>log(n))            O(n^2)             O(1)              不稳定</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式(JDK Proxy与CGLIB Proxy)</title>
    <url>/proxymode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><ol>
<li><p>售卖香水接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义真实对象和代理对象的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义香水提供商，实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChanelFactory</span> <span class="keyword">implements</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功购买香奈儿品牌的香水，价格是："</span> + price + <span class="string">"元！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>定义代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoHongSellProxy</span> <span class="keyword">implements</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代理对象内部保存对真实目标对象的引用，控制其它对象对目标对象的访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChanelFactory chanelFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoHongSellProxy</span><span class="params">(ChanelFactory chanelFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chanelFactory = chanelFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        doSomethingBeforeSell();</span><br><span class="line">        chanelFactory.sellPerfume(price);</span><br><span class="line">        doSomethingAfterSell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBeforeSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小红代理购买香水前的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfterSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小红代理购买香水后的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>购买香水</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 访问者仅能通过代理对象访问真实目标对象，不可直接访问目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChanelFactory chanelFactory = <span class="keyword">new</span> ChanelFactory();</span><br><span class="line">        XiaoHongSellProxy xiaoHongSellProxy = <span class="keyword">new</span> XiaoHongSellProxy(chanelFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 代理对象并不是真正提供服务的对象，它只是替访问者访问目标对象的一个中间人，</span></span><br><span class="line"><span class="comment">         * 真正提供服务的还是目标对象，而代理对象的作用就是在目标对象提供服务之前或之后能够执行额外的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        xiaoHongSellProxy.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小红代理购买香水前的额外操作...</span><br><span class="line">成功购买香奈儿品牌的香水，价格是：<span class="number">100.0</span>元！</span><br><span class="line">小红代理购买香水后的额外操作...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>代理模式的定义：</strong>给目标对象提供一个代理对象，代理对象包含该目标对象，并控制对该目标对象的访问。</p>
<p><strong>代理模式的目的：</strong>通过代理对象的隔离，可以在对目标对象的访问前后增加额外的业务逻辑，实现功能增强；通过代理对象访问目标对象，可以防止系统大量的直接对目标对象进行不正确的访问。</p>
<h3 id="2-静态代理与动态代理"><a href="#2-静态代理与动态代理" class="headerlink" title="2.静态代理与动态代理"></a>2.静态代理与动态代理</h3><p><strong>共同点：</strong>都能实现代理模式；代理对象和目标对象都需要实现一个公共接口。</p>
<p><strong>不同点：</strong></p>
<ul>
<li>动态代理产生代理对象的时机是<strong>运行时动态生成</strong>，它没有Java源文件，<strong>直接生成字节码文件实例化代理对象</strong>，而静态代理的代理对象，在<strong>程序编译时</strong>已经写好了Java文件，直接new一个代理对象即可。</li>
<li>动态代理比静态代理更加稳健，对程序的可维护性和扩展性更加友好。</li>
</ul>
<h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>面对新的需求时，不需要修改代理对象的代码，只需要新增接口对象，在客户端调用即可完成新的代理。</p>
<h4 id="3-1-JDK-Proxy"><a href="#3-1-JDK-Proxy" class="headerlink" title="3.1 JDK Proxy"></a>3.1 JDK Proxy</h4><p>JDK提供的一个动态代理机制，涉及到Proxy和InvocationHandler两个核心类。</p>
<p><strong>代理对象是在程序运行过程中，有代理工厂动态生成，代理对象本身不存在Java源文件。</strong></p>
<p>代理工厂需要实现InvocationHanlder接口并实现invoke()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellProxyFactory</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行代理后的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行代理前的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 真正执行的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 调用第二个参数method时传入的参数列表值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        Object invokeObject = method.invoke(object, args);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成代理对象需要用到Proxy类，里面的静态方法newProxyInstance可以生成任意一个代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loader 加载动态代理的类的类加载器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 代理类实现的接口，可以传入多个接口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 指定代理类的调用处理程序，即调用接口中的方法时，会找到该代理工厂h，执行invoke()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<p><strong>新增红酒代理功能：</strong></p>
<ul>
<li><p>创建新的红酒供应商和售卖红酒接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 红酒供应商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedWineFactory</span> <span class="keyword">implements</span> <span class="title">SellWine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SellWine</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功售卖一瓶红酒，价格："</span> + price + <span class="string">"元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 售卖红酒接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellWine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SellWine</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在客户端实例化一个代理对象，然后向该代理对象购买红酒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// buyChannel();</span></span><br><span class="line">        buyRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ChanelFactory chanelFactory = <span class="keyword">new</span> ChanelFactory();</span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory(chanelFactory);</span><br><span class="line">        SellPerfume sellPerfume = (SellPerfume)Proxy.newProxyInstance(chanelFactory.getClass().getClassLoader(),</span><br><span class="line">            chanelFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        sellPerfume.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyRedWine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个红酒供应商</span></span><br><span class="line">        RedWineFactory redWineFactory = <span class="keyword">new</span> RedWineFactory();</span><br><span class="line">        <span class="comment">// 实例化代理工厂，传入红酒供应商引用控制对其的访问</span></span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory(redWineFactory);</span><br><span class="line">        <span class="comment">// 实例化代理对象</span></span><br><span class="line">        SellWine sellWine = (SellWine)Proxy.newProxyInstance(redWineFactory.getClass().getClassLoader(),</span><br><span class="line">            redWineFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        <span class="comment">// 代理售卖红酒</span></span><br><span class="line">        sellWine.SellWine(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li>JDK动态代理的使用方法<ul>
<li>代理工厂需要实现InvocationHandle接口，调用代理方法会转向执行invoke()方法。</li>
<li>生成代理对象需要使用Proxy对象中的newProxyInsatnce()方法，返回对象可强转成传入的其中一个接口，然后调用接口方法即可实现代理。</li>
</ul>
</li>
<li>JDK动态代理的特点<ul>
<li>目标对象强制需要实现一个接口，否则无法使用JDK动态代理。</li>
</ul>
</li>
</ol>
<h4 id="3-2-CGLIB"><a href="#3-2-CGLIB" class="headerlink" title="3.2 CGLIB"></a>3.2 CGLIB</h4><p>CGLIB不是JDK自带的动态代理，它需要导入第三方依赖，它是一个字节码生成类库，能够在运行时动态生成代理类对Java类和Java接口扩展。CGLIB不仅能够为Java接口做代理，而且<strong>能够为普通的Java类做代理</strong>，而JDK Proxy只能为实现了接口的Java类做代理。</p>
<p><strong>CGLIB可以代理没有实现接口的Java类</strong></p>
<ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CGLIB代理中有两个核心的类：MetondInterceptor接口和Enhancer类，前者是实现一个代理工厂的根接口，后者是创建动态代理对象的类。</p>
<p>定义代理工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关联真实对象，控制真实对象的访问</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从代理工厂获取一个代理对象实例，等价于创建小红代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要增强类的类加载器</span></span><br><span class="line">        enhancer.setClassLoader(object.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类，真实对象</span></span><br><span class="line">        enhancer.setSuperclass(object.getClass());</span><br><span class="line">        <span class="comment">// 设置方法拦截器，代理工厂</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行方法前额外的操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行方法后额外的操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 被代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 被拦截方法的所有入参值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理，用于调用原始的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        Object invokeSuperObject = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeSuperObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory();</span><br><span class="line">        <span class="comment">//获取一个代理实例</span></span><br><span class="line">        ChanelFactory chanelFactoryInstance = (ChanelFactory) sellProxyFactory.getProxyInstance(<span class="keyword">new</span> ChanelFactory());</span><br><span class="line">        chanelFactoryInstance.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li><p>CGLIB的使用方法</p>
<ul>
<li>代理工厂需要<strong>实现MethodInterceptor接口</strong>，并重写方法，<strong>内部关联真实对象</strong>，控制第三者对真实对象的访问；代理工厂内部暴露getInstance(Object object)方法，<strong>用于从代理工厂中获取一个代理对象实例</strong>。</li>
<li>Enhancer类用于从代理工厂中实例化一个代理对象，给调用者提供代理服务。</li>
</ul>
</li>
<li><p>JDK Proxy和CGLIB的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>JDK Proxy</th>
<th>CGLIB</th>
</tr>
</thead>
<tbody><tr>
<td>代理工厂实现接口</td>
<td>InvocationHandler</td>
<td>MethodInterceptor</td>
</tr>
<tr>
<td>构造代理对象给Client服务</td>
<td>Proxy</td>
<td>Enhancer</td>
</tr>
</tbody></table>
<p><strong>不同点：</strong></p>
<ul>
<li>CGLIB可以代理大部分类；而JDK Proxy仅能够代理实现了接口的类</li>
<li>CGLIB采用动态创建被代理类的子类实现方法拦截的方法，所以CGLIB不能代理被final关键字修饰的类和方法。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="4-动态代理的实际运用"><a href="#4-动态代理的实际运用" class="headerlink" title="4.动态代理的实际运用"></a>4.动态代理的实际运用</h3><p>AOP允许我们<strong>将重复的代码逻辑抽取出来形成一个单独的覆盖层</strong>，在执行代码时可以将覆盖层嵌入到原代码逻辑里面去。</p>
<p>如下图，method1和method2都需要在方法执行前后记录日志，AOP可以将大量重复的Log.info代码包装到额外的一层，监听方法的执行，当方法被调用时，通用的日志记录层会拦截掉该方法，在该方法调用前后记录日志，这样可以让方法专注于自己的业务逻辑而无需关注其它不必要的信息。</p>
<p><img data-src="../../../../assets/img/640.gif" alt></p>
<p>Spring AOP有许多功能：提供缓存、提供日志环绕、事务处理……</p>
<p><strong>事务</strong></p>
<p>@Transactional</p>
<p>每个有关数据库的操作都有保证一个事务内的所有操作，要么全部执行成功，要么全部执行失败，传统的事务失败回滚和成功提交是使用try…catch代码块完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    session = getSqlSessionFactory().openSession(<span class="keyword">false</span>);</span><br><span class="line">    session.update(<span class="string">"..."</span>, <span class="keyword">new</span> Object());</span><br><span class="line">    <span class="comment">// 事务提交</span></span><br><span class="line">    session.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// 事务回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭事务</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个方法都需要写这一段逻辑非常冗余，所以Spring封装了一个注解@Transactional，使用它后，调用方法时会监视方法，如果方法上含有该注解，就会自动把数据库相关操作的代码包裹起来，类似上面一段代码。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发(一)开发者接入微信公众号</title>
    <url>/38103/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="微信公众号开发-一-开发者接入微信公众号"><a href="#微信公众号开发-一-开发者接入微信公众号" class="headerlink" title="微信公众号开发(一)开发者接入微信公众号"></a>微信公众号开发(一)开发者接入微信公众号</h4><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>该文章基于<code>JDK1.8</code>  <code>springboot2.1.7.RELEASE</code>环境</p>
<p>实现开发者第一次接入微信公众号后台的需求</p>
<h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h3><h4 id="2-1-进入微信公众平台注册账号"><a href="#2-1-进入微信公众平台注册账号" class="headerlink" title="2.1 进入微信公众平台注册账号"></a>2.1 进入微信公众平台注册账号</h4><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>个人用户建议注册订阅号</p>
<a id="more"></a>

<h4 id="2-2-内网穿透"><a href="#2-2-内网穿透" class="headerlink" title="2.2 内网穿透"></a>2.2 内网穿透</h4><p>因为要直接用内网本机开发调试，微信网页授权在回调时要访问本机，所以直接做个内网穿透，可以直接在外网访问到本机，做法如下：</p>
<ol>
<li><p>登录 <span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24v">https://natapp.cn/<i class="fa fa-external-link-alt"></i></span> （我用的natapp.cn，你可以用其他类似的，个人感觉这个不错）</p>
</li>
<li><p>购买隧道：购买后使用方式: </p>
<blockquote>
<p> 参考官方教程：<span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24vYXJ0aWNsZS9uYXRhcHBfbmV3Ymll">https://natapp.cn/article/natapp_newbie<i class="fa fa-external-link-alt"></i></span> </p>
</blockquote>
</li>
</ol>
<p>使用后会得到natapp分配的网址，如 xxx.natapp.cn，这个地址就可以访问到开发本机。</p>
<p>   <img data-src="../../../../assets/img/142029.jpg" alt></p>
<ol start="3">
<li><p>下载并配置config.ini, 运行natapp</p>
<p><img data-src="../../../../assets/img/142853.jpg" alt></p>
</li>
</ol>
<h3 id="3-接入认证成为开发者"><a href="#3-接入认证成为开发者" class="headerlink" title="3.接入认证成为开发者"></a>3.接入认证成为开发者</h3><blockquote>
<p>可参考微信官方开发文档 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0FjY2Vzc19PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="3-1-填写服务器配置"><a href="#3-1-填写服务器配置" class="headerlink" title="3.1 填写服务器配置"></a>3.1 填写服务器配置</h4><p>登录微信公众号开发平台:<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span>    <code>开发</code>—<code>开发者工具</code>—<code>公众平台测试账号</code></p>
<p><img data-src="../../../../assets/img/144010.jpg" alt></p>
<ul>
<li>Tips:</li>
</ul>
<ol>
<li>微信公众号接口必须以<span class="exturl" data-url="aHR0cDovL3huLS1odHRwcy13bTZqLy/lvIDlpLTvvIzliIbliKvmlK/mjIE4MOerr+WPo+WSjDQ0M+err+WPo++8gQ==">http://或https://开头，分别支持80端口和443端口！<i class="fa fa-external-link-alt"></i></span></li>
<li>这里的url可以选择自己买的服务器地址，记得必须开放80端口去使用！ 或者使用内网映射外网工具生成一个域名地址供给你开发使用，此方法自行百度，如下就是其中一种使用~</li>
<li>目前提交是无法配置成功的, 不要着急</li>
</ol>
<h4 id="3-2-提交验证URL有效性"><a href="#3-2-提交验证URL有效性" class="headerlink" title="3.2 提交验证URL有效性"></a>3.2 提交验证URL有效性</h4><h5 id="3-2-1-搭建SpingBoot工程"><a href="#3-2-1-搭建SpingBoot工程" class="headerlink" title="3.2.1 搭建SpingBoot工程"></a>3.2.1 搭建SpingBoot工程</h5><p>项目结构</p>
<p><img data-src="../../../../assets/img/144403.jpg" alt></p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weixin-java-mp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">wechat:</span></span><br><span class="line">  <span class="attr">mpAppId:</span> <span class="string">xxxxxxxx</span>		<span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpAppSecret:</span> <span class="string">xxxxxx</span>	<span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpToken:</span> <span class="string">xxxxx</span>		<span class="comment">#与前面在公众平台测试账号---接口配置信息所填写保持一致</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span>		<span class="comment">#端口号</span></span><br></pre></td></tr></table></figure>

<p>sha1加密工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sha1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(<span class="string">"sha1"</span>);</span><br><span class="line">            <span class="comment">// 放入加密字符串</span></span><br><span class="line">            digest.update(str.getBytes());</span><br><span class="line">            <span class="comment">// 进行加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] digestMsg = digest.digest();</span><br><span class="line">            <span class="comment">// byte转换16进制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : digestMsg) &#123;</span><br><span class="line">                sb.append(String.format(<span class="string">"%02x"</span>, b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"wechat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatAccountConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mpAppId;</span><br><span class="line">    <span class="keyword">private</span> String mpAppSecret;</span><br><span class="line">    <span class="keyword">private</span> String mpToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/wechat/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WechatAccountConfig wechatAccountConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理微信认证：验证服务器地址的有效性，get提交</span></span><br><span class="line"><span class="comment">     * signature: 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span></span><br><span class="line"><span class="comment">     * timestamp 时间戳</span></span><br><span class="line"><span class="comment">     * nonce: 随机数</span></span><br><span class="line"><span class="comment">     * echostr: 随机字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSignature</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============= 处理微信认证 ==============="</span>);</span><br><span class="line">        <span class="comment">// 拿到微信的请求参数</span></span><br><span class="line">        String signature = request.getParameter(<span class="string">"signature"</span>);</span><br><span class="line">        String timestamp = request.getParameter(<span class="string">"timestamp"</span>);</span><br><span class="line">        String nonce = request.getParameter(<span class="string">"nonce"</span>);</span><br><span class="line">        String echostr = request.getParameter(<span class="string">"echostr"</span>);</span><br><span class="line">        <span class="comment">// TODO 这里的token是微信公众平台上自己所配的！</span></span><br><span class="line">        String token = wechatAccountConfig.getMpToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① 将token、timestamp、nonce三个参数进行字典序排序 b a d c h ==&gt;a b c d h</span></span><br><span class="line">        String[] strArr = &#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="comment">// 字典排序</span></span><br><span class="line">        Arrays.sort(strArr);</span><br><span class="line">        <span class="comment">// ② 将三个参数字符串拼接成一个字符串进行sha1加密</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strArr) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        String sha1Str = SecurityUtil.sha1(sb.toString());</span><br><span class="line">        <span class="comment">// ③ 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">        <span class="keyword">if</span> (sha1Str.equals(signature)) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，就是来自微信请求</span></span><br><span class="line">            <span class="comment">// 若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效</span></span><br><span class="line">            response.getWriter().println(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeChatService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-测试"><a href="#3-2-2-测试" class="headerlink" title="3.2.2 测试"></a>3.2.2 测试</h5><ol>
<li>启动该SpringBoot项目</li>
<li>回到公众平台测试账号—接口配置信息, 点击提交即可</li>
</ol>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/14808/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 中一般认为有23种设计模式, 下面介绍几种常见的设计模式。总体来说设计模式分为三大类： </p>
<ul>
<li>创建型模式, 共5五种：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、原型模式。 </li>
<li>结构型模式，共7种：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、代理模式、外观模式、桥接模式、组合模式、享元模式。 </li>
<li>行为型模式，共11种：策略模式、模板方法模式、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<a id="more"></a>

<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>所谓的单例设计指的是<strong>一个类只允许产生一个实例化对象。</strong><br>最好理解的一种设计模式，分为懒汉式和饿汉式。</p>
<p><strong>饿汉式</strong>: 构造方法私有化，外部无法产生新的实例化对象，只能通过static方法取得实例化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类的内部可以访问私有结构，所以可以在类的内部产生实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * private 声明构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式</strong>: 当第一次去使用Singleton对象的时候才会为其产生实例化对象的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 还未实例化</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当多个线程并发执行 getInstance() 方法时，懒汉式会存在线程安全问题，所以用到了 synchronized 来实现线程的同步，当一个线程获得锁的时候其他线程就只能在外等待其执行完毕。而饿汉式则不存在线程安全的问题。</p>
<p><strong>适用场景：</strong><br>    单例模式<strong>只允许创建一个对象</strong>，因此<strong>节省内存，加快对象访问速度</strong>，因此<strong>对象需要被公用的场合适合使用</strong>，如多个模块使用同一个数据源连接对象等等。如：<br>    (1) 需要频繁实例化然后销毁的对象。<br>    (2) 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。<br>    (3) 有状态的工具类对象。<br>    (4) 频繁访问数据库或文件的对象。<br>以下都是单例模式的经典使用场景：<br>    (1) 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>    (2) 控制资源的情况下，方便资源之间的互相通信。如线程池等。 </p>
<h3 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h3><p>一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。 </p>
<h3 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h3><p>对已有的业务逻辑进一步的封装, 使其增加额外的功能, 要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p><strong>适用环境:</strong></p>
<p>​    (1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
<p>​    (2) 处理那些可以撤消的职责。</p>
<p>​    (3) 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p>
<h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h3><p>适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h3><h4 id="5-1-简单工厂模式"><a href="#5-1-简单工厂模式" class="headerlink" title="5.1 简单工厂模式"></a>5.1 简单工厂模式</h4><p>简单工厂模式就是把<strong>对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的</strong>，只用告诉工厂我想要什么就行了。而这种方法的缺点也很明显，<strong>违背了设计模式的开闭原则</strong>，因为如果你要增加工厂可以初始化的类的时候，你必须对工厂进行改建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz开始启动了。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz停车了。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ford</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ford开始启动了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ford停车了。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCarInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Benz"</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> Benz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Ford"</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> Ford();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car c = Factory.getCarInstance(<span class="string">"Benz"</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.run();</span><br><span class="line">            c.stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"造不了这种汽车。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-工厂方法模式"><a href="#5-2-工厂方法模式" class="headerlink" title="5.2 工厂方法模式"></a>5.2 工厂方法模式</h4><p>设计一个工厂的接口，你想要什么东西，就写个类继承于这个工厂，这样就不用修改什么，直接添加就行了。就相当于，我这个工厂是用来生汽车的，而要什么品牌的汽车具体分到了每个车间，如果新多了一种品牌的汽车，直接新增一个车间就行了。那么问题又来了，如果想要生产大炮怎么办？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"plane...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broom</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"broom....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Moveable <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroomFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Broom();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VehicleFactory factory = <span class="keyword">new</span> BroomFactory();</span><br><span class="line">        Moveable m = factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-抽象工厂模式"><a href="#5-3-抽象工厂模式" class="headerlink" title="5.3 抽象工厂模式"></a>5.3 抽象工厂模式</h4><p>与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Weapon <span class="title">createWeapon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Food <span class="title">createFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">createFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> DefaultFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发(三)快递信息查询</title>
    <url>/12221/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-快递查询API"><a href="#1-快递查询API" class="headerlink" title="1.快递查询API"></a>1.快递查询API</h3><p>这里使用的是阿里云全国快递物流查询-快递查询接口:<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXQuYWxpeXVuLmNvbS9wcm9kdWN0cy81NjkyODAwNC9jbWFwaTAyMTg2My5odG1s">https://market.aliyun.com/products/56928004/cmapi021863.html<i class="fa fa-external-link-alt"></i></span></p>
<p>该接口支持只通过快递运单号查询物流信息, 不需要在额外设置参数. 该种方式95%能自动识别, 填写查询速度会更快, 已经满足一般开发的需求, 并能极大方便开发者的使用.</p>
<a id="more"></a>

<p><strong>请求参数说明</strong>    <img data-src="../../../../assets/img/215607.jpg" alt></p>
<p><strong>返回结果说明</strong>    <img data-src="../../../../assets/img/215818.jpg" alt></p>
<p>官方提供的示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String host = <span class="string">"https://wuliu.market.alicloudapi.com"</span>;</span><br><span class="line">        String path = <span class="string">"/kdi"</span>;</span><br><span class="line">        String method = <span class="string">"GET"</span>;</span><br><span class="line">        System.out.println(<span class="string">"请先替换成自己的AppCode"</span>);</span><br><span class="line">        String appcode = <span class="string">"833509fd73fe1124838xxxxxxxx"</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">"Authorization"</span>, <span class="string">"APPCODE "</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">"no"</span>, <span class="string">"462587770684"</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        querys.put(<span class="string">"type"</span>, <span class="string">"zto"</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        <span class="comment">//JDK 1.8示例代码请在这里下载：  http://code.fegine.com/Tools.zip</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	    	* 重要提示如下:</span></span><br><span class="line"><span class="comment">	    	* HttpUtils请从</span></span><br><span class="line"><span class="comment">	    	* https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">                * 或者直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/HttpUtils.zip</span></span><br><span class="line"><span class="comment">	    	* 下载</span></span><br><span class="line"><span class="comment">	    	*</span></span><br><span class="line"><span class="comment">	    	* 相应的依赖请参照</span></span><br><span class="line"><span class="comment">	    	* https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">                * 相关jar包（非pom）直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/aliyun-jar.zip</span></span><br><span class="line"><span class="comment">	    	*/</span></span><br><span class="line">                HttpResponse response = HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">	    	<span class="comment">//System.out.println(response.toString());如不输出json, 请打开这行代码，打印调试头部状态码。</span></span><br><span class="line">                <span class="comment">//状态码: 200 正常；400 URL无效；401 appCode错误； 403 次数用完； 500 API网管错误</span></span><br><span class="line">	    	<span class="comment">//获取response的body</span></span><br><span class="line">          System.out.println(EntityUtils.toString(response.getEntity())); <span class="comment">//输出json</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>正常返回示例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"0"</span>,<span class="comment">/* status 0:正常查询 201:快递单号错误 203:快递公司不存在 204:快递公司识别失败 205:没有信息 207:该单号被限制，错误单号 */</span></span><br><span class="line">	<span class="attr">"msg"</span>: <span class="string">"ok"</span>,</span><br><span class="line">	<span class="attr">"result"</span>: &#123;</span><br><span class="line">		<span class="attr">"number"</span>: <span class="string">"780098068058"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"zto"</span>,</span><br><span class="line">		<span class="attr">"list"</span>: [&#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-09 11:59:26"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【石家庄市】快件已在【长安三部】 签收,签收人: 本人,感谢使用中通快递,期待再次为您服务!"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-09 09:03:10"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件已到达 【长安三部】（0311-85344265）,业务员 容晓光（13081105270） 正在第1次派件, 请保持电话畅通,并耐心等待"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-08 23:43:44"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件离开 【石家庄】 发往 【长安三部】"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-08 21:00:44"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件到达 【石家庄】"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-07 01:38:45"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【广州市】 快件离开 【广州中心】 发往 【石家庄】"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-07 01:36:53"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【广州市】 快件到达 【广州中心】"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-07 00:40:57"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【广州市】 快件离开 【广州花都】 发往 【石家庄中转】"</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			<span class="attr">"time"</span>: <span class="string">"2018-03-07 00:01:55"</span>,</span><br><span class="line">			<span class="attr">"status"</span>: <span class="string">"【广州市】 【广州花都】（020-37738523） 的 马溪 （18998345739） 已揽收"</span></span><br><span class="line">		&#125;],</span><br><span class="line">		<span class="attr">"deliverystatus"</span>: <span class="string">"3"</span>, <span class="comment">/* 0：快递收件(揽件)1.在途中 2.正在派件 3.已签收 4.派送失败 5.疑难件 6.退件签收  */</span></span><br><span class="line">		<span class="attr">"issign"</span>: <span class="string">"1"</span>,                      <span class="comment">/*  1.是否签收                  */</span></span><br><span class="line">		<span class="attr">"expName"</span>: <span class="string">"中通快递"</span>,              <span class="comment">/*  快递公司名称                */</span>       </span><br><span class="line">		<span class="attr">"expSite"</span>: <span class="string">"www.zto.com"</span>,           <span class="comment">/*  快递公司官网                */</span></span><br><span class="line">		<span class="attr">"expPhone"</span>: <span class="string">"95311"</span>,                <span class="comment">/*  快递公司电话                */</span></span><br><span class="line">		<span class="attr">"courier"</span>: <span class="string">"容晓光"</span>,                <span class="comment">/*  快递员 或 快递站(没有则为空)*/</span></span><br><span class="line">                <span class="attr">"courierPhone"</span>:<span class="string">"13081105270"</span>,       <span class="comment">/*  快递员电话 (没有则为空)     */</span></span><br><span class="line">                <span class="attr">"updateTime"</span>:<span class="string">"2019-08-27 13:56:19"</span>, <span class="comment">/*  快递轨迹信息最新时间        */</span></span><br><span class="line">                <span class="attr">"takeTime"</span>:<span class="string">"2天20小时14分"</span>,         <span class="comment">/*  发货到收货消耗时长 (截止最新轨迹)  */</span></span><br><span class="line">                <span class="attr">"logo"</span>:<span class="string">"http://img3.fegine.com/express/zto.jpg"</span> <span class="comment">/* 快递公司LOGO */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败返回示例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"205"</span>,   <span class="comment">/* status状态码见产品详情 */</span></span><br><span class="line">	<span class="attr">"msg"</span>: <span class="string">"没有信息"</span>,</span><br><span class="line">	<span class="attr">"result"</span>: &#123;</span><br><span class="line">		<span class="attr">"number"</span>: <span class="string">"1111ADECD1234"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">		<span class="attr">"list"</span>: []</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误码定义:</p>
<table>
<thead>
<tr>
<th align="left">错误码</th>
<th>错误信息</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">201</td>
<td>快递单号错误</td>
<td>status：快递单号错误</td>
</tr>
<tr>
<td align="left">203</td>
<td>快递公司不存在</td>
<td>status：快递公司不存在</td>
</tr>
<tr>
<td align="left">204</td>
<td>快递公司识别失败</td>
<td>status：快递公司识别失败</td>
</tr>
<tr>
<td align="left">205</td>
<td>没有信息</td>
<td>status：没有信息</td>
</tr>
<tr>
<td align="left">207</td>
<td>该单号被限制，错误单号</td>
<td>status：该单号被限制，错误单号；一个单号对应多个快递公司，请求须指定快递公司</td>
</tr>
<tr>
<td align="left">0</td>
<td>正常</td>
<td>status：正常查询</td>
</tr>
</tbody></table>
<h3 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2.核心代码"></a>2.核心代码</h3><p><strong>工具类:</strong></p>
<ol>
<li><p>HttpUtils(官方提供)</p>
<blockquote>
<p>下载地址 <span class="exturl" data-url="aHR0cDovL2NvZGUuZmVnaW5lLmNvbS9IdHRwVXRpbHMuemlw">http://code.fegine.com/HttpUtils.zip<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
</li>
<li><p>TextUtil  用于判断输入发送的消息是否为英文字母+数字或纯数字(即符合快递运单号基本规则)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">DecText</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        Pattern p=Pattern.compile(<span class="string">"^[A-Za-z0-9]+$"</span>);    <span class="comment">//正则表达式</span></span><br><span class="line">        Matcher matcher = p.matcher(text);</span><br><span class="line">        <span class="keyword">return</span>  matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ExpressUtil  调用API查询物流信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">QueryExpress</span><span class="params">(String num)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = <span class="string">"https://wuliu.market.alicloudapi.com"</span>;</span><br><span class="line">        String path = <span class="string">"/kdi"</span>;</span><br><span class="line">        String method = <span class="string">"GET"</span>;</span><br><span class="line">        String appcode = <span class="string">"06a9e928218141bxxxxxxx"</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">"Authorization"</span>, <span class="string">"APPCODE "</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">"no"</span>, num);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        HttpResponse response = HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">        <span class="comment">//System.out.println(response.toString());</span></span><br><span class="line">        <span class="comment">//获取response的body</span></span><br><span class="line">        String str = EntityUtils.toString(response.getEntity());<span class="comment">//输出json</span></span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line">        <span class="comment">// 获取到key为result的值</span></span><br><span class="line">        String result = jsonObject.getString(<span class="string">"result"</span>);</span><br><span class="line">        jsonObject = JSONObject.parseObject(result);</span><br><span class="line">        <span class="comment">// 获取到key为list的值</span></span><br><span class="line">        String list = jsonObject.getString(<span class="string">"list"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时返回的数据为:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:45:12"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何海桃】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:45:12"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件在【浙江嘉善公司】进行装车，扫描员【何海桃】，车签号【】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:42:13"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:42:13"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件在【浙江嘉善公司】进行装包，扫描员【何德文】，袋号【9005261902881】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:41:07"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 19:29:40"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"【浙江嘉善公司】的【公司称重（)】已收件，扫描员【公司出港1】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	<span class="attr">"time"</span>: <span class="string">"2020-02-29 18:32:52"</span>,</span><br><span class="line">	<span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>MsgService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (TextUtil.DecText(content)==<span class="keyword">true</span>)&#123;</span><br><span class="line">                    String str = ExpressUtil.QueryExpress(content);</span><br><span class="line">                    List&lt;HashMap&gt; r = JSON.parseArray(str, HashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = r.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        System.out.println(r.get(i).get(<span class="string">"time"</span>) + <span class="string">":"</span> + r.get(i).get(<span class="string">"status"</span>));</span><br><span class="line">                        String string = r.get(i).get(<span class="string">"time"</span>) + <span class="string">":"</span> + r.get(i).get(<span class="string">"status"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                            stringBuilder.append(string);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            stringBuilder.append(string).append(<span class="string">"\n"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(stringBuilder);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    TextMessage text = <span class="keyword">new</span> TextMessage();</span><br><span class="line">                    text.setContent(stringBuilder+<span class="string">""</span>);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-功能测试"><a href="#3-功能测试" class="headerlink" title="3.功能测试"></a>3.功能测试</h3><p><img data-src="../../../../assets/img/68078.jpg" alt></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发(二)自动回复功能实现简单的天气查询</title>
    <url>/39972/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>微信公众平台服务器配置通过后，就能进行下面的开发啦</p>
<blockquote>
<p>首先可以查看官方的说明文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0dldHRpbmdfU3RhcnRlZC9PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>普通消息的类型分为7种：</p>
<a id="more"></a>

<ol>
<li>文本消息</li>
<li>图片消息</li>
<li>语音消息</li>
<li>视频消息</li>
<li>小视频消息</li>
<li>地理位置消息</li>
<li>链接消息</li>
</ol>
<p>本文使用的是文本消息与图片消息</p>
<h3 id="2-图文消息的自动回复"><a href="#2-图文消息的自动回复" class="headerlink" title="2.图文消息的自动回复"></a>2.图文消息的自动回复</h3><h4 id="2-1-文本消息"><a href="#2-1-文本消息" class="headerlink" title="2.1 文本消息"></a>2.1 文本消息</h4><p>文本消息的XML结构是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数包含：<img data-src="../../../../assets/img/203231.jpg" alt></p>
<p>定义一个BaseMessage，消息基类，封装通用属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息基类（普通用户 -&gt; 公众帐号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开发者微信号</span></span><br><span class="line">    <span class="keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="comment">// 发送方帐号（一个OpenID）</span></span><br><span class="line">    <span class="keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="comment">// 消息创建时间 （整型）</span></span><br><span class="line">    <span class="keyword">private</span> String CreateTime;</span><br><span class="line">    <span class="comment">// 消息类型（text/image/location/link）</span></span><br><span class="line">    <span class="keyword">private</span> String MsgType;</span><br><span class="line">    <span class="comment">// 消息id，64位整型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> MsgId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位0x0001被标志时，星标刚收到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> FuncFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义文本消息属性TextMessage：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="keyword">private</span> String Content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-图片消息"><a href="#2-2-图片消息" class="headerlink" title="2.2 图片消息"></a>2.2 图片消息</h4><p>图片消息的XML结构是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[image]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[this is a url]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span>&lt;![CDATA[media_id]]&gt;<span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>参数包含：<img data-src="../../../../assets/img/215347.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-图文消息"><a href="#2-3-图文消息" class="headerlink" title="2.3 图文消息"></a>2.3 图文消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Description;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片链接，支持JPG、PNG格式，&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 较好的效果为大图640*320，小图80*80</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String PicUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Title;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击图文消息跳转链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 图文消息 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息个数，限制为10条以内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ArticleCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多条图文消息信息，默认第一个item为大图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Article&gt; Articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><h4 id="3-1-工具类MessageUtil"><a href="#3-1-工具类MessageUtil" class="headerlink" title="3.1 工具类MessageUtil"></a>3.1 工具类MessageUtil</h4><ol>
<li>解析微信发来的请求（xml）</li>
<li>将响应消息的Java对象转换成xml</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="string">"text"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：音乐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="string">"music"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：图文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="string">"news"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="string">"text"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="string">"image"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="string">"link"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：地理位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="string">"location"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：音频</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="string">"voice"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="string">"event"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="string">"subscribe"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="string">"unsubscribe"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_CLICK = <span class="string">"CLICK"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml转换为map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">xmlToMap</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"></span><br><span class="line">        InputStream ins = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = request.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Document doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = reader.read(ins);</span><br><span class="line">            Element root = doc.getRootElement();</span><br><span class="line"></span><br><span class="line">            List&lt;Element&gt; list = root.elements();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Element e : list) &#123;</span><br><span class="line">                map.put(e.getName(), e.getText());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 解析微信发来的请求（XML）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月7日 上午10:04:02</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">parseXml</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将解析结果存储在HashMap中</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 从request中取得输入流</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        <span class="comment">// 读取输入流</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(inputStream);</span><br><span class="line">        <span class="comment">// 得到xml根元素</span></span><br><span class="line">        Element root = document.getRootElement();</span><br><span class="line">        <span class="comment">// 得到根元素的所有子节点</span></span><br><span class="line">        List&lt;Element&gt; elementList = root.elements();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> (Element e : elementList) &#123;</span><br><span class="line">            map.put(e.getName(), e.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public static XStream xstream = new XStream();</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本消息对象转换成xml</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textMessage 文本消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> xml</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">textMessageToXml</span><span class="params">(TextMessage textMessage)</span></span>&#123;</span><br><span class="line"><span class="comment">//        XStream xstream = new XStream();</span></span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, textMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图文消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> newsMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月8日 下午4:14:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">newsMessageToXml</span><span class="params">(NewsMessage newsMessage)</span> </span>&#123;</span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, newsMessage.getClass());</span><br><span class="line">        xstream.alias(<span class="string">"item"</span>, <span class="keyword">new</span> Article().getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(newsMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图片消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> imageMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月9日 上午9:25:51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">imageMessageToXml</span><span class="params">(ImageMessage imageMessage)</span> </span>&#123;</span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, imageMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(imageMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象到xml的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> XppDriver() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HierarchicalStreamWriter <span class="title">createWriter</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">                <span class="comment">// 对所有xml节点的转换都增加CDATA标记</span></span><br><span class="line">                <span class="keyword">boolean</span> cdata = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startNode</span><span class="params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.startNode(name, clazz);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeText</span><span class="params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cdata) &#123;</span><br><span class="line">                        writer.write(<span class="string">"&lt;![CDATA["</span>);</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                        writer.write(<span class="string">"]]&gt;"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h4><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复<code>文本</code>、<code>图片</code>、<code>图文</code>、<code>语音</code>、<code>视频</code>、<code>音乐</code>）。</p>
<p>上一篇文章，已经创建了IndexController ，里面的GET方法用来验证token，下面直接加一个POST方法，用于进行消息管理。消息接收<code>POST</code>和微信认证<code>GET</code>是同一个接口（开发者填写的URL）</p>
<p><strong>Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgProcess</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">// 调用核心业务类接收消息、处理消息</span></span><br><span class="line">    String respMessage = msgService.processRequest(request);</span><br><span class="line">    <span class="comment">// 响应消息</span></span><br><span class="line">    PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        out.print(respMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        out = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MsgService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String respMessage = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            String fromUserName = requestMap.get(<span class="string">"FromUserName"</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            String toUserName = requestMap.get(<span class="string">"ToUserName"</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            String msgType = requestMap.get(<span class="string">"MsgType"</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String content = requestMap.get(<span class="string">"Content"</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"FromUserName is:"</span> + fromUserName + <span class="string">", ToUserName is:"</span> + toUserName + <span class="string">", MsgType is:"</span> + msgType);</span><br><span class="line">            <span class="comment">// 文本消息</span></span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123;</span><br><span class="line">                <span class="comment">//这里根据关键字执行相应的逻辑，只有你想不到的，没有做不到的</span></span><br><span class="line">                <span class="keyword">if</span> (content.indexOf(<span class="string">"天气"</span>)!=-<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    NewsMessage newmsg = <span class="keyword">new</span> NewsMessage();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">                    article.setTitle(<span class="string">"天气预报"</span>);</span><br><span class="line">                    article.setDescription(<span class="string">"点击了解未来天气详情..."</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">"https://lwy-image.oss-cn-beijing.aliyuncs.com/ep.png"</span>);</span><br><span class="line">                    article.setUrl(<span class="string">"https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=auto&amp;key=f1688db9422246fc969a6ba559075097"</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"error......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试    <img data-src="../../../../assets/img/06215027.jpg" alt></p>
<blockquote>
<p>源码参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pob3VtaW5wei93ZWNoYXRQdWJsaWNBY2NvdW50LQ==">https://github.com/zhouminpz/wechatPublicAccount-<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/computernetwork/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#1-TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="1.TCP 为什么握手是 3 次、挥手是 4 次？"></a>1.TCP 为什么握手是 3 次、挥手是 4 次？</h3><ul>
<li>如果一个Host主动向另一个Host发起连接，称为SYN，请求同步；</li>
<li>如果一个Host主动断开请求，称为FIN，请求完成；</li>
<li>如果一个Host给另一个Host发送数据，称为PSH，数据推送。</li>
</ul>
<a id="more"></a>

<img data-src="../assets/img/image-20210620162355901.png" alt="image-20210620162355901" style="zoom:67%;">

<img data-src="../assets/img/image-20210620162420844.png" alt="image-20210620162420844" style="zoom:67%;">

<p>TCP是一个双工协议，建立连接的时候，连接双方都需要向对方发送SYN和ACK。握手阶段没有繁琐的工作，因此一方向另一方发起同步(SYN)之后，另一方可以将自己的ACK和SYN打包作为一条消息回复，因此是3次握手。</p>
<p>挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应(ACK)，表示收到了挥手请求。最后等所有工作结束，再发送请求中断连接(FIN)，因此是4次挥手。</p>
<h3 id="2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"><a href="#2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？" class="headerlink" title="2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"></a>2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？</h3><p>TCP拆包：将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程中需要保证数据经过网络传输，又能恢复到原始的顺序。TCP利用发送字节数(Sequence Number)和接收字节数(Acknowledgement Number)的唯一性来确定封包之间的顺序关系(无论是Seq还是ACK，都是针对对方而言的。是对方发送的数据和对方接受的数据)。粘包是为了防止数据量过小，导致大量的传输，而将多个TCP段合并成一个发送。</p>
<p><img data-src="../assets/img/image-20210620150902311.png" alt></p>
<h3 id="3-滑动窗口和流速控制"><a href="#3-滑动窗口和流速控制" class="headerlink" title="3.滑动窗口和流速控制"></a>3.滑动窗口和流速控制</h3><p>深绿色：已经收到了ACK的段    浅绿色：发送了，但是没有收到ACK的段    白色：没有发送的段    紫色：暂时不能发送的段。</p>
<ol>
<li><p>有两个封包到达，标记为绿色。</p>
<p><img data-src="../assets/img/image-20210620161423153.png" alt></p>
</li>
<li><p>滑动窗口可以向右滑动</p>
<p><img data-src="../assets/img/image-20210620161910667.png" alt></p>
</li>
</ol>
<p><strong>重传</strong></p>
<ol>
<li><p>如果部分数据没能收到ACK，如段4迟迟没有收到ACK。</p>
<p><img data-src="../assets/img/image-20210620162206747.png" alt></p>
</li>
<li><p>此时滑动窗口只能右移一个位置</p>
<p><img data-src="../assets/img/image-20210620162314291.png" alt></p>
<p>如果段4重传成功(接收到ACK)，那么窗口就会继续右移。如果段4发送失败，还是没能收到ACK，那么接收方也会抛弃段5、6、7。这样从段4开始之后的数据都需要重发。</p>
</li>
</ol>
<p><strong>快速重传</strong></p>
<p>例如段1、2、4到了，但是3没到。接收方可以发送多次3的ACK(不发段4的ACK)。如果发送方收到多个3的ACK，就会重发段3。这和超时重发不同，是一种催促机制，接收方希望催促发送方尽快补全某个TCP段。</p>
<p>实际操作中，每个TCP段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中滑动窗口的大小单位是字节数。</p>
<p><strong>总结</strong></p>
<p>滑动窗口是TCP协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出的顺序，但是窗口中的分组会一次性发送。窗口中序号最大的分组如果收到ACK，窗口就会发生滑动；如果有分组为收到ACK，则会滑动到该窗口。</p>
<p>在多次传输中，网络的平均延迟往往是相对固定的，这样TCP协议可以通过<strong>发送方和接收方协商窗口大小控制流速</strong>。</p>
<h3 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h3><p><strong>UDP</strong></p>
<p>UDP，目标是在传输层提供直接发送报文的能力。Datagram是数据传输的最小单位，UDP协议不会帮助拆分数据，它的目标只有一个，就是能发送报文。</p>
<p>UDP的可靠性仅仅就是通过Checksum保证。如果一个数据封包Datagram发生了数据损坏，UDP可以通过Checksum纠错或者修复。</p>
<p><strong>UDP与TCP的区别</strong></p>
<ol>
<li><p>目的差异</p>
<p>TCP：提供可靠的网络传输。</p>
<p>UDP：提供报文交换能力基础上尽可能的简化协议。</p>
</li>
<li><p>可靠性差异</p>
<p>TCP：可靠，收到的数据会进行排序。</p>
<p>UDP：不可靠，只管发送数据包。</p>
</li>
<li><p>连接vs无连接</p>
<p>TCP：面向连接，会有握手的过程，传输数据必须先建立连接。</p>
<p>UDP：无连接协议，数据随时都可以发送，只提供发送封包的能力。</p>
</li>
<li><p>流控技术</p>
<p>TCP在发送缓冲区中存储数据，并在接收缓冲区中接收数据，如果接收缓冲区已满，接收方无法处理更多数据，并将其丢弃。UDP没有提供类似的能力。</p>
</li>
<li><p>传输速度</p>
<p>UDP协议简化，封包小，没有连接、可靠性检查等，因此单纯从速度上讲，UDP更快。</p>
</li>
<li><p>理论上，任何一个用TCP协议构造的成熟应用层协议，都可以UDP重构。想要把网络优化到极致，就会用UDP作为底层技术，然后在UDP基础上解决可靠性。</p>
<p>TCP场景：</p>
<ul>
<li>远程控制(SSH)</li>
<li>File Transfer Protocol(FTP)</li>
<li>邮件(SMTP、IMAP等)</li>
<li>点对点文件传输(微信等)</li>
</ul>
<p>UDP场景</p>
<ul>
<li>网络游戏</li>
<li>音视频传输</li>
<li>DNS</li>
<li>ping</li>
<li>直播</li>
</ul>
<p>模糊地带</p>
<ul>
<li>HTTP(目前以TCP为主)</li>
<li>文件传输</li>
</ul>
</li>
</ol>
<p>TCP最核心的价值就是提供封装好的一套解决可靠性的优秀方案。UDP最核心的价值是灵活、轻量、传输速度快。场景不同选择不同。</p>
<h3 id="5-IPv4"><a href="#5-IPv4" class="headerlink" title="5.IPv4"></a>5.IPv4</h3><p>IP协议自身不能不能保证可靠性(数据无损的到达目的地)。</p>
<p>IP协议接收IP协议上方的Host-To-Host协议传来的数据，然后进行拆分，这个能力叫做分片。然后IP协议为每个片段增加一个IP头，组成一个IP封包。之后，IP协议调用底层的局域网(数据链路层)传送数据。最后IP协议通过寻址和路由最终将封包送达目的地。</p>
<p>延迟：指1bit数据从网络的一个终端传送到另一个终端需要的时间。<br>吞吐量：单位时间内可以传输的平均数据量。如bit/s(bps)。<br>丢包率：指发出去的封包没有到达目的地的比例。</p>
<p><strong>IPv4地址</strong><br>4个8喂排列而成，总共可以编址43亿个地址。<br>如103.16.3.1</p>
<p><img data-src="../assets/img/23223038.png" alt></p>
<p><strong>寻址与路由的区别</strong></p>
<p>寻址就是通过地址找设备，比如根据地址找到一个公寓。在 IPv4 协议中，寻址找到的是一个设备所在的位置。路由的本质是路径的选择，就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</p>
<p>所以，要做路由，就必须理解地址，也就是借助寻址的能力。找到最终的设备又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址相辅相成。</p>
<h3 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h3><p><strong>相似点</strong></p>
<p>工作原理与IPv4类似，分成切片、增加封包头、路由(寻址)几个阶段。</p>
<p><strong>不同点</strong></p>
<ul>
<li><p>IPv6地址</p>
<p>IPv4的地址是4个8位，总共32位，如103.28.7.35，每一个是8位，用0-255的数字表示；IPv6的地址是8个16位，总共128位，如0123:4567:89ab:cdef:0123:4567:89ab:cdef，通常用16进制表示。</p>
</li>
<li><p>IPv6的寻址</p>
<ul>
<li><p>全局单播</p>
<p>将消息从一个设备传到另一个设备，和IPv4的发送/接收数据大同小异。IPv6地址太多，因此不需要子网掩码，而是直接将IPv6的地址分区即可。</p>
</li>
<li><p>本地单播</p>
<p>在局域网中，实现设备到设备的通信。本地单播必须以fe80开头，类似IPv4中以127开头。</p>
</li>
<li><p>分组多播</p>
<p>将消息发送给多个接收者。</p>
</li>
<li><p>任意播</p>
<p>将消息发送给多个接收方，并选择一条最优的路径。</p>
</li>
</ul>
</li>
</ul>
<p><strong>IPv6和IPv4的兼容</strong></p>
<ul>
<li><p>一个IPv6的客户端想访问IPv4的服务器</p>
<p><img data-src="../assets/img/gfgfdg225213.png" alt></p>
<ol>
<li>客户端通过DNS64服务器查询AAAA记录。(DNS64：一种解决IPv4和IPv6兼容问题的DNS服务，会把IPv4和IPv6地址同时返回)</li>
<li>DNS64服务器返回含IPv4地址的AAAA记录。</li>
<li>客户端将对应的IPv4地址请求发送给一个NAT64路由器。</li>
<li>NAT64路由器将IPv6地址转换为IPv4地址，从而访问IPv4网络，并收集结果。</li>
<li>消息返回客户端。</li>
</ol>
</li>
<li><p>两个IPv6网络被IPv4隔离</p>
<p><img data-src="../assets/img/iij225838.png" alt></p>
<p>隧道的本质就是在两个IPv6的网络出口网关处，实现一段地址转换的程序。</p>
</li>
</ul>
<p><strong>Tunnel是什么？</strong></p>
<p>Tunnel就是隧道，两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个IPv6网络被IPv4分隔开，那么两个IPv6网络的出口处(和IPv4的网关处)就可以用程序(或硬件)实现一个隧道，方便两个网络中设备的通信。</p>
<h3 id="7-BIO、NIO和AIO有什么区别？"><a href="#7-BIO、NIO和AIO有什么区别？" class="headerlink" title="7.BIO、NIO和AIO有什么区别？"></a>7.BIO、NIO和AIO有什么区别？</h3><p>BIO接口设计会直接导致当前线程阻塞。NIO的设计不会触发当前线程的阻塞。AIO为I/O提供了异步的能力，也就是将I/o的响应程序放到一个独立的时间线上去执行。但是通常AIO的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且将异步计算同步回主线的能力。</p>
<p>通常情况下，这3种API都会伴随I/O多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将I/O消息发送给指定的线程。另外，还可以使用DMA、内存映射等方式优化I/O。</p>
<h3 id="8-怎样实现RPC框架？"><a href="#8-怎样实现RPC框架？" class="headerlink" title="8.怎样实现RPC框架？"></a>8.怎样实现RPC框架？</h3><ol>
<li><p>调用约定和命名</p>
<p>远程调用一个函数，命名空间+类名+方法名    IP、端口</p>
</li>
<li><p>注册和发现</p>
<p>调用的时候，需要根据字符串(命名)去获取IP和端口(机器和服务)</p>
<ul>
<li><p>Redis hash</p>
<p>注册：上线一个服务时，用Redis的hash对象存储它和它对应的IP地址+端口列表。</p>
<p>发现：根据RPC服务的名称(命名空间+类名+方法名)查找到提供服务的IP + 端口清单并指定某个 IP + 端口(提供服务)</p>
<p>不足：所有RPC调用着都去Redis查询，压力较大，增加缓存，缓存和注册表之间数据不一致。</p>
</li>
<li><p>Zookeeper提供订阅，让RPC调用者订阅到服务地址的变更，及时更新自己的缓存。</p>
</li>
</ul>
</li>
<li><p>多路复用</p>
<p>提升吞吐量：1.顺序传输  2.切片传输。</p>
</li>
<li><p>负载均衡</p>
<p>负载均衡可以看作发现模块的一个子组件，请求到达RPC的网关(或某个路由程序)后，发现组件会提供服务对应的所有实例(IP+端口)，然后负载均衡算法会指定其中一个响应请求。</p>
</li>
<li><p>可用性和容灾</p>
<ul>
<li>当一个服务实例崩溃的时候，发现模块及时从注册表中删除这个服务实例。</li>
<li>注册表和RPC调用者之间存在不一致现象，而且注册表的更新本身也可能滞后。如确认一个服务有没有崩溃，可能需要一个心跳程序持续请求这个服务，调用到一个不存在或崩溃的服务，需要自己重新发现组件申请新的服务实例(地址+端口)。</li>
<li>临时访问量剧增，需要扩容的场景，上线更多的容器，并且去注册。</li>
</ul>
</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？"><a href="#1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？" class="headerlink" title="1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？"></a>1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？</h4><p>TCP连接上限受限于机器的内存，假设一个TCP连接需要占用的最小内存是8k(发送、接收缓存各4k，当然还要考虑socket描述符等)，那么最大连接数为：8 * 1024 * 1024 / 8 = 1048576个，即约为100w个TCP长连接。<br>但是如果单机建立太多的连接，会报<code>Cant assign requested address</code>的异常，这是因为客户端连接服务端时，操作系统要为每个客户端分配一个端口号，端口号会更快用尽。</p>
<h4 id="2-127-0-0-1，localhost，0-0-0-0-有什么不同？"><a href="#2-127-0-0-1，localhost，0-0-0-0-有什么不同？" class="headerlink" title="2.127.0.0.1，localhost，0.0.0.0 有什么不同？"></a>2.127.0.0.1，localhost，0.0.0.0 有什么不同？</h4><p>127.0.0.1：本地回环地址，发送到loopback上的数据会被转发到本地应用。</p>
<p>localhost：指代本地计算机，用于访问绑定在loopback上的服务。localhost是一个主机名，不仅可以指向IPv4的本地回环地址，也可以指向IPv6的本地回环地址[::1]。</p>
<p>0.0.0.0：一个特殊的目的IP地址，称作不可路由IP地址，它的用途会被特殊规定。通常情况下，当把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的IP地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到0.0.0.0就可以保证服务在多个IP地址上都可以用。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发(五)部署项目到阿里云服务器</title>
    <url>/deployment/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul>
<li>可以正常运行提供服务的项目</li>
<li>一台云服务器</li>
</ul>
<h3 id="2-项目打包"><a href="#2-项目打包" class="headerlink" title="2.项目打包"></a>2.项目打包</h3><p>首先将我们在IDEA下的项目进行打包，这边基于的是maven项目的打包。<br>点击菜单栏 File → Project Structure → Artifacts 添加一个jar</p>
<a id="more"></a>
<p><img data-src="../../../../assets/img/212549.jpg" alt></p>
<p>之后，对添加的jar进行配置<br><img data-src="../../../../assets/img/212555.jpg" alt></p>
<p>点击右侧竖排菜单栏的maven project 然后点开Lifecycle，先clean再package，注意在打包之前，要将项目的启动端口号改为80，8080端口是本机端口，不适用于服务器。</p>
<p><img data-src="../../../../assets/img/213308.jpg" alt></p>
<p>当下方控制器显示BUILD SUCCESS时说明打包成功<br><img data-src="../../../../assets/img/213558.jpg" alt></p>
<p>这时候我们可以在项目的文件目录下看到多了个target目录，点开目录移动到最下方我们可以看到项目jar包,我们可以从电脑磁盘中将放置该项目的文件夹打开并找到该项目文件。<br><img data-src="../../../../assets/img/213739.jpg" alt><br><img data-src="../../../../assets/img/213759.jpg" alt></p>
<h3 id="3-导入服务器"><a href="#3-导入服务器" class="headerlink" title="3.导入服务器"></a>3.导入服务器</h3><p>使用FTP工具负责构建完成的项目jar包到云服务器<br><img data-src="../../../../assets/img/214254.jpg" alt></p>
<h3 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h3><h4 id="4-1-配置Java运行环境"><a href="#4-1-配置Java运行环境" class="headerlink" title="4.1 配置Java运行环境"></a>4.1 配置Java运行环境</h4><ol>
<li><p>查看yum库中的Java安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y list java*</span><br></pre></td></tr></table></figure>

<p>以yum库中java-1.8.0为例, “*”表示将java-1.8.0的所有相关Java程序都安装上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查是否安装成功<br>输入  <code>java -version</code>  <code>javac</code><br><img data-src="../../../../assets/img/214925.jpg" alt></p>
</li>
</ol>
<h4 id="4-2-启动项目"><a href="#4-2-启动项目" class="headerlink" title="4.2 启动项目"></a>4.2 启动项目</h4><p>查询一下80端口是否已开放，开放了80端口后我们就可以启动我们的项目了，通过输入指令：<br>Java -jar [jar包的完整文件名(.jar别忘了加)] 如下图所示。这样我们的项目就开始启动了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar WeChat-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/214926.jpg" alt></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
        <tag>Spring Boot</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发(四)处理语音消息</title>
    <url>/35386/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-语音识别接口"><a href="#1-语音识别接口" class="headerlink" title="1.语音识别接口"></a>1.语音识别接口</h3><p>为了实现微信公众号与用户的多样化交互, 本章进行处理用户语音消息的开发.</p>
<p>开发者进入微信公众平台 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span> —接口权限—对话服务—接受消息—打开接收语音识别结果接口权限</p>
<a id="more"></a>

<p><img data-src="../../../../assets/img/162311.jpg" alt></p>
<p><img data-src="../../../../assets/img/162403.jpg" alt></p>
<h3 id="2-获取语音识别结果"><a href="#2-获取语音识别结果" class="headerlink" title="2.获取语音识别结果"></a>2.获取语音识别结果</h3><p>请注意，开通语音识别后，用户每次发送语音给公众号时，微信会在推送的语音消息XML数据包中，增加一个<strong>Recognition</strong>字段（注：<code>由于客户端缓存，开发者开启或者关闭语音识别功能，对新关注者立刻生效，对已关注用户需要24小时生效。开发者可以重新关注此帐号进行测试</code>）。</p>
<p>开启语音识别后的语音XML数据包如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">toUser</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">fromUser</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1357290913<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">voice</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">media_id</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Format</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">Format</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">Format</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Recognition</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[腾讯微信团队] ]&gt;</span><span class="tag">&lt;/<span class="name">Recognition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>语音消息参数说明</strong></p>
<p><img data-src="../../../../assets/img/161521.jpg" alt></p>
<p>开通语音识别功能以后，用户每次发送语音给微信公众号，微信会在推送语音消息XML数据包中添加一个<code>Recongnition</code>字段，该字段为语音识别出的文本内容.</p>
<h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><p><strong>实体类VoiceMessage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiceMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Recognition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MessageUtil</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">voiceMessageToXml</span><span class="params">(VoiceMessage voiceMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="string">"xml"</span>, voiceMessage.getClass());</span><br><span class="line">    <span class="keyword">return</span> xstream.toXML(voiceMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MsgService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MsgService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String respMessage = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            String fromUserName = requestMap.get(<span class="string">"FromUserName"</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            String toUserName = requestMap.get(<span class="string">"ToUserName"</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            String msgType = requestMap.get(<span class="string">"MsgType"</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String content = requestMap.get(<span class="string">"Content"</span>);</span><br><span class="line"></span><br><span class="line">            String recognition = requestMap.get(<span class="string">"Recognition"</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"FromUserName is:"</span> + fromUserName + <span class="string">", ToUserName is:"</span> + toUserName + <span class="string">", MsgType is:"</span> + msgType);</span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_VOICE))&#123;</span><br><span class="line">                System.out.println(recognition);</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">"环境信息"</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    Map map = IoTPopApiUtil.IoTpop();</span><br><span class="line">                    Map ioTpop = JSON.parseObject(JSONObject.toJSONString(map), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    Object data = ioTpop.get(<span class="string">"data"</span>);</span><br><span class="line">                    String str = data.toString();</span><br><span class="line">                    <span class="keyword">int</span> index=str.indexOf(<span class="string">"["</span>);</span><br><span class="line">                    String result=str.substring(index);</span><br><span class="line">                    String jsonStr = result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>);</span><br><span class="line">                    JSONArray array = JSONArray.parseArray(jsonStr);</span><br><span class="line">                    List&lt;Pi&gt; pi = JSONObject.parseArray(array.toJSONString(),Pi<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String returnText=<span class="string">"当前温度:"</span>+pi.get(<span class="number">3</span>).getValue()+<span class="string">"°C"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前湿度:"</span>+pi.get(<span class="number">2</span>).getValue()+<span class="string">"%"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前光照强度:"</span>+pi.get(<span class="number">4</span>).getValue()+<span class="string">"Lux"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前气压:"</span>+pi.get(<span class="number">1</span>).getValue()+<span class="string">"hPa"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前海拔:"</span>+pi.get(<span class="number">0</span>).getValue()+<span class="string">"m"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"降雨情况:"</span>+(pi.get(<span class="number">5</span>).getValue()==<span class="number">1</span>?<span class="string">"降雨"</span>:<span class="string">"未降雨"</span>);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    TextMessage text = <span class="keyword">new</span> TextMessage();</span><br><span class="line">                    text.setContent(returnText);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">"天气"</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    NewsMessage newmsg = <span class="keyword">new</span> NewsMessage();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">                    article.setTitle(<span class="string">"天气预报"</span>);</span><br><span class="line">                    article.setDescription(<span class="string">"点击了解未来天气详情..."</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">"https://xxxx.oss-cn-beijing.aliyuncs.com/ep.png"</span>);</span><br><span class="line">                    article.setUrl(<span class="string">"https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=accu&amp;key=4bdfe35a67bb4b53bee844f6ce7a4b5c"</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"error......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p><img data-src="../../../../assets/img/163205.jpg" alt></p>
<p><img data-src="../../../../assets/img/163500.jpg" alt></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络与网络编程</title>
    <url>/65346/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1.软件结构"></a>1.软件结构</h3><h4 id="1-1-C-S结构"><a href="#1-1-C-S结构" class="headerlink" title="1.1 C/S结构"></a>1.1 C/S结构</h4><p>全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。<br><img data-src="../../../../assets/img/1_cs.jpg" alt></p>
<h4 id="1-2-B-S结构"><a href="#1-2-B-S结构" class="headerlink" title="1.2 B/S结构"></a>1.2 B/S结构</h4><p>全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<a id="more"></a>
<p><img data-src="../../../../assets/img/2_bs.jpg" alt><br>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h3 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2.网络通信协议"></a>2.网络通信协议</h3><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<br><img data-src="../../../../assets/img/3_tcp_ip.jpg" alt><br>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
<li><strong>OSI七层模型:</strong><br>  应用层    负责对软件提供接口时程序能使用网络服务<br>  表示层    应用程序和网络之间的翻译官<br>  会话层    负责在网络中的两节点之间建立和维持通信<br>  传输层    建立端到端之间的连接，数据的分段和重组<br>  网络层    将网络地址翻译成对应的mac地址，指导数据包的转发<br>  数据链路层    将网络层接收到的数据包封装为特定的数据帧，使其在不可靠的物理链路上进行可靠的数据传递<br>  物理层    建立、维护、断开物理连接。（由底层网络定义协议）</li>
</ul>
<h3 id="3-UDP与TCP协议"><a href="#3-UDP与TCP协议" class="headerlink" title="3.UDP与TCP协议"></a>3.UDP与TCP协议</h3><h4 id="3-1-UDP协议"><a href="#3-1-UDP协议" class="headerlink" title="3.1 UDP协议"></a>3.1 UDP协议</h4><p>​    UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。<br><img data-src="../../../../assets/img/106209.png" alt></p>
<h4 id="3-2-TCP协议"><a href="#3-2-TCP协议" class="headerlink" title="3.2 TCP协议"></a>3.2 TCP协议</h4><p>​    TCP协议是<strong>面向连接</strong>的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认 </li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 </li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示<br><img data-src="../../../../assets/img/403168.png" alt><br>由于TCP协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。</li>
</ul>
<h3 id="4-相关面试题"><a href="#4-相关面试题" class="headerlink" title="4.相关面试题"></a>4.相关面试题</h3><ol>
<li>TCP断开连接的四次挥手<br>第一次挥手：客户端发送一个FIN包（seq=x），进入FIN_WAIT（结束等待）状态<br>第二次挥手：服务器收到FIN包，发回一个ACK包(ack=x+1)，进入CLOSE_WAIT（关闭等待）状态<br>第三次挥手：服务器关闭客户端的连接，并发送一个FIN包(seq=y)，进入LAST_ACK（最后确认）状态<br>第四次挥手：客户端发回ACK(ack=y+1)包确认，发送完毕后，连接断开<br><img data-src="../../../../assets/img/70830403.png" alt></li>
<li>需要三次握手的原因<br><strong>为了防止失效的连接请求报文突然又传送到服务器产生错误</strong>。假如不三次握手，客户端发送连接确认给服务端就立即建立连接，如果有个连接请求阻塞了很久才到服务端，而此时本来已经关闭了连接的又重新建立了连接，然而等了很久都没有数据发送，这就会白白浪费资源</li>
<li>Http协议与Https协议</li>
</ol>
<ul>
<li>Http协议即<strong>超文本传输协议</strong>，是一种<strong>基于TCP的应用层协议</strong>，还是一种<strong>无状态协议</strong>。用于服务器和客户端的<strong>数据传输</strong>，客户端和服务器使用<strong>URL</strong>来建立连接和传输数据。客户端发送Http请求给服务器，服务器根据请求返回Html、文本或多媒体文件给客户端</li>
<li>Https协议是一种安全的Http协议。Http协议是一种明文传输的协议，存在被窃听，信息篡改等安全隐患，在Http协议的基础上加入了SSL或TLS协议，实现了数据的加密传输。因为加上了加密的协议，所以Https的响应速度会比Http慢很多。并不是所有情况下都需要使用Https协议，对于隐私的，重要的信息最好用Https协议，不重要的或者可以公开的信息就没有必要用Https协议</li>
</ul>
<ol start="4">
<li>Http请求报文和响应报文</li>
</ol>
<ul>
<li>请求报文包括请求行，请求头，空行和请求体（GET请求没有请求体）</li>
<li>响应报文包括状态行，响应头，空行和响应体</li>
</ul>
<ol start="5">
<li>Http请求常见状态码</li>
</ol>
<ul>
<li>200 OK，请求成功</li>
<li>404 Not Found，对应的URL上不存在资源</li>
<li>405 Method Not Allowed，请求不被允许，即请求方式错误</li>
<li>500 Internal Server Error，服务器内部错误，发现严重BUG，要及时修复</li>
</ul>
<ol start="6">
<li>GET请求与POST请求的区别</li>
</ol>
<ul>
<li>GET请求一般用于<strong>获取</strong>服务器上的资源，是<strong>幂等</strong>的。POST请求一般用于对服务器上资源进行<strong>更新</strong>，<strong>非幂等</strong>的（幂等即每次请求返回结果一样）</li>
<li>GET请求没有请求体，<strong>请求参数跟是在URL后面</strong>的，所以使用GET请求时请求参数用户是可以直接看到的。POST请求有请求体，<strong>请求参数放在请求体</strong>，对用户是不可见的。相对来说POST请求比GET请求更安全</li>
<li>GET请求的参数<strong>长度有限制</strong>，这是因为URL长度有限导致的。POST请求的参数长度可以认为是<strong>无限制</strong>的</li>
</ul>
<ol start="7">
<li>TCP 和 UDP的区别</li>
</ol>
<ul>
<li>TCP是一种<strong>面向连接的可靠</strong>传输协议，UDP是<strong>面向无连接的不可靠</strong>传输协议</li>
<li>TCP支持报文传输，还支持<strong>字节流</strong>的传输。而UDP协议只支持传输报文</li>
<li>TCP<strong>数据报格式比较复杂</strong>，传输过程数据不容易丢失和出错，而UDP<strong>数据报格式较为简单</strong>，容易丢失</li>
<li>TCP传输在接收端会进行重排，所以是<strong>有序</strong>的，UDP则<strong>不保证有序</strong></li>
<li>TCP<strong>速度慢</strong>，UDP<strong>速度快</strong></li>
<li>TCP有<strong>流量控制和拥塞控制</strong>，而UDP没有</li>
</ul>
<ol start="8">
<li>应用层协议有哪些</li>
</ol>
<ul>
<li>DNS协议，域名解析系统。基于TCP和UDP的协议，通过DNS可以将域名转换成IP地址</li>
<li>SMTP协议，电子邮件协议。基于TCP的协议，通过SMTP协议可以发送电子邮件，SMTP通信的过程建立连接、邮件传送、连接释放</li>
<li>Telnet协议，远程终端协议。基于TCP的协议，通过Telnet协议可以对远程的终端进行控制</li>
<li>Http协议，超文本传输协议。基于TCP的协议，通过Http协议实现客户端和服务端的数据传输</li>
<li>FTP协议，文件传输协议。基于TCP的协议，通过FTP协议达到相互传输文件的效果</li>
</ul>
<ol start="9">
<li>OSI参考模型与TCP/IP参考模型<br>(1) OSI参考模型由7层组成：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>(2) TCP/IP参考模型由4层组成：主机-网络层、网际层、传输层、应用层<br>(3) 对应关系中，OSI参考模型的物理层、数据链路层对应TCP/IP的主机-网络层，网络层对应网际层，传输层对应传输层，会话层、表示层、应用层对应应用层</li>
<li>cookie 和 session的区别<br>(1) cookie由于把信息保存在客户端中。session把信息保存在服务器中<br>(2) cookie性能更高一点，速度较快，用户的信息存在各自的浏览器中，可以分担服务器的一部分存储工作。session速度较慢，所有用户的信息都存在服务器中，在高并发时必然影响服务器性能<br>(3) cookie有限制大小，在4K以内。session没有限制<br>(4) cookie对用户是透明的，安全性低，不重要的或者可以公开的信息保存在cookie。session对用户是不可见的，安全性高，重要信息应该保存在session</li>
<li>forward 和 redirect的区别<br>(1) forward为转发，进行forward操作后，请求URL不发生变化，并且会把请求的数据携带到下一个请求中。redirect是重定向，进行redirect操作后，请求URL是发生变化的<br>(2) forward是服务器内部请求转发，不可以请求到其它站点，redirect是服务器通知客户端重新请求，可以请求到其它站点<br>(3) forward速度快，redirect速度慢</li>
<li>DNS劫持和DNS污染<br>(1) DNS劫持：指用户访问一个域名时，DNS服务器故意将此地址指向一个错误的IP地址的行为。比如进入一个网站显示的却是另外一个网站的内容<br>(2) DNS污染：指用户访问一个域名时，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如国内不能访问Google、YouTube等</li>
</ol>
<h3 id="5-TCP通信程序"><a href="#5-TCP通信程序" class="headerlink" title="5.TCP通信程序"></a>5.TCP通信程序</h3><h4 id="5-1-简单的TCP网络程序"><a href="#5-1-简单的TCP网络程序" class="headerlink" title="5.1 简单的TCP网络程序"></a>5.1 简单的TCP网络程序</h4><p><strong>TCP通信分析图解</strong></p>
<ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。<blockquote>
<p>到此，客户端向服务端发送数据成功。<br><img data-src="../../../../assets/img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" alt><br>自此，服务端向客户端回写数据。</p>
</blockquote>
</li>
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-文件上传"><a href="#5-2-文件上传" class="headerlink" title="5.2 文件上传"></a>5.2 文件上传</h4><p><strong>文件上传分析图解</strong></p>
<ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。<br><img data-src="../../../../assets/img/6_upload2.jpg" alt></li>
</ol>
<p><strong>服务端实现:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/ThreadPool/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p><img data-src="../../../../assets/img/11183270.jpg" alt></p>
<a id="more"></a>
<p><strong>原理：</strong><br>当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。<br><strong>优点：</strong></p>
<ol>
<li>降低资源消耗；</li>
<li>提高响应速度；</li>
<li>提高线程的可管理性。</li>
</ol>
<p><strong>缺点：</strong>TODO<br><img data-src="../../../../assets/img/184834.jpg" alt></p>
<h5 id="1-1-四种常用ExecutorService特性"><a href="#1-1-四种常用ExecutorService特性" class="headerlink" title="1.1 四种常用ExecutorService特性"></a>1.1 四种常用ExecutorService特性</h5><table>
<thead>
<tr>
<th>类型</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>KeepAlive时间(存活时间)</th>
<th align="center">任务队列</th>
<th>拒绝策略</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool(可缓存线程池)</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>60s</td>
<td align="center">SynchronousQueue</td>
<td>线程池无限大，当执行第二个任务已经完成，会复用执行第一个任务的线程。</td>
</tr>
<tr>
<td>newFixedThreadPool(定长线程池)</td>
<td>指定大小</td>
<td>指定大小(与核心线程数相同)</td>
<td>0</td>
<td align="center">LinkedBlockingQueue</td>
<td>线程池大小固定，没有可用的线程的时候，任务会放在队列等待，队列的长度无限制。</td>
</tr>
<tr>
<td>newSingleThreadExexutor</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td align="center">LinkedBlockingQueue</td>
<td>单线程化的线程池，适用于业务逻辑上只允许1个线程进行处理的场景，保证所有任务按照指定顺序FIFO(先进先出)，LIFO(后进先出)，优先级执行。</td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td>指定大小</td>
<td>Integer.MAX_VALUE</td>
<td>0</td>
<td align="center">DelayedWordQueue</td>
<td>定长线程池，支持定时及周期性任务执行。</td>
</tr>
</tbody></table>
<h5 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h5><p>《阿里巴巴 Java 开发手册》中规定线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。线程池的好处是<strong>减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</strong>。如果不使用线程池，有可能<strong>造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</strong>。而且线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。这样的处理方式能够<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong><br><strong>corePoolSize：</strong>核心线程数，指定了线程池中的线程池数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中；</p>
<p><strong>maximumPoolSize：</strong>指定了线程池中的最大线程数量，这个参数会根据使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量。</p>
<p>核心和最大线程数大小仅在构建时设置，但也可以使用 <code>setCorePoolSize()</code> 和 <code>setMaximumPoolSize()</code> 进行动态更改。<br><strong>keepAliveTime：</strong>当线程池中的空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁。如果线程池在以后会变得更加活跃，则应构建线程或者使用<code>setKeepAliveTime(long, TimeUnit)</code>方法。</p>
<p><strong>unit：</strong>keepAliveTime的单位</p>
<p><strong>workQueue：</strong>阻塞队列(用来保存等待被执行的任务)</p>
<ol>
<li>ArrayBlockingQueue：基于数组结构的<strong>有界任务队列</strong>，按照FIFO排序任务。若有新的任务需要执行时，线程会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程数量达到maximumPoolSize，则执行拒绝策略。这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界任务队列的初始容量比较大或者没有达到超负荷状态，线程数将会一直维持在corePoolSize以下，反之，则会以maximumPoolSize为最大线程数上限。</li>
<li><strong>没有预定义容量</strong>的LinkedBlockingQueue：基于链表结构的<strong>无界任务队列</strong>，按照FIFO排序任务。使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，当线程数达到corePoolSize后就不会再增加了。使用无界任务队列将导致新任务在队列中等待，从而导致maximumPoolSize的值没有任何作用。当使用这种任务队列模式时，一定要注意任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。这种队列方式可以用于平滑瞬时大量请求。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于ArrayBlockingQueue。<strong>直接握手队列</strong>：它将任务交给线程而不需要保留，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此构建新的线程，如果达到maximumPoolSize设置的最大值，则根据设置的handler执行拒绝策略。在这种情况下，需要对程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量避免执行拒绝策略。应注意，当任务持续以平均提交速度大于平均处理速度时，会导致线程数量会无限增长问题。</li>
<li>PriorityBlockingQueue：具有优先级的无界任务队列。<strong>优先任务队列</strong>：特殊的无界任务队列，无论添加了多少个任务，线程数量都不会超过corePoolSize。其它队列一般是按照FIFO(先进先出)的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</li>
</ol>
<p><strong>threadFactory：</strong>线程工程，用于创建线程。如果未另行指定，则使用Executors.<strong>defaultThreadFactory</strong>默认工厂，使其全部位于同一个ThreadGroup中，并具有相同的NORM_PRIORITY优先级和非守护进程状态。通过不同的ThreadFactory可以更改线程的名称，线程组，优先级，守护进程状态等。privilegedThreadFactory：继承自defaultThreadFactory，主要添加了访问权限校验。</p>
<p><strong>handler：</strong>拒绝策略，创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但如果出现任务队列已满且线程池创建的线程数达到maximumPoolSize时，这时就需要指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p>
<ol>
<li>AbortPolicy：默认策略，丢掉任务直接抛出RejectedExecutionException异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy：如果线程池的线程池的线程数量达到上限，该策略会把拒绝的任务放在调用者线程当中运行，如果执行程序已关闭，则会丢弃该任务。</li>
<li>DiscardPolicy：该策略会默默丢弃无法处理的任务，不会抛出任何异常，使用此策略，业务场景中需允许任务的丢失。</li>
<li>DiscardOldestPolicy：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的。即每次移除队头元素后再尝试入队。</li>
</ol>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">16</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">testTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testTask testTask = <span class="keyword">new</span> testTask();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(testTask);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/mysql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1.基础篇"></a>1.基础篇</h3><h4 id="1-1-一条SQL查询语句是如何执行的？"><a href="#1-1-一条SQL查询语句是如何执行的？" class="headerlink" title="1.1 一条SQL查询语句是如何执行的？"></a>1.1 一条SQL查询语句是如何执行的？</h4><p><img data-src="../assets/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt></p>
<ul>
<li><p>Server层</p>
<p>连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。</p>
<a id="more"></a>
</li>
<li><p>存储引擎层</p>
<p>负责数据的存储和提取。支持InnoDB、MyISAM、Memory等多个存储引擎。MySQL5.5.5版本后默认使用InnoDB。</p>
</li>
</ul>
<ol>
<li><p>连接器</p>
<p>连接器负责与客户端建立连接、获取权限、维持和管理连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h&#123;ip&#125; -P&#123;port&#125; -u&#123;user&#125; -p</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一个用户成功建立连接后，即使使用管理员账户对该用户的权限做了修改，也不会影响已经存在的连接权限，只有新建的连接才会使用新的权限设置。</p>
</li>
<li><p>show processlist 可以查看各连接状态</p>
<p><img data-src="../assets/img/f2da4aa3a672d48ec05df97b9f992fed.png" alt></p>
<p>“Sleep”表示空闲连接，如果客户端太长时间没动静(wait_timeout，默认8小时)，连接器自动断开。</p>
</li>
<li><p>数据库长连接指连接成功后，客户端持续有请求，则一直使用同一个连接；短连接指每次执行完几次查询后就断开连接，下次查询再重新建立。MySQL在执行过程中临时使用的内存是管理在连接对象里的，如果长连接累积下来，会导致内存占用过大。</p>
<p>解决办法：</p>
<ul>
<li>定期断开长连接</li>
<li>MySQL5.7及以后，可以在每次执行一个比较大的操作后，执行mysql_reset_connection来将连接恢复到刚刚创建完的状态(不需要重连和权限验证)。</li>
</ul>
</li>
</ul>
</li>
<li><p>查询缓存</p>
<p>之前查询过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。但只要有对一个表的更新，那么这个表上的查询缓存就会被全部清除。MySQL8.0版本将查询缓存模块删除掉了。</p>
<ul>
<li><p>MySQL提供了”按需使用”的方式，将参数query_cache_type设置为DEMAND，这样对于默认的SQL不使用查询缓存。使用SQL_CACHE显式指定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select SQL_CACHE * from T <span class="built_in">where</span> ID=10；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分析器</p>
<p>如果没有命中查询缓存，就要开真正开始执行语句。</p>
<ol>
<li><p>词法分析</p>
<p>把”select”关键字识别出来，把字符串”T”识别为”表名T”，把字符串”ID”识别为”列ID”。</p>
</li>
<li><p>语法分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> elect * from t <span class="built_in">where</span> ID=1;</span></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>优化器</p>
<p>在表里有多个索引的时候，决定使用哪个索引；或者一个语句有多表关联(join)的时候，决定各个表的连接顺序。</p>
</li>
<li><p>执行器</p>
<p>开始执行语句，先判断对这个表T是否有权限(如果命中查询缓存，会在查询缓存返回结果时做权限校验)。如果有权限，就开始执行语句。</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集。</li>
<li>调用引擎接口取”下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>将结果集返回给客户端。</li>
</ol>
<p>对于有索引的表，第一次调用的是”满足条件的第一行”这个接口，之后循环取”满足条件的下一行”接口。</p>
</li>
</ol>
<h4 id="1-2-日志系统：一条SQL更新语句是如何执行的"><a href="#1-2-日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="1.2 日志系统：一条SQL更新语句是如何执行的"></a>1.2 日志系统：一条SQL更新语句是如何执行的</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(ID int primary key, c int);</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span></span><br></pre></td></tr></table></figure>

<p><strong>重要的日志模块：redo log</strong></p>
<p>WAL(Write-Ahead Logging)：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的。</p>
<p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB。从头开始写，写到末尾就又回到开头循环写。</p>
<p><img data-src="../assets/img/16a7950217b3f0f4ed02db5db59562a7.png" alt></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，这时不能再执行新的更新，得擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<p><strong>重要的日志模块：binlog</strong></p>
<p>MySQL整体看包括两块：一块是Server层，它主要做的是MySQL功能层面的事情；还一块是引擎层，负责存储相关的具体事宜。redo log是InnoDB(重做日志)引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)</p>
<p><strong>为什么会有两份日志？</strong></p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎MyIASM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是以插件形式引入MySQL的，使用另外一套日志系统-redo log来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同：</p>
<ol>
<li>redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是”在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p><strong>InnoDB引擎内部执行流程</strong></p>
<ol>
<li>执行器先找引擎取ID=2这一行。(ID是主键，引擎直接用树搜索到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。)</li>
<li>执行器拿到引擎给的行数据，把这个值加1，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成commit状态，更新完成。</li>
</ol>
<p>浅色表示在InnoDB内部进行，深色表示在执行器中执行。</p>
<p><img data-src="../assets/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt></p>
<h4 id="1-3-事务隔离"><a href="#1-3-事务隔离" class="headerlink" title="1.3 事务隔离"></a>1.3 事务隔离</h4><p>事务：保证一组数据库操作，要么全部成功，要么全部失败。</p>
<p>ACID(原子性、一致性、隔离性、持久性)</p>
<p>当数据库上有多个事务同时执行的时候，可能会出现脏读、不可重复读、幻读的问题。SQL标准的事务隔离级别包括：</p>
<ul>
<li>读未提交：一个事务还没提交，它做的变更就能被其他事务看到。</li>
<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化：对于同一行记录，”写”会加”写锁”，”读”会加”读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img data-src="../assets/img/7dea45932a6b722eb069d2264d0066f8.png" alt></p>
<ul>
<li>读未提交：V1 = 2，V2、V3 = 2</li>
<li>读提交：V1 = 1，V2 = 2，V3 = 2</li>
<li>可重复读：V1、V2 = 1，V3 = 2；之所以V2还是1，是因为：事务在执行期间看到的数据前后必须一致</li>
<li>串行化：在事务B执行”将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以V1、V2 = 1，V3 = 2</li>
</ul>
<p><strong>事务隔离的实现</strong></p>
<p>数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。”可重复读”，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；”读提交”，这个视图是在每个SQL语句开始执行的时候创建的。”读未提交”，直接返回记录上的最新值，没有视图概念；”串行化”，直接用加锁的方式来避免并发访问。</p>
<p>MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，都可以得到前一个状态。当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除。</p>
<p>长事务意味着系统里会存在很老的事务视图，这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致占用大量存储空间。</p>
<p><strong>事务的启动方式</strong></p>
<ol>
<li>显式启动事务语句，begin或start transaction。配套的语句是commit或者rollback。</li>
<li>set autocommit = 0，将这个线程的自动提交关掉。意味着如果执行一个select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到主动执行commit或者rollback，或者断开连接。</li>
</ol>
<h4 id="1-4-索引"><a href="#1-4-索引" class="headerlink" title="1.4 索引"></a>1.4 索引</h4><p><strong>索引的常见模型</strong></p>
<ul>
<li><p>哈希表</p>
<p>以键-值(key-value)存储数据的结构。多个key经过哈希函数换算，会出现同一个值的情况，此时会拉出一个链表。因为不是有序的，所以哈希索引做区间查询的速度很慢。适用于只有等值查询的场景。</p>
</li>
<li><p>有序数组</p>
<p>支持范围查询，但在插入数据和删除数据时必须挪动后面所有的记录，成本太高。适用于静态存储查询，这类不会再修改的数据。</p>
</li>
<li><p>二叉搜索树</p>
<p><img data-src="../assets/img/04fb9d24065635a6a637c25ba9ddde68.webp" alt></p>
<p>二叉搜索树的特点：父节点左子树所有节点小于父节点的值，右子树所有的节点大于父节点的值。</p>
<p>多叉树就是每个节点有多个儿子，儿子的大小保证从左到右递增。索引不止在内存中，还要写到磁盘上。为了尽可能少的读磁盘，就必须让查询过程访问尽量少的数据块。”N叉树”的”N”取决于数据块的大小。</p>
</li>
</ul>
<p><strong>InnoDB的索引模型</strong></p>
<p>每一个索引在InnoDB中对应一棵B+树。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(</span></span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p>
<p><img data-src="../assets/img/dcda101051f28502bd5c4402b292e38d.webp" alt></p>
<p>索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也称为聚簇索引。</p>
<p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p>
<p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>select * from T where ID = 500 即主键查询方式，则只需要搜索ID这棵B+树</li>
<li>select * from T where k = 5 即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表。</li>
</ul>
<p><strong>索引维护</strong></p>
<p>B+树为了维护索引有序性，在插入新值时需要做必要的维护。以上图为例，如果插入新的行ID值为700，则只需要在R5后面插入一个新记录。如果新插入的ID为400，需要逻辑上挪动后面的数据，空出位置。如果R5所在的数据页已满，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂，性能会下降。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。</p>
<p>自增主键：NOT NULL PRIMARY KEY AUTO_INCREMENT。每次插入一条新纪录，都是追加操作，都不涉及挪动记录，也不会触发叶子节点的分裂。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约２０个字节，而如果用整形做主键，则只需要４个字节。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p><strong>覆盖索引</strong></p>
<p><img data-src="../assets/img/ds224929.png" alt></p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。</p>
<p><strong>最左前缀原则</strong></p>
<p><img data-src="../assets/img/rrr225205.png" alt></p>
<p>索引项是按照索引定义里面出现的字段顺序排序的。当查询所有名字是”张三”的人时，可以快速定位到ID4，然后向后遍历。</p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>如果通过调整顺序，可以少维护一个索引，那么往往优先考虑这个顺序。</p>
<p><strong>索引下推</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值。</p>
<p>MySQL5.6之后引入索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的数据，减少回表次数。</p>
<p>无索引下推：回表4次</p>
<p><img data-src="../assets/img/625230314.png" alt></p>
<p>有索引下推：在(name，age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过，只需回表2次。</p>
<p><img data-src="../assets/img/156230553.png" alt></p>
<h4 id="1-5-全局锁和表锁"><a href="#1-5-全局锁和表锁" class="headerlink" title="1.5 全局锁和表锁"></a>1.5 全局锁和表锁</h4><p>数据库锁设计的初衷是处理并发问题。</p>
<p><strong>全局锁</strong></p>
<p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局锁的方法，命令是Flush tables with read lock(FTWRL)。当需要让整个库处于只读状态(不止DML，还包括DDL)时，可以使用该命令。使用场景是，<strong>全库逻辑备份</strong>的时候。</p>
<p>InnoDB引擎的库推荐使用一致性读(single-transcation)参数，对应用会更友好，全局锁一般在数据库引擎不支持事务时使用。</p>
<p>为什么不使用set global readonly=true？</p>
<ol>
<li>readonly的值会被用作其他逻辑，如判断主库备库。</li>
<li>异常处理机制有差别，执行FTWRL后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。readonly，如果客户端发生异常，则数据库就会一直保持readonly状态。</li>
</ol>
<p><strong>表级锁</strong></p>
<p>MySQL里面的表级别锁有两种：一种是表锁，一种是元数据锁(meta data lock，MDL)</p>
<ul>
<li><p>表锁</p>
<p>表锁的语法是lock tables..read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables不仅会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>某个线程A执行lock tables t1 read，t2 write；则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作，连写t1都不允许，自然也不能访问其他表。</p>
</li>
<li><p>元数据锁DML</p>
<p>不需要显示的使用，在访问一个表的时候会被自动加上，保证读写的正确性。</p>
<p>给一个表加字段，或者修改字段，或者加索引。需要扫描全表的数据。</p>
<p><strong>如何安全地给小表加字段？</strong></p>
<p>首先解决长事务的问题，事务不提交，就会一直占着MDL锁。在alter table语句里面设定等待时间，如果在这个指定的等待时间内未拿到MDL锁，则会放弃，不阻塞后面的业务。之后再通过重试命令重复这个过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-6-行锁"><a href="#1-6-行锁" class="headerlink" title="1.6 行锁"></a>1.6 行锁</h4><p>并不是所有的引擎都支持行锁，如MyISAM不支持行锁。行锁就是针对数据表中行记录的锁，比如事务A更新了一行，而这时事务B也要更新一行，则必须等事务A的操作完成后才能进行更新。</p>
<p><strong>两阶段锁</strong></p>
<p><img data-src="../assets/img/34234225501.png" alt></p>
<p>事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p><strong>在InnoDB事务中，行锁并不是不需要了就立刻释放，而是要等待事务结束时才能释放。</strong></p>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p><strong>死锁和死锁检测</strong></p>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源的时候，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p><img data-src="../assets/img/323230138.png" alt></p>
<ol>
<li>直接进入等待，直到超时。超时时间参数：innodb_lock_wait_timeout，默认50s</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其它事务得以继续执行。innodb_deadlock_detect：on，默认开启。</li>
</ol>
<p>正常情况下使用第二种策略，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，但如果遇到所有事务更新同一行的场景，每个新来的线程都需要判断会不会由于自己加入导致了死锁，会消耗大量的CPU资源。</p>
<p>如何解决热点行更新导致的性能问题？</p>
<ol>
<li>在确保该业务不会出现死锁的情况下，临时取消死锁检测。</li>
<li>控制并发度。(中间件、在MySQL里进入引擎之前排队)</li>
<li>将一行改成逻辑上的多行来减少锁冲突，如账户总额等于10个记录值的总和。</li>
</ol>
<h4 id="1-7-事务到底是隔离的还是不隔离的？"><a href="#1-7-事务到底是隔离的还是不隔离的？" class="headerlink" title="1.7 事务到底是隔离的还是不隔离的？"></a>1.7 事务到底是隔离的还是不隔离的？</h4><p>当前读：更新数据都是先读后写的，而这个读，只能读当前的值。</p>
<p>事务的可重复读的能力是怎么实现的？<br>可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读，如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>InnoDB的行数有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。<br>对于可重复读：查询只承认在事务启动前就已经提交完成的数据；<br>对于读提交：查询只承认在语句启动前就已经提交完成的数据；</p>
<p>为什么表结构不支持”可重复读”?<br>因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑</p>
<h3 id="2-实践篇"><a href="#2-实践篇" class="headerlink" title="2.实践篇"></a>2.实践篇</h3><h4 id="2-1-普通索引和唯一索引该如何选择？"><a href="#2-1-普通索引和唯一索引该如何选择？" class="headerlink" title="2.1 普通索引和唯一索引该如何选择？"></a>2.1 普通索引和唯一索引该如何选择？</h4><p><img data-src="../assets/img/css224736.png" alt></p>
<p><strong>查询</strong></p>
<p>select id from T where k=5</p>
<ul>
<li>普通索引：查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5的记录。</li>
<li>唯一索引：查找到第一个满足条件的记录后，就会停止检索。</li>
</ul>
<p>两者的性能差距：InnoDB的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录从磁盘读出来，而是以页为单位，将其整体读入内存，InnoDB中，每个数据页的大小默认是16KB。对于整形字段，一个数据页可以放近千个key，所以k=5这个记录刚好是数据页最后一个记录的几率会很低。</p>
<p><strong>更新过程</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在chang buffer中，在下次查询需要访问这个数据页的时候将数据页读入内存，然后执行change buffer中与这个页有关的参数。</p>
<p>虽然名字叫做change buffer，实际上它是可以持久化的数据，change buffer在内存中有拷贝，也会被写入磁盘中。</p>
<p>将change buffer中操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭(shutdown)的过程中，也会执行merge操作。</p>
<p>对于唯一索引，比如插入(4,400)这个记录，需要先判断表中是否存在k=4的记录，而这必须要将数据页读入到内存才能判断。如果已经读入内存了，直接更新内存即可，没必要再使用change buffer。因此，唯一索引的更新不能使用change buffer。</p>
<p>innodb_change_buffer_max_size: 50    表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>插入(4,400)：</p>
<ul>
<li>更新的目标页在内存中<ul>
<li>唯一索引：找到3和5之间的位置，判断没有冲突，插入值。</li>
<li>普通索引：找到3和5之间的位置，插入值。</li>
</ul>
</li>
<li>更新的目标页不在内存中<ul>
<li>唯一索引：将数据页读入内存，判断没有冲突，插入值。</li>
<li>普通索引：将更新记录在change buffer。</li>
</ul>
</li>
</ul>
<p><strong>change buffer的使用场景</strong><br>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多，收益越大。即适合于<strong>写多读少</strong>的场景。</p>
<p><strong>change buffer和redo log</strong><br>insert into t(id,k) values (id1,k1)(id2,k2);<br>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB<br>buffer pool) 中，k2 所在的数据页不在内存中。</p>
<ol>
<li>Page1在内存中，直接更新内存。</li>
<li>Page2不在内存中，将更新记录在change buffer。</li>
<li>将上述两个动作记录在redo log。</li>
</ol>
<p>select * from t where k in (k1, k2)</p>
<ol>
<li>读Page1时，直接从内存返回。</li>
<li>读Page2时，需要把Page2从磁盘读入内存，然后应用change buffer里的操作记录，生成一个正确的版本并返回结果。</li>
</ol>
<p>redo log主要节省的是随机写磁盘的IO消耗(转为顺序写)，而change buffer主要节省的是随机读磁盘的IO消耗。</p>
<h4 id="2-2-MySQL为什么有的时候会选错索引？"><a href="#2-2-MySQL为什么有的时候会选错索引？" class="headerlink" title="2.2 MySQL为什么有的时候会选错索引？"></a>2.2 MySQL为什么有的时候会选错索引？</h4><p><strong>优化器的逻辑</strong></p>
<p>扫描行数、是否使用临时表、是否排序等因素。</p>
<p>一个索引上不同的值越多(基数)，这个索引的区分度就越好。</p>
<p><strong>MySQL是怎样得到索引的基数的？</strong></p>
<p>采样统计：InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到这个索引的基数。而数据表是会持续更新的，索引统计信息也需要同步改变。所以，当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。</p>
<p>innodb_stats_persistent:<br>on：统计信息会持久存储，默认N是20，M是10。<br>off：统计信息只存储在内存中，默认N是8，M是16。</p>
<p>analyze table t：重新统计索引信息</p>
<p><strong>索引选择异常和处理</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b betwwen <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>采用force index强行选择一个索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改语句，引导MySQL使用期望的索引</p>
<p>“order by b limit 1”改成”order by b,a limit 1”，语义逻辑相同。之前优化器选择索引b，因为它认为使用索引b可以避免排序(b本身就是索引，不需要再次进行排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。”order by b,a”，意味着使用这两个索引都需要排序，因此，扫描行数成了影响索引选择的主要条件，于是，此时优化器选择了只需要扫描1000行的索引a。</p>
<p>但这种优化方法并不通用。</p>
</li>
<li><p>新建一个更合适的索引，来提供给优化器做选择，或者删除掉误用的索引</p>
</li>
</ol>
<h4 id="2-3-怎么给字符串字段加索引？"><a href="#2-3-怎么给字符串字段加索引？" class="headerlink" title="2.3 怎么给字符串字段加索引？"></a>2.3 怎么给字符串字段加索引？</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/fdfd222522.png" alt></p>
<p><img data-src="../assets/img/hgh222605.png" alt></p>
<p>由于email(6)这个索引结构中每个邮箱字段都只取前6个字节，所以<strong>占用的空间会更小，但可能会增加额外的记录扫描次数。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,emial <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果使用的是index1(即email整个字符串的索引结构)</p>
<ol>
<li>从index1索引树找到满足索引值是‘zhangssxyz@xxx.com’的这条记录，取得ID2的值。</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这条记录加入结果集。</li>
<li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
</li>
<li><p>如果使用的是index2(即emai(6)索引结构)</p>
<ol>
<li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li>
<li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’<span class="exturl" data-url="bWFpbHRvOnpoYW5nc3N4eXpAeHh4LmNvbQ==">zhangssxyz@xxx.com<i class="fa fa-external-link-alt"></i></span>’，这行记录丢弃；</li>
<li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p>
</li>
</ul>
<p><strong>使用前缀索引，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。</strong></p>
<p><strong>怎么确定该使用多长的前缀呢？</strong></p>
<p>区分度越高越好，意味着重复的键值越少。因此可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure>

<p>依次选取不同长度的前缀的值，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">4</span>)) <span class="keyword">as</span> L4,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">5</span>)) <span class="keyword">as</span> L5,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">6</span>)) <span class="keyword">as</span> L6,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">7</span>)) <span class="keyword">as</span> L7 <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure>

<p>使用前缀索引很可能损失区分度，所以需要预先设定一个可以接收的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7都满足，你就可以选择前缀长度为 6。</p>
<p><strong>前缀索引对覆盖索引的影响</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure>

<p>与前面例子中的SQL语句相比，这个语句只要求返回id和email字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure>

<p>如果使用index1(即email整个字符串的索引结构)的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回表；而如果使用index2(即email(6)索引结构)的话，就不得不回到ID索引再去判断email的值。</p>
<p>即使将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p>
<p><strong>其他方式</strong></p>
<ol>
<li><p>使用倒序存储</p>
<p>如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用hash字段</p>
<p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc)</span><br></pre></td></tr></table></figure>

<p>每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能会冲突，所以查询语句where部分要判断id_card的值是否精确相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">'input_id_card_string'</span>) <span class="keyword">and</span> id_card=<span class="string">'input_id_card_string'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用倒序存储和使用 hash 字段的异同点</strong></p>
<ol>
<li>倒叙存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。</li>
<li>倒序方式每次写和读的时候，都需要额外调一次reverse函数，而hash字段需要额外调一次crc32()函数，单纯从计算复杂度来看，reverse函数额外消耗的CPU资源会更小。</li>
<li>hash字段方式的查询性能相对更加稳定，因为crc32()算出来的值虽然有冲突的概率，但概率非常小，可以认为每次查询平均扫描行数接近1，而倒序存储方式毕竟还是前缀索引的方式，即还是会增加扫描行数。</li>
</ol>
<h4 id="2-4-为啥SQL语句偶尔会变”慢”？"><a href="#2-4-为啥SQL语句偶尔会变”慢”？" class="headerlink" title="2.4 为啥SQL语句偶尔会变”慢”？"></a>2.4 为啥SQL语句偶尔会变”慢”？</h4><p>InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作(redo log)，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p>
<p>flush：把内存中的数据写入磁盘的过程</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存为”脏页”。内存数据写入到磁盘后，内存就和磁盘上的数据页上的数据页的内容就一致了，称为”干净页”。</p>
<p><img data-src="../assets/img/fdff151353.png" alt></p>
<p>平时执行很快的操作：写内存和日志<br>偶尔”抖”一下：刷脏页(flush)</p>
<p><strong>什么情况下会引发数据库的flush操作?</strong></p>
<ol>
<li><p>InnoDB的redo log写满了。这时系统会停止所有更新操作，把checkpont往前推进，redo log留出空间可以继续写。</p>
<p><img data-src="../assets/img/111152005.png" alt></p>
<p>把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志，对应的所有脏页都flush到磁盘上。</p>
</li>
<li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，淘汰一些数据页，空出内存。如果淘汰的是”脏页”，就需要先将脏页写到磁盘。</p>
</li>
<li><p>MySQL认为系统”空闲”的时候就刷一点”脏页”。</p>
</li>
<li><p>MySQL正常关闭的时候，会把内存的脏页都flush到磁盘上，这样MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
</li>
</ol>
<p><strong>对性能的影响</strong></p>
<ol>
<li><p>“redo log 写满了，要 flush 脏页”，这种情况，所有的更新都被堵塞，需要避免。</p>
</li>
<li><p>“内存不够用了，要先将脏页写到磁盘”，InnoDB使用缓冲池管理内存，缓冲池中的内存页有3种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页。</p>
<p>当要读入的数据页没有在内存中的时候，就必须到缓冲池申请一个数据页。这时需要把最久不使用的数据页从内存中淘汰掉。如果淘汰的是一个干净页，就直接释放出来复用；如果是脏页，就必须先刷到磁盘，变成干净页后才能复用。</p>
<ul>
<li>一个查询要淘汰的脏页个数太多。</li>
<li>日志写满，更新全部堵住。</li>
</ul>
</li>
</ol>
<p><strong>InnoDB刷脏页的控制策略</strong></p>
<p>参考因素：脏页比例，redo log写盘速度。</p>
<p>innodb_max_dirty_pages_pct：脏页比例上限，默认75%  F1(M)</p>
<p>InnoDB每次写日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，假设为F2(N)(N越大，算出来的值越大)。</p>
<p>F1(M)和F2(N)的最大值为R，接下来引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的数据。</p>
<p><img data-src="../assets/img/121154612.png" alt></p>
<p>合理设置innodb_io_capacity，多关注脏页比例，不要让它接近75%。</p>
<p>innodb_flush_neighbors，值为1时，对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷(机械硬盘时代，减少随机IO)。值为0时，只刷自己的，MySQL8.0之后，默认为0。</p>
<h4 id="2-5-为什么表数据删掉一半，表文件大小不变？"><a href="#2-5-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="2.5 为什么表数据删掉一半，表文件大小不变？"></a>2.5 为什么表数据删掉一半，表文件大小不变？</h4><p><strong>参数innodb_file_per_table</strong></p>
<p>innodb_file_per_table：MySQL5.6.6版本后默认为ON</p>
<ul>
<li>OFF：表的数据放在系统共享表空间，也就是跟数据字典放在一起。</li>
<li>ON：每个InnoDB表数据存储在一个.ibd为后缀的文件中。</li>
</ul>
<p>推荐设置为ON，一个表单独存储为一个文件更容易管理，不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。如果放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<p><strong>数据删除流程</strong></p>
<p><img data-src="../assets/img/jhj195615.png" alt><br>假设，我们需要删除掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>InnoDB的数据是按页存储的，如果删除一个数据页上的所有记录，整个数据页就可以被复用了，但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。<br>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。</p>
<p>如果用delete命令删除整个表的数据，所有的数据页都会被标记为可复用。但磁盘上，文件大小不变。</p>
<p>不止是删除数据会造成空洞，插入数据也会。</p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<p><img data-src="../assets/img/1212201259.png" alt></p>
<p>由于page A满了，申请一个新的页面page B来保存数据。页面分裂完成后，page A的末尾就留下了空洞。</p>
<p><strong>重建表</strong></p>
<p>新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行行地从表A里读出来再插入到表B中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">alert table A engine=InnoDB</span><br></pre></td></tr></table></figure>

<p>MySQL5.6版本开始引入Online DDL(往临时表插入数据的过程中，表A中不能有更新)。</p>
<p><img data-src="../assets/img/dsd203817.png" alt></p>
<ol>
<li>建立一个临时文件，扫描表A主键的所有数据页。</li>
<li>用数据页中表A的记录生成B+树，存储到临时文件。</li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件(row log)中，对应图中state2的状态。</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据与表A相同的数据文件，对应图中state3的状态。</li>
<li>用临时文件替换表A的数据文件。</li>
</ol>
<h4 id="2-6-count-的实现方式"><a href="#2-6-count-的实现方式" class="headerlink" title="2.6 count(*)的实现方式"></a>2.6 count(*)的实现方式</h4><p>MyISAM引擎把一个表的总行数存在了磁盘上，count(*)会直接返回这个数(不含where条件)。</p>
<p>InnoDB引擎需要把数据一行一行的从引擎里面读出来，然后累计计数。</p>
<p><strong>为什么InnoDB不像MyISAM一样把数字存放起来？</strong></p>
<p>和InnoDB的事务设计有关，可重复读是它的默认的隔离级别，通过多版本并发控制(MVCC)实现。每一行记录都要判断自己是否对这个会话可见，因此count(*)，InnoDB只好把数据一行一行的读出依次判断。</p>
<ul>
<li>MyISAM表虽然count(*)很快，但不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<p><strong>不同的count用法</strong></p>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>
<p>原则：</p>
<ol>
<li>server原则要什么就什么；</li>
<li>InnoDB只给必要的值；</li>
<li>现在的优化器只优化了count(*)的语义取行数。</li>
</ol>
<ul>
<li><p>count(主键id)</p>
<p>InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空后，按行累加。</p>
</li>
<li><p>count(1)</p>
<p>InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字”1”进去，判断是不可能为空的，按行累加。</p>
<p>count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
</li>
<li><p>count(字段)</p>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
</li>
<li><p>count(*)</p>
<p>不取值。count(*) 肯定不是 null，按行累加。</p>
</li>
</ul>
<p>效率：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</p>
<h4 id="2-7-“order-by”是如何工作的？"><a href="#2-7-“order-by”是如何工作的？" class="headerlink" title="2.7 “order by”是如何工作的？"></a>2.7 “order by”是如何工作的？</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p> <strong>全字段排序</strong><img data-src="../assets/img/image-20210714220341145.png" alt></p>
<p>Extra：”Using filesort”表示需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p>
<p><img data-src="../assets/img/220736.png" alt></p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age三个字段；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<p>sort_buffer_size：MySQl为排序开辟的内存的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，否则利用磁盘临时文件辅助排序(外部排序。</p>
<p>外部排序一般使用归并算法，即将要排序的数据分成12份，每一份单独排序后，将这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。</p>
<p>只对原表的数据读了一遍，剩下的操作都是在sort_buffer或临时文件中执行，但如果要查询返回的字段特别多，则需要分成很多临时文件，排序性能很差。</p>
<p><strong>rowid排序</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> max_length_for_sort_data = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>如果单行的长度超过这个值，MySQL就认为单行太大，需要换个算法(city、name、age这3个字段的定义总长度36)。新的算法放入sort_buffer的字段，只要排序的列(即name字段)和主键id。</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name快速排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表取出city、name和age三个字段返回给客户端。</li>
</ol>
<p>rowid多访问了一次表t的主键索引，即步骤7。</p>
<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<p>MySQL之所以要生成临时表并且在临时表上做排序操作，是因为原来的数据都是无序的。</p>
<p><strong>联合索引</strong></p>
<p>如在这张表上创建一个city和name的联合索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city,<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/ds50223.png" alt></p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name)取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li>
</ol>
<p><strong>覆盖索引</strong></p>
<p>覆盖索引上的信息足够满足查询请求，不需要再回到主键索引上取数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city,<span class="keyword">name</span>,age)</span><br></pre></td></tr></table></figure>

<ol>
<li>从索引(city,name,age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name和age这3个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name,age)取下一个记录，同样取出这3个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li>
</ol>
<h4 id="2-8-为什么这些SQL语句逻辑相同，但性能差异巨大"><a href="#2-8-为什么这些SQL语句逻辑相同，但性能差异巨大" class="headerlink" title="2.8 为什么这些SQL语句逻辑相同，但性能差异巨大"></a>2.8 为什么这些SQL语句逻辑相同，但性能差异巨大</h4><ol>
<li><p><strong>条件字段函数操作</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>查询所有年份中7月份的交易记录总数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>下面是t_modified索引的示意图，方框上面的数字就是month()函数对应的值。<img data-src="../assets/img/dd223828.png" alt></p>
<p>B+树的快速定位能力来源于同一层兄弟节点的有序性，<strong>对索引字段做函数操作，可能会破环索引值的有序性，因此优化器决定放弃走树搜索功能，导致全索引扫描(并不是放弃这个索引)。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span>(t_modified &gt;=<span class="string">'2016-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2016-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2017-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2017-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2018-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2018-7-1'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式类型转换</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid=<span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>tradeid的字段类型是varchar(32)，而输入的参数是整形，需要做类型转换。</p>
<p><strong>字符串和数字作比较：将字符串转换成数字</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">CAST</span>(tradeid <span class="keyword">AS</span> signed <span class="built_in">int</span>) = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>因此触发：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
</li>
<li><p><strong>隐式字符编码转换</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`trade_detail`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`trade step`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 操作步骤 */</span></span><br><span class="line"><span class="string">`step_info`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure>

<p>查询id=2的交易的所有操作步骤信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210722215222511.png" alt></p>
<ol>
<li>优化器会先在交易记录表tradelog上查到id=2的行，这个步骤使用了主键索引，row=1表示只扫描一行；</li>
<li>第2行key=NULL，表示没用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li>
</ol>
<p>从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，tradelog称为驱动表，把trade_detail表称为被驱动表，把tradeid称为关联字段。</p>
<p><img data-src="../assets/img/image-20210722222051685.png" alt></p>
<ol>
<li>根据id在tradelog表中找到L2这一行；</li>
<li>从L2中取出tradeid字段的值；</li>
<li>根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key=NULL表示的就是，这个过程就是通过遍历主键索引的方式，一个个的判断tradeid的值是否匹配。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid=$L2.tradeid.value</span><br></pre></td></tr></table></figure>

<p>$L2.tradeid.value的字符集就是utf8mb4，字符集utf8mb4是utf8的超集，两个不同类型的字符串比较时，MySQL会把utf8字符串转成utf8mb4字符集再做比较。所以需要将被驱动数据表里的字段一个一个转成utf8mb4，再与L2比较，类似于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(tradeid <span class="keyword">USING</span> uth8mb4)=$L2.tradeid.value</span><br></pre></td></tr></table></figure>

<p>再次触发了：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<p><strong>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =$R4.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =<span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4);</span><br></pre></td></tr></table></figure>

<p>CONVERT函数加在输入参数上，可以用上被驱动表的tradeid索引。</p>
<p><strong>优化：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>把trade_detail表上的tradeid字段的字符集也改成utf8mb4</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail <span class="keyword">modify</span> tradeid <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改sql语句，主动把l.tradeid转成utf8，避免了被驱动表上的字符编码转换。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=<span class="keyword">CONVERT</span>(l.trade.id <span class="keyword">USING</span> utf8) <span class="keyword">on</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="2-9-为什么我只查一行的语句，也执行这么慢？"><a href="#2-9-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="2.9 为什么我只查一行的语句，也执行这么慢？"></a>2.9 为什么我只查一行的语句，也执行这么慢？</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">while(i&lt;=100000)do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>查询长时间不返回</strong></p>
<p>大概率表t被锁住了，执行<code>show processlist</code>命令查看当前语句状态。</p>
<ul>
<li><p><strong>等MDL锁</strong></p>
<p><img data-src="../assets/img/image-20210726223343443.png" alt></p>
<p><code>Wating for table metadata lock</code>状态表示的是，现在有一个线程正在表t上请求或持有MDL写锁，把select语句堵住了。</p>
<p>找到谁持有MDL锁，然后把它kill掉。<br>通过查询sys.schema_table_lockwaits这张表，直接找出造成阻塞的process id，把这个连接用kill命令断开即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>等flush</strong></p>
<p><code>Waiting for table flush</code>表示，有一个线程正要对表t做flush操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;	<span class="comment">#只关闭表t</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;  <span class="comment">#关闭所有打开的表</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>正常情况下，这两个语句执行都很快，可能的情况：有一个flush tables 命令被别的语句堵住了，然后它又堵住了select语句。</code></pre><ul>
<li><p><strong>等行锁</strong></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>update t set c=c+1 where id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from where id=1 lock in share mode;</td>
</tr>
</tbody></table>
<p>show processlist</p>
<p><img data-src="../assets/img/image-20210727221501088.png" alt></p>
<p>查询是谁占有了写锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> locked_table,waiting_pid,waiting_query,blocking_trx_id,blocking_pid <span class="keyword">from</span> sys.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ol start="2">
<li><p><strong>查询慢</strong></p>
<ul>
<li><p>查看是否开启慢查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置慢查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img data-src="../assets/img/image-20210802212135496.png" alt></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1;//执行100万池</td>
</tr>
<tr>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>select * from where id=1 lock in share mode;</td>
<td></td>
</tr>
</tbody></table>
<p><img data-src="../assets/img/image-20210802212638953.png" alt></p>
<p>session B更新完100万次，生成了100万个回滚日志(undo log)。(undo log里记录的其实是”把2改成1”，”把3改成2”这样的操作逻辑)</p>
<p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1是一致性读，因此需要从1000001开始，依次执行log，执行100万次以后，才将1这个结果返回。</p>
</li>
</ol>
<h4 id="2-10-幻读"><a href="#2-10-幻读" class="headerlink" title="2.10 幻读"></a>2.10 幻读</h4><ul>
<li><p>幻读有什么问题？</p>
<ul>
<li>语义</li>
<li>数据一致性</li>
</ul>
</li>
<li><p>如何解决幻读？</p>
<p>产生幻读的原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的”间隙”。</p>
<p><strong>间隙锁(Gap Lock)</strong></p>
<p>锁的就是两个值之间的空隙。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210804221313976.png" alt="批量插入数据"></p>
<p>当执行<code>select * from t where d=5 for update</code>的时候，就不止给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。即在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空袭，也加上了间隙锁。</p>
<p>行锁分为读锁和写锁：</p>
<p><img data-src="../assets/img/image-20210804221753434.png" alt></p>
<p>跟行锁有冲突关系的是”另外一个行锁”。</p>
<p>但跟间隙锁存在冲突关系的，是”往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</p>
<p>间隙锁和行锁合称next-key lock，next-key-lock解决了幻读的问题，但可能会导致同样的语句锁住更大的范围。</p>
<p>间隙锁在可重复读隔离级别下才会生效，<strong>把隔离级别设为读提交，就没有间隙锁了。但同时可能会出现数据和日志不一致问题，需要把binlog格式设置为row。</strong></p>
</li>
</ul>
<h4 id="2-11-next-key-lock"><a href="#2-11-next-key-lock" class="headerlink" title="2.11 next-key lock"></a>2.11 next-key lock</h4><ol>
<li>原则1：加锁的基本单位是next-key lock，前开后闭((5,10])</li>
<li>原则2：查找过程中访问到的对象才会加锁</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化成行锁</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁</li>
<li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为此</li>
</ol>
<p>删除数据的时候尽量加limit，不仅可以控制删除数据的条数，让操作更安全，还可减小加锁的范围。</p>
<p>next-key lock实际上是由间隙锁加行锁实现的。</p>
<h4 id="2-12-应急提高性能的方法"><a href="#2-12-应急提高性能的方法" class="headerlink" title="2.12 应急提高性能的方法"></a>2.12 应急提高性能的方法</h4><ul>
<li><p><strong>短连接风暴</strong></p>
<p>如果使用的是短链接，业务高峰期，连接数暴增。MySQL建立连接成本很高(网络连接3次握手、登录权限判断和获得这个连接的读写权限)。</p>
<p>数据库处理不及时；机器负载较高时，处理现有请求耗时变长，每个连接保持的时间也更长；连接数上限：max_connections，超过这个值时，会拒绝接下来的连接请求，并报错提示”Too many connections”。</p>
<ul>
<li><p><strong>先处理掉那些占着连接但不工作的线程</strong></p>
<p>max_connections，只要连着就占用一个计数位置。kill connection处理掉不需要保持的连接；设置wait_tineout参数(一个线程空闲wait_timeout这么多秒以后，就会被MySQL直接断开连接)。</p>
<blockquote>
<p>优先断开事务外空闲太久的连接，如果这样还不够，再考虑断开事务内的空闲太久的连接。(从 information_schema.innodb_trx 查询事务状态)</p>
</blockquote>
<p>kill connection + id，一个客户端处于sleep状态，它的连接被服务端主动断开，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到报错”ERROR 2013 (HY000): Lost connection to<br>MySQL server during query”。</p>
</li>
<li><p><strong>减少连接过程的消耗</strong></p>
<p>让数据库跳过权限验证阶段，重启数据库，并使用-skip-grant-tables参数启动，整个MySQL会跳过所有的权限验证，包括连接过程和语句执行过程，<strong>风险极高</strong>。</p>
<blockquote>
<p>MySQL8.0，如果启用-skip-grant-tables参数，MySQL会默认把-skip-networking参数打开，表示数据库只能被本地的客户端连接。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>慢查询性能问题</strong></p>
<p>引发慢查询的可能：</p>
<ol>
<li>索引没有设计好</li>
<li>SQL语句没写好</li>
<li>MySQL选错索引</li>
</ol>
<ul>
<li><p><strong>索引没有设计好</strong></p>
<p>紧急创建索引，MySQL5.6之后，创建索引支持Online DDL，直接执行alter table语句。</p>
<ol>
<li>在备库B上执行set sql_log_bin=off，即不写binlog，然后执行alter table语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是B，备库是A。在A上执行set sql_bin_log=off，然后执行alter table语句加上索引。</li>
</ol>
</li>
<li><p><strong>SQL语句没写好</strong></p>
<p>MySQL5.7之后提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p>
<p>如语句被错误地写成了 <code>select * from t where id + 1 = 10000</code>，可以通过下面的<br>方式，增加一个语句改写规则。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br><span class="line"><span class="comment">-- 这个存储过程，让插入的新规则生效，即"查询重写"</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210823224604330.png" alt></p>
</li>
<li><p><strong>MySQL选错索引</strong></p>
<p>使用查询重写功能，给原来的语句加上force index。</p>
</li>
</ul>
<p>通过以下方式，预先发现问题：</p>
<ol>
<li>上线前，在测试环境，把慢查询日志(show log)打开，并把long_query_time设为0。(确保每个语句都会被记录入慢查询日志)</li>
<li>在测试表里插入线上数据，进行回归测试。</li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined(每次执行过程中实际扫描的记录数)字段是否与预期一致。</li>
</ol>
</li>
<li><p><strong>QPS突增问题</strong></p>
<p>业务突然出现高峰或应用程序bug，导致某个语句QPS暴增。</p>
<ol>
<li><p>由全新业务的bug导致的，能够确定业务方会下掉这个功能，可以从数据库直接把白名单去掉。(白名单机制)</p>
</li>
<li><p>如果使用的是单独的数据库用户，可以用管理员账号把这个用户删掉。(业务账户分离)</p>
</li>
<li><p>如果新增的功能和主体功能是部署在一起的，可以通过查询重写功能，单独把这个语句以select 1的结果返回。</p>
<p>副作用：</p>
<ul>
<li>如果别的功能里也使用了这个SQL语句模板，会有误伤。</li>
<li>很多业务不是一个语句就完成逻辑的，单独把这个语句以select 1的结果返回，可能导致后面的业务逻辑一起失败。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-13-MySQL是如何保证数据不丢失的"><a href="#2-13-MySQL是如何保证数据不丢失的" class="headerlink" title="2.13 MySQL是如何保证数据不丢失的"></a>2.13 MySQL是如何保证数据不丢失的</h4><p>WAL机制(Write-Ahead Logging 先写日志，再写磁盘)，只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p>
<p><strong>binlog的写入机制</strong></p>
<p>事务执行过程中，先把日志写到binglog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过，就要暂存到磁盘。</p>
<p><img data-src="../assets/img/image-20210906222648205.png" alt="binlog写盘状态"><br>每个线程有自己的binlog cache，但共用同一份binlog文件。<br>write：把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，速度较快。<br>fsync：将数据持久化到磁盘，占用磁盘的IOPS。</p>
<p>参数sync_binlog：</p>
<ol>
<li>sync_binlog=0时，每次提交事务都只write，不fsync；</li>
<li>sync_binlog=1时，每次提交事务都会执行fsync；</li>
<li>sync_binlog=N(N&gt;1)时，表示每次提交事务都write，但累积N个事务后才能fsync。</li>
</ol>
<p><strong>如果IO出现瓶颈，可以将sync_binlog设为一个较大的值。</strong>但实际考虑到丢失日志量的可控性，常见的是将其设置为100-1000。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p>
<p><strong>redo log的写入机制</strong></p>
<p>redo log buffer：在事务执行的过程中，生成的redo log是要先写到redo log buffer的。</p>
<p><img data-src="../assets/img/image-20210906223901216.png" alt="redo log存储状态"></p>
<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，图中红色部分。</li>
<li>写到磁盘(write)，但是没有持久化(fsync)，物理上是在文件系统的page cache里，图中黄色部分。</li>
<li>持久化到磁盘，对应hard disk，图中绿色部分。</li>
</ol>
<p>innodb_flush_log_at_trx_commit参数：</p>
<ol>
<li>为0时，表示每次事务提交时都只是把redo log留在redo log buffer中；</li>
<li>为1时，表示每次事务提交时都将redo log持久化到磁盘。</li>
<li>为2时，表示每次事务提交时都只是把redo log写到page cache。</li>
</ol>
<p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cahce，然后调用fsync持久化到磁盘。</p>
<blockquote>
<p>事务执行中间过程的redo log也是直接卸载redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。所以，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p>
</blockquote>
<p>除了后台线程的轮询操作，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：</p>
<ol>
<li>redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，即只留在了文件系统的page cache。</li>
<li>并行的事务提交时，顺带将这个事务的redo log buffer持久化到磁盘。</li>
</ol>
<p>两阶段提交：时序上redo log先prepare，再写binlog，最后再把redo log commit。</p>
<p>如果把innodb_flush_log_at_trx_commit设置为1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖prepare的redo log，再加上binlog来恢复的。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p>
<p><strong>“双1”配置</strong>：sync_binlog和innodb_flush_log_at_trx_commit都设置为1，即<strong>一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare阶段)，一次是binlog。</strong></p>
<p><strong>组提交</strong></p>
<p>日志逻辑序列号(LSN)：单调递增，用来对应redo log的一个个写入点。每次写入长度为length的redo log，LSN的值就会加上length。LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p>
<p>三个并发事务在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。</p>
<p><img data-src="../assets/img/image-20210915222802904.png" alt></p>
<ol>
<li>trx1是第一个到达的，会被选为这组的leader；</li>
<li>等trx1要开始写盘的时候，这个组里已经有了三个事务，这时候LSN也变成了160。</li>
<li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li>
<li>这时候trx2和trx3就可以直接返回了。</li>
</ol>
<p><strong>一次组提交里面，组员越多，节约磁盘IOPS的效果越好。</strong>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p>
<p><strong>“拖时间”</strong></p>
<p>两阶段提交：</p>
<p><img data-src="../assets/img/image-20210915224702007.png" alt="image-20210915224702007"></p>
<p>其实”写binlog”是分成两步的：</p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li>
<li>调用fsync持久化。</li>
</ol>
<p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后，则上图变成了：</p>
<p><img data-src="../assets/img/image-20210915225004511.png" alt></p>
<p>这样一来，binlog也可以组提交了，不过通常第3步执行的会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p>可以通过binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来提升binlog组提交的效果。</p>
<ol>
<li>binlog_group_commit_sync_delay：延迟多少微妙后才调用fsync；</li>
<li>binlog_group_commit_sync_no_delay_count：累积多少次以后才调用fsync。</li>
</ol>
<p>这两个条件是或的关系，只要一个满足条件就会调用fsync。因此，当 binlog_group_commit_sync_delay 设置为 0 的时候，binlog_group_commit_sync_no_delay_count 也无效了。</p>
<p><strong>WAL制作得益于</strong>：</p>
<ol>
<li>redo log和binlog都是顺序写，磁盘的顺序写比随机写速度要快。</li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li>
</ol>
<p><strong>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</strong></p>
<ol>
<li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。基于”额外的故意等待”实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将sync_binlog设置为大于1的值(常见的为100-1000)。风险：主机断电时会丢binlog日志。</li>
<li>将innodb_flush_log_at_trx_commit设置为2。风险：主机断电时会丢binlog日志。(不建议设置成 0。因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。)</li>
</ol>
<h4 id="2-14-MySQL是怎么保证主备一致的"><a href="#2-14-MySQL是怎么保证主备一致的" class="headerlink" title="2.14 MySQL是怎么保证主备一致的"></a>2.14 MySQL是怎么保证主备一致的</h4><p><strong>MySQL主备的基本原理</strong></p>
<p><img data-src="../assets/img/image-20211008220747983.png" alt></p>
<p>客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。需要切换的时候，就切换成状态2。这时客户端读写访问节点B，而节点A是B的备库。</p>
<p>备库虽然没有被直接访问，但仍建议设为只读(readonly)模式：</p>
<ol>
<li>有时一些运营类的查询语句会放到备库上查询，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有bug，如切换过程中出现双写，造成主备不一致；</li>
<li>可以通过readonly状态，判断节点的角色。</li>
</ol>
<p><code>readonly状态，怎么与主库保持同步更新？</code></p>
<p>readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p>
<p><img data-src="../assets/img/image-20211008222439618.png" alt="节点A到B的内部流程"></p>
<p>备库B跟主库A之间维持了一个长连接，主库A内部有一个线程，专门服务备库B的这个长连接。</p>
<p>一个事务日志同步的完整过程：</p>
<ol>
<li>在备库B上通过chang master命令，设置主库A的IP、端口、用户名、密码，以及从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread(主要负责与主库建立连接)和sql_thread。</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B；</li>
<li>备库B拿到binlog之后，写到本地文件，称为中转日志(ready log)；</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p>多线程复制方案的引入，sql_thread演化成了多个线程。</p>
</blockquote>
<p><strong>binlog的三种格式对比</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a&gt;=<span class="number">4</span> <span class="keyword">and</span> t_modified&lt;=<span class="string">'2018-11-10'</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>statement</p>
<p>记录到binlog里的语句原文，在主库执行时，用的是索引a，而在备库执行时，却用了索引t_modified，可能会造成主备不一致。</p>
</li>
<li><p>row</p>
<p>row格式的binlog里没有了SQL语句原文，而是替换成了两个event：Table_map(用于说明接下来操作的表)和Delete_rows(用于定义删除的行为)</p>
</li>
<li><p>mixed</p>
<p>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。但row格式，很占空间。如一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果是row格式，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</p>
<p>mixed格式：<strong>MySQL会自己判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。(线上至少应该把 binlog 的格式设置为 mixed)</strong></p>
</li>
</ol>
<p><strong>恢复数据</strong></p>
<p>现在越来越多场景要求把MySQL的binlog格式设为row，如<code>恢复数据</code>。</p>
<p>binlog恢复数据的标准做法：用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog master.000001  <span class="comment">--start-position=2738 --stop-position=2942 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure>

<p>含义：将master.00001文件里面从2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p>
<p><strong>循环复制问题</strong></p>
<p><img data-src="../assets/img/image-20211010224052755.png" alt="MySQL 主备切换流程 -- 双 M 结构"></p>
<p>双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。</p>
<p>但如果业务逻辑在A上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（建议把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<p>日志执行流程：</p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id；</li>
<li>传到节点B执行一次后，节点B生成的binlog的server id也是A的server id；</li>
<li>再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环就断掉了。</li>
</ol>
<h4 id="2-15-MySQL是怎么保证高可用的？"><a href="#2-15-MySQL是怎么保证高可用的？" class="headerlink" title="2.15 MySQL是怎么保证高可用的？"></a>2.15 MySQL是怎么保证高可用的？</h4><p> <strong>主备延迟</strong></p>
<p>主备切换：可能是一个主动运维动作，如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电等。</p>
<p><strong>同步延迟</strong></p>
<ol>
<li>主库A执行完成一个事务，写入binlog，这个时刻记为T1；</li>
<li>之后传给备库B，备库B接收完成这个binlog的时刻记为T2；</li>
<li>备库B执行完成这个事务，这个时刻记为T3。</li>
</ol>
<p><strong>主备延迟：同一个事务在备库执行完成的时间和主库执行完成的时间之间的差值</strong>，即T3-T1。</p>
<p>执行<code>show slave status</code>命令，返回结果<code>seconds_behind_master</code>(时间精度：秒)，用于表示当前备库延迟了多少秒。</p>
<p>seconds_behind_master的计算方法：</p>
<ol>
<li>每个事务binlog都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，即seconds_behind_master。</li>
</ol>
<p>主备库机器时间设置不一致，会不会导致主备延迟的值不准确？</p>
<p>不会，备库连接到主库时，会执行<code>SELECT UNIX_TIMESTAMP()</code>函数来获取当前主库的系统时间，如果不一致，备库在计算seconds_behind_master时会扣掉差值。</p>
<p>主备延迟主要来源是：<strong>备库接收完binlog和执行完成这个事务之间的时间差</strong>。</p>
<p><strong>主备延迟的来源</strong></p>
<ol>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p>
<p>对称部署</p>
</li>
<li><p>备库压力大</p>
<p>忽视备库的压力控制，一些分析查询语句在备库耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p>
<ol>
<li>一主多从，多接几个从库，分担读的压力；</li>
<li>通过binlog输出到外部系统，如Hadoop这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
</li>
<li><p>大事务</p>
<p>主库上必须等事务执行完成后才写入binlog，再传入给备库。如果一个主库上的语句执行10分钟，那这个事务可能导致主备延迟10分钟。</p>
<p>如一次性delete大量数据，大表DDL(建议使用gh-ost方案)。</p>
</li>
<li><p>备库的并行复制能力</p>
</li>
</ol>
<p>主备切换不同的策略：</p>
<p><strong>可靠性优先策略</strong></p>
<p><img data-src="../assets/img/image-20211205225611489.png" alt="MySQL可靠性优先主备切换流程"></p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值(如5秒)继续下一步，否则重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设为true；</li>
<li>判断备库B的senconds_behind_master的值，直到这个值变为0；</li>
<li>把备库B改成可读写状态，即把readonly设为false；</li>
<li>把业务请求切换到B库。</li>
</ol>
<p>不可用时间：步骤2到步骤5，步骤3耗费时间(步骤1保证步骤3尽可能短)。</p>
<p><strong>可用性优先策略</strong></p>
<p>步骤4、5调整到最开始执行，及不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写。</p>
<p>几乎没有不可用时间，可能出现数据不一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>继续执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>假设，现在主库上有大量的更新，导致主备延迟5秒。在插入一条c=4的语句后，发起了主备切换。</p>
<p><img data-src="../assets/img/image-20211206223345522.png" alt="可用性优先策略，且binlog_format=mixed"></p>
<ol>
<li><p>步骤2中，主库A执行完insert语句，插入一行数据(4,4)，之后开始进行主备切换；</p>
</li>
<li><p>步骤3中，由于主备之间有5秒延迟，所以备库B还未应用”插入c=4”这个中转日志，就开始接收”插入c=5”的命令；</p>
</li>
<li><p>步骤4中，备库B插入了一行数据(4,5)，并且把这个binlog发给主库A；</p>
</li>
<li><p>步骤 5 中，备库B执行”插入 c=4”这个中转日志，插入了一行数据(5,4)。而直接在备库B执行的”插入 c=5”这个语句，传到主库 A，就插入了一行新数据((5,5)。</p>
<p>主库A和备库B上出现了两行不一致的数据。</p>
</li>
</ol>
<p>可用优先策略，设置bnlog_format=row会怎样？</p>
<p>row格式在记录binlog的时候，会记录新插入的行的所有字段值，最后只会有一行不一致，两边的主备同步的应用线程会报错 duplicate key error 并停止。备库 B 的 (5,4) 和主库 A 的 (5,5) 这两行数据，都不会被对方执行。</p>
<p><img data-src="../assets/img/image-20211206224759317.png" alt="可用优先策略，且binlog_format=row"></p>
<p>结论：</p>
<ol>
<li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。</li>
<li>主备切换的可用性优先策略会导致数据不一致。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/multithreading/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-多线程基础"><a href="#1-多线程基础" class="headerlink" title="1.多线程基础"></a>1.多线程基础</h3><h4 id="1-1-实现多线程的方法"><a href="#1-1-实现多线程的方法" class="headerlink" title="1.1 实现多线程的方法"></a>1.1 实现多线程的方法</h4><ol>
<li><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现Runnable接口实现多线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"继承Thread类实现多线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">   </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，默认采用DefaultThreadFactory，它会给线程池创建的线程设置一些默认值，如：线程的名字、是否守护线程，以及线程的优先级等。但无论怎么设置这些这些属性，最终还是通过new Thread()创建线程的，只不过这里的构造函数传入的参数要多一些，<strong>本质还是通过new Thread()实现的</strong>。</p>
</li>
<li><p>实现有返回值的Callable创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">" : "</span>+ i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> Test_03());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable创建线程是无返回值的，而Callable和与之相关的Future、FutureTask，它们可以把线程执行的结果作为返回值返回。</p>
</li>
</ol>
<p><strong>……</strong></p>
<p><strong>实现线程只有一种方式</strong></p>
<p>启动线程需要调用start()方法，而start方法最终会调用run()方法，分析run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>target实际上就是一个Runnable，即使用Runnable接口实现线程时传给Thread类的对象。第二种，继承Thread方式，继承Thread之后，会把run()方法重写，最终还是会调用thread.start()方法启动线程，而start()方法最终也会调用这个已经被重写的run()方法来执行任务。创建线程<strong>本质就是构造一个Thread类</strong>，不同点在于<strong>实现线程运行内容的方式不同</strong>，可以通过实现Runnable接口，或继承Thread类重写run()方法。</p>
<h4 id="1-2-实现Runnable接口比继承Thread类实现线程更好？"><a href="#1-2-实现Runnable接口比继承Thread类实现线程更好？" class="headerlink" title="1.2 实现Runnable接口比继承Thread类实现线程更好？"></a>1.2 实现Runnable接口比继承Thread类实现线程更好？</h4><ol>
<li>Java不支持多继承，一旦继承了Thread类，就无法再继承其它类，限制了代码的可扩展性。</li>
<li>Runnable里只有一个run()方法，定义了需要执行的内容，实现了Runnable与Thread类的解耦，Thread类负责线程启动和属性设置，权责分明。</li>
</ol>
<h4 id="1-3-如何正确停止线程？"><a href="#1-3-如何正确停止线程？" class="headerlink" title="1.3 如何正确停止线程？"></a>1.3 如何正确停止线程？</h4><p>对于Java而言，最正确的停止线程的方式是使用interrupt，但<strong>interrupt仅仅起到通知被停止线程的作用，而对于被停止的线程而言，它拥有完全的自主权</strong>，即可以选择立即停止，也可以一段时间后停止，也可以不停止。Java<strong>希望程序间可以相互通知、相互协作的管理线程，如果贸然停止线程可能会造成一些安全性问题</strong>，为了避免造成问题就需要给对方一定的时间来整理收尾工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦调用某个线程的interrupt后，该线程的中断标记位就会被设置成true，每个线程都有这样的标记位，当线程执行时应定期检查这个标记位。上面代码可以看到，while循环判断语句中，先通过Thread.currentThread().isInterrupt()判断是否被中断，随后检查是否还有工作要做。</p>
<h4 id="1-4-sleep期间能否感受到中断？"><a href="#1-4-sleep期间能否感受到中断？" class="headerlink" title="1.4 sleep期间能否感受到中断？"></a>1.4 sleep期间能否感受到中断？</h4><p>如果sleep、wait等可以让线程进入阻塞的方法使线程休眠了，而<strong>处于休眠中的线程被中断，线程是可以感受到中断信号的，并会抛出InterruptedException</strong>，同时清除中短信号，将中断标记位设为false。</p>
<p>处理方式：</p>
<ol>
<li><p>方法签名抛异常，run()强制try/catch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求每一个方法的调用方有义务去处理异常。<strong>调用方要不使用try/catch并在catch中正确处理异常，要不将异常声明到方法签名中</strong>。如果每层逻辑都遵守规范，便可以将中断信号传递到顶层，最终让run()方法可以捕获到异常。而对于run()方法而言，它本身没有抛出checkedException的能力，只能通过try/catch来处理异常。层层传递异常保障了异常不会被遗漏，而对于run()方法，就可以根据不同的业务逻辑来进行相应的处理。</p>
</li>
<li><p>再次中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在catch语句中再次中断线程。如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时手动添加中断信号，中断信号依然可以被捕捉到。</p>
</li>
</ol>
<h4 id="1-5-为什么用volatile标记位的停止方法是错误的？"><a href="#1-5-为什么用volatile标记位的停止方法是错误的？" class="headerlink" title="1.5 为什么用volatile标记位的停止方法是错误的？"></a>1.5 为什么用volatile标记位的停止方法是错误的？</h4><p><strong>stop()会直接把线程停止，会导致出现数据完整性等问题。suspend()和resume()并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，容易导致死锁问题。</strong></p>
<p><strong>volatile修饰标记位适用的场景</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCanStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!canceled &amp;&amp; num &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + num + <span class="string">"是10的倍数"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileCanStop canStop = <span class="keyword">new</span> VolatileCanStop();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(canStop);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        canStop.canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动线程，经过3s，把volatile修饰的标记位设置为true，那么下一次while循环中判断出canceled的值为true，就跳出while循环，线程停止。</p>
<p><strong>volatile修饰标记位不适用的场景</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCanNotStop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayBlockingQueue storage = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">8</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">"被消费了"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者不需要更多数据了。"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来</span></span><br><span class="line">        producer.canceled = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canceled &amp;&amp; num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + num + <span class="string">"是50的倍数，被放到仓库中了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产者结束运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.97</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程被长时间阻塞的情况，就无法及时感受中断</strong>：尽管已经把canceled的标记位设置为true，但生产者仍然没有被停止，是因为生产者在执行storage.put(num)时发生阻塞，在它被叫醒之前是没有办法进入下次循环判断canceled的值的，这种情况下volatile没有办法让生产者停下来的，如果用interrupt语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做相应处理。</p>
<h4 id="1-6-线程是如何在6种状态之间转换的？"><a href="#1-6-线程是如何在6种状态之间转换的？" class="headerlink" title="1.6 线程是如何在6种状态之间转换的？"></a>1.6 线程是如何在6种状态之间转换的？</h4><p><strong>线程的6种状态</strong><br><img data-src="../../../../assets/img/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.png" alt></p>
<ol>
<li>New(新建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed Waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ol>
<ul>
<li><p>New 新建<br>New表示线程被创建但尚未启动的状态：new Thread()新建一个线程时，如果线程没有开始运行start()方法，所以也没有开始执行run()方法里面的代码，此时它的状态就是New。一旦线程调用了start()，就变成Runnable。</p>
</li>
<li><p>Runnable 可运行<br>Java中的Runnable状态对应操作系统线程状态中的两种状态，分别是Running和Ready，即Java中处于Runnable状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配CPU资源。所以，如果一个正在运行的线程是Runnable状态，当它运行到任务的一半时，执行该线程的CPU被调度去做其他事情，导致该线程暂时不运行，它的状态仍为Runnable，因为它有可能随时被调度回来继续执行任务。</p>
</li>
<li><p>Blocked 被阻塞<br>从Runnable状态进入Blocked状态只有一种可能，就是进入synchronized保护的代码块/方法时没有抢到monitor锁，Blocked仅仅针对synchronized monitor锁。</p>
</li>
<li><p>Waiting 等待<br>线程进入Waiting</p>
<ol>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ol>
<p>Blocked与Waiting的区别是Blocked在等待其它线程释放monitor锁，而Waiting则是在等待某个条件，比如join的线程执行完毕，或者是notify()/notifyAll()。</p>
</li>
<li><p>Timed Waiting 限期等待<br>Waiting和Time Waiting区别：有没有时间限制，Timed Waiting会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p>
<p>线程进入Timed Waiting</p>
<ol>
<li>设置了时间参数的Thread.sleep(long millis)方法</li>
<li>设置了时间参数的Object.wait(long timeout)方法</li>
<li>设置了时间参数的Thread.join(long millis)方法</li>
<li>设置了时间参数的LockSupport.parkNanos(long nanos)方法和LockSupport.parkUntil(long deadline)方法</li>
</ol>
<p>Blocked—&gt;Runnable：线程获取monitor锁</p>
<p>Waiting—&gt;Runnable：执行了LockSupport.unpark()，或join的线程运行结束，或者被中断。</p>
<p>Waiting—&gt;Blocked：其它线程调用notify()或notifyAll()，因为唤醒Waiting线程的线程如果调用notify()或notifyAll()，必须首先持有该monitor锁，所以处于Waiting状态的线程被唤醒时拿不到该锁，就会进入Blocked状态，直到执行notify()/notifyAll()的唤醒线程执行完毕并释放monitor锁，才可能轮到它去抢夺这把锁，抢到就会从Blocked状态回到Runnable状态。</p>
<p>TimedWaiting类似，但如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到Runnable状态。</p>
</li>
<li><p>Terminated<br>线程进入Terminated</p>
<ol>
<li>run()方法执行完毕，线程正常退出。</li>
<li>出现一个没有捕获的异常，终止了run()方法，最终导致意外终止。</li>
</ol>
</li>
</ul>
<p><strong>Tips</strong></p>
<ol>
<li>线程的状态是按照箭头方向走的，如线程从New不可以进入Blocked，它需要经历Runnable。</li>
<li>线程的生命周期不可逆：一旦进入Runnable就不能回到New状态；一旦被终止就不可能有任何状态的变化。所以一个线程只有一次New和Terminated状态，只有处于中间状态才可以相互转换。</li>
</ol>
<h4 id="1-7-为什么wait必须在synchronized保护的同步代码中使用？"><a href="#1-7-为什么wait必须在synchronized保护的同步代码中使用？" class="headerlink" title="1.7 为什么wait必须在synchronized保护的同步代码中使用？"></a>1.7 为什么wait必须在synchronized保护的同步代码中使用？</h4><h4 id="1-8-为什么wait-notify-notifyAll方法被定义在Object类中，而sleep定义在Thread类中？"><a href="#1-8-为什么wait-notify-notifyAll方法被定义在Object类中，而sleep定义在Thread类中？" class="headerlink" title="1.8 为什么wait/notify/notifyAll方法被定义在Object类中，而sleep定义在Thread类中？"></a>1.8 为什么wait/notify/notifyAll方法被定义在Object类中，而sleep定义在Thread类中？</h4><ol>
<li>Java中每个对象都有一把称之为monitor监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll也都是锁级别的操作，它们的锁属于对象，所以把它们定义在Object类，因为Object类是所有对象的父类。</li>
<li>如果把wait/notify/notifyAll方法定义在Thread类中，会带有很大的局限性，如一个线程可能持有多个锁。如何明确当前线程等待的是哪把锁呢？既然是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现。</li>
</ol>
<h4 id="1-9-wait-notify和sleep方法的异同"><a href="#1-9-wait-notify和sleep方法的异同" class="headerlink" title="1.9 wait/notify和sleep方法的异同"></a>1.9 wait/notify和sleep方法的异同</h4><p>相同点</p>
<ol>
<li>都可以让线程阻塞</li>
<li>都可以响应interrupt中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出InterruptedException</li>
</ol>
<p>不同点</p>
<ol>
<li>wait方法必须在synchronized保护的代码中使用，而sleep方法并没这个要求。</li>
<li>在同步代码块中执行sleep方法，并不会释放monitor锁，但执行wait方法时会主动释放monitor锁。</li>
<li>sleep方法必须定义一个时间，时间到期后会主动会恢复，而对于没有参数的wait方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不主动恢复。</li>
<li>wait/notify是Object类的方法，而sleep是Thread类的方法。</li>
</ol>
<h3 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2.线程安全"></a>2.线程安全</h3><p>如果某个对象是线程安全的，即使用时就不需要考虑方法间的协调问题。</p>
<h4 id="2-1-3种典型的线程安全问题"><a href="#2-1-3种典型的线程安全问题" class="headerlink" title="2.1 3种典型的线程安全问题"></a>2.1 3种典型的线程安全问题</h4><ol>
<li><p>运行结果错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongResult</span> </span>&#123;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       Thread thread1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">       thread1.start();</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">       thread2.start();</span><br><span class="line">       thread1.join();</span><br><span class="line">       thread2.join();</span><br><span class="line">       System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i++并不是一个原子操作</p>
</li>
<li><p>发布或初始化导致线程安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrongInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                students = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                students.put(<span class="number">1</span>, <span class="string">"王小美"</span>);</span><br><span class="line">                students.put(<span class="number">2</span>, <span class="string">"钱二宝"</span>);</span><br><span class="line">                students.put(<span class="number">3</span>, <span class="string">"周三"</span>);</span><br><span class="line">                students.put(<span class="number">4</span>, <span class="string">"赵四"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WrongInit wrongInit = <span class="keyword">new</span> WrongInit();</span><br><span class="line">        System.out.println(wrongInit.getStudents().get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>students 这个成员变量是在构造函数中新建的线程中进行的初始化和赋值操作，而线程的启动需要一定的时间，但是我们的 main 函数并没有进行等待就直接获取数据，导致 getStudents 获取的结果为 null，这就是<strong>在错误的时间或地点发布或初始化造成的线程安全问题</strong>。</p>
</li>
<li><p>活跃性问题</p>
<p>分别为死锁、活锁和饥饿</p>
<ul>
<li><p>死锁：两个线程之间相互等待对方资源，但同时又互不相让，都想自己先执行，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MayDeadLock</span> </span>&#123;</span><br><span class="line">    Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程1成功拿到两把锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程2成功拿到两把锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MayDeadLock deadLock = <span class="keyword">new</span> MayDeadLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                deadLock.thread1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                deadLock.thread2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>活锁：与死锁类似，不过活锁是活的，因为正在运行的线程并没有阻塞，它始终在运行，缺一直得不到结果。假设有一个消息队列里放着需要被处理的消息，而某个消息由于自身的错误无法被正确处理，同时队列的重试机制会把它放在队列头进行优先重试处理。</p>
</li>
<li><p>饥饿：线程需要某些资源始终得不到，尤其是CPU资源，就会导致线程一直不能运行。</p>
<ol>
<li>在Java中有1-10的线程优先级，1最低，10最高。如果某个线程的优先级为1，该线程就有可能始终分配不到CPU资源，而导致长时间无法运行。</li>
<li>或者是某个线程始终持有某个文件的锁，其他线程想要修改文件必须先获取锁，这时想要修改文件的线程就会陷入饥饿。<h4 id="2-2-需要额外注意线程安全的场景"><a href="#2-2-需要额外注意线程安全的场景" class="headerlink" title="2.2 需要额外注意线程安全的场景"></a>2.2 需要额外注意线程安全的场景</h4></li>
</ol>
</li>
</ul>
</li>
<li><p>访问共享变量和资源</p>
<p>如访问共享对象的属性、访问static静态变量、访问共享的缓存等。</p>
</li>
<li><p>依赖时序的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">    map.remove(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同数据之间存在绑定关系</p>
<p>不同的数据之间是成组出现的，存在着相互对应或绑定的关系，最典型的就是IP和端口号。</p>
</li>
<li><p>对方没有声明自己是线程安全的</p>
</li>
</ol>
<h4 id="2-3-为什么多线程会带来性能问题"><a href="#2-3-为什么多线程会带来性能问题" class="headerlink" title="2.3 为什么多线程会带来性能问题"></a>2.3 为什么多线程会带来性能问题</h4><p>单线程是独立工作的，不需要与其他线程进行交互，但多线程之间则需要调度以及协作，<strong>调度</strong>与<strong>协作</strong>就会带来性能开销从而产生性能问题。</p>
<ul>
<li><p>调度开销</p>
<ol>
<li><p><strong>上下文切换：</strong>线程数往往大于CPU核心数，操作系统会按照一定的调度算法，给每个线程分配时间片。而在进行调度时就会引起上下文切换，<strong>上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程。</strong></p>
</li>
<li><p><strong>缓存失效：</strong>进行了线程调度，切换到其他线程，CPU就会去执行不同的代码，<strong>原有的缓存就很有可能失效了，需要重新缓存新的数据。</strong></p>
<p>给被调度到的线程设置最小执行时间，即只有执行完这段时间后，才可能进行下一次的调度，由此减少上下文切换的次数。</p>
</li>
</ol>
</li>
<li><p>协作开销</p>
<p>为了避免共享数据错乱、保证线程安全，就有可能<strong>禁止编译器和CPU对其进行重排序等优化</strong>，也可能出于同步的目的，<strong>反复把线程工作内存的数据flush到主内存，然后再从主内存refresh到其他线程的工作内存中</strong>。</p>
</li>
</ul>
<h4 id="2-4-使用线程池的好处"><a href="#2-4-使用线程池的好处" class="headerlink" title="2.4 使用线程池的好处"></a>2.4 使用线程池的好处</h4><ol>
<li>线程池可以解决线程生命周期的系统开销问题，线程池里的线程可以复用，消除了线程创建带来的延迟，从而提高响应速度。</li>
<li>线程池可以统筹内存和CPU的使用，避免资源的使用不当。</li>
<li>线程池可以统一管理资源。</li>
</ol>
<h4 id="2-5-线程池各参数的含义"><a href="#2-5-线程池各参数的含义" class="headerlink" title="2.5 线程池各参数的含义"></a>2.5 线程池各参数的含义</h4><p><img data-src="../../../../assets/img/CgoB5l3eH8mAAoJCAACEOKMHtpw036.png" alt></p>
<p><img data-src="../../../../assets/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt></p>
<p><strong>线程池的特点：</strong></p>
<ol>
<li>线程池希望保持较少的线程数，只有在负载变的很大时才增加线程。</li>
<li>线程池只有在任务队列满时才会创建多于corePoolSize的线程，如果使用的是无界队列(如LinkedBlockingQueue)，线程数不会超过corePoolSize。</li>
<li>设置corePoolSize和maxPoolSize为相同的值，可以创建固定大小的线程池。</li>
</ol>
<h4 id="2-6-线程池有哪几种拒绝策略？"><a href="#2-6-线程池有哪几种拒绝策略？" class="headerlink" title="2.6 线程池有哪几种拒绝策略？"></a>2.6 线程池有哪几种拒绝策略？</h4><p><img data-src="../../../../assets/img/CgotOV3g0WWAVWVlAAEsBI6lEEA162.png" alt></p>
<ul>
<li>AbortPolicy：拒绝任务时直接抛出一个类型为RejectedExecutionException的RuntimeException，可以感知到任务被拒绝了，可以根据业务逻辑选择重试或放弃提交等。</li>
<li>DiscardPolicy：当新任务被提交后直接被丢弃掉，不会有任何通知。</li>
<li>DiscardOldestOlicy：丢弃任务队列的头节点，通常是存活时间最长的任务，也不会有任何通知。</li>
<li>CallerRunsPolicy：把任务交给提交任务的线程执行，即谁提交任务，谁就负责执行任务。<ol>
<li>提交的任务不会被丢弃</li>
<li>提交任务的线程负责执行任务，提交任务的线程被占用，不会再提交新的任务，线程池中的线程也可以利用这段时间执行掉一部分任务，相当于是给了线程池一定的缓冲期。</li>
</ol>
</li>
</ul>
<h4 id="2-7-有哪6种常见的线程池？什么是Java8的ForkJoinPool"><a href="#2-7-有哪6种常见的线程池？什么是Java8的ForkJoinPool" class="headerlink" title="2.7 有哪6种常见的线程池？什么是Java8的ForkJoinPool?"></a>2.7 有哪6种常见的线程池？什么是Java8的ForkJoinPool?</h4><ul>
<li><p>FixedThreadPool</p>
<p>核心线程数和最大线程数是一样的，可以看作是固定线程数的线程池，没有可用的线程的时候，任务会放在队列中等待，任务的长度无限制(LinkedBlockingQueue)</p>
</li>
<li><p>CachedThreadPool</p>
<p>线程数几乎可以无限增加(Integer.MAX_VALUE，2^31-1)，该线程池的线程数量不固定，不够使用时自动增加，闲置时自动回收。队列为SynchronousQueue，队列容量为0，实际不存储任务，只对任务进行中转和传递。</p>
</li>
<li><p>ScheduledThreadPool</p>
<p>支持定时或周期的执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//延迟指定时间后执行一次任务，10秒执行一次</span></span><br><span class="line">service.schedule(<span class="keyword">new</span> Task(), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//以固定的频率执行任务</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Task(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//与第二种类似，不过scheduledAtFixedRate以开始时间为起点，时间到就开始第二次，而scheduledWithFixedDelay以任务结束时间为下一次循环的时间起点开始计算</span></span><br><span class="line">service.scheduleWithFixedDelay(<span class="keyword">new</span> Task(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor</p>
<p>原理与FixedThreadPool一样，线程只有一个，如果线程在执行过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。适合用于任务需要按被提交的顺序依次执行的场景。</p>
</li>
<li><p>SingleThreadScheduledExecutor</p>
<p>于ScheduledThreadPool类似，如源码所示：只是将ScheduledThreadPool的核心线程数设置为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/CgoB5l3kzomAckv5AAAxf6FCPco696.png" alt></p>
</li>
<li><p>ForkJoinPool</p>
</li>
</ul>
<h4 id="2-8-线程池常用的阻塞队列"><a href="#2-8-线程池常用的阻塞队列" class="headerlink" title="2.8 线程池常用的阻塞队列"></a>2.8 线程池常用的阻塞队列</h4><p><img data-src="../../../../assets/img/Cgq2xl3nUryAJBkpAAA0_WFSrB8184.png" alt></p>
<ul>
<li><p>LinkedBlockingQueue</p>
<p>对于FixedThreadPool和SingleThreadExector，它们使用的是容量为Integer.MAX_VALUE的LinkedBlockingQueue，可以任务是无界队列。</p>
</li>
<li><p>SynchronousQueue</p>
<p>对于CachedThreadPool，最大线程数为Integer.MAX_VALUE，所以不需要任务队列来存储任务，一旦有任务提交就直接转发给线程或创建新线程来执行。</p>
</li>
<li><p>DelayedWorkQueue</p>
<p>对于ScheduledThreadPool和SingleThreadScheduledExecutor，DelayedWorkQueue内部元素并不是按照放入的时间排序，而是按照延迟的时间长短对任务进行排序，内部采用的是”堆”的数据结构。</p>
</li>
</ul>
<h4 id="2-9-为什么不应该自动创建线程池？"><a href="#2-9-为什么不应该自动创建线程池？" class="headerlink" title="2.9 为什么不应该自动创建线程池？"></a>2.9 为什么不应该自动创建线程池？</h4><ul>
<li><p>FixedThreadPool、SingleThreadPool</p>
<p>使用的队列是没有上限的LinkedBlockingQueue，如果处理任务过慢，队列中堆积的任务会越来越多，占用大量内存，导致OOM。</p>
</li>
<li><p>CachedThreadPool</p>
<p>不限制线程的数量，任务特别多时，有可能会创建非常多的线程，最终导致超过了操作系统的上限而无法创建线程，或导致内存不足。</p>
</li>
<li><p>ScheduledThreadPool、SingleThreadScheduledExecutor</p>
<p>DelayedWorkQueue也是一个无界队列。</p>
</li>
</ul>
<h4 id="2-10-合适的线程数是多少？"><a href="#2-10-合适的线程数是多少？" class="headerlink" title="2.10 合适的线程数是多少？"></a>2.10 合适的线程数是多少？</h4><ul>
<li><p>CPU密集型任务</p>
<p>如加密、解密、压缩、计算等大量耗费CPU资源的任务，线程数为CPU核心数的1-2倍。</p>
</li>
<li><p>耗时IO型任务</p>
<p>如数据库、文件的读写、网络通信等并不消耗CPU资源的任务，线程数=CPU核心数*(1+平均等待时间/平均工工作时间)</p>
</li>
</ul>
<p>线程的平均工作时间所占比例越高，就需要越少的线程。线程的平均等待时间所占比例越高，就需要越多的线程。</p>
<h4 id="2-11-如何正确关闭线程？"><a href="#2-11-如何正确关闭线程？" class="headerlink" title="2.11 如何正确关闭线程？"></a>2.11 如何正确关闭线程？</h4><ul>
<li><p>shutdown()</p>
<p>安全的关闭的一个线程池，调用shutdown()之后，如果还有新任务被提交，线程池会根据拒绝策略直接拒绝后续提交的任务，执行完正在执行的任务和队列中等待的任务后关闭。</p>
</li>
<li><p>isShutdown()</p>
<p>判断线程是否已经开始了关闭工作，即是否执行了shutdown()或shutdownNow()</p>
</li>
<li><p>isTerminated()</p>
<p>检测线程池是否真正”终结”了，即线程池已关闭，同时线程池中的所有任务都执行完毕了。</p>
</li>
<li><p>awaitTermination()</p>
<p>判断线程池状态，如给awaitTermination方法传入的参数为10秒，那么它会陷入10秒等待，直到</p>
<ol>
<li>等待期间(包括进入等待之前)，线程池已关闭并所有任务都执行完毕，相当于线程池”终结”了，方法便返回true。</li>
<li>等待超时时间到后，线程池始终未”终结”，返回false。</li>
<li>等待期间线程被中断，方法抛出InterruptedException异常。</li>
</ol>
<p>即调用awaitTermination方法后当前线程池会尝试等待一定指定的时间，如果在等待时间内，线程池已关闭并任务都执行完毕，方法返回true，否则返回false。</p>
</li>
<li><p>shutdownNow()</p>
<p>立刻关闭，执行shutdownNow()方法之后，首先会给线程池中的线程发送interrupt中断信号，尝试中断这些任务的执行，然后会将等待的所有任务转移到一个List中并返回。</p>
</li>
</ul>
<h3 id="3-各种各样的”锁”"><a href="#3-各种各样的”锁”" class="headerlink" title="3.各种各样的”锁”"></a>3.各种各样的”锁”</h3><h4 id="3-1-你知道哪几种锁？分别有什么特点？"><a href="#3-1-你知道哪几种锁？分别有什么特点？" class="headerlink" title="3.1 你知道哪几种锁？分别有什么特点？"></a>3.1 你知道哪几种锁？分别有什么特点？</h4><ol>
<li><p><strong>偏向锁/轻量级锁/重量级锁</strong></p>
<p>特指synchronized锁的状态，通过在对象头中的mark word来表明锁的状态。</p>
<ul>
<li><p>偏向锁</p>
<p>如果，这把锁一直不存在竞争，就没必要上锁，只需打个标记就行。对象被初始化，还没有线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获取锁，开销很小，性能最好。</p>
</li>
<li><p>轻量级锁</p>
<p>synchronized中的代码是被多个线程交替执行的，并不存在实际的竞争、或只有短时间的竞争，用<strong>CAS</strong>就可以解决。轻量级锁是指当锁原来是偏向锁时，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过<strong>自旋</strong>的形式获取锁，而不会陷入阻塞。</p>
</li>
<li><p>重量级锁</p>
<p>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，开销相对较大。当多个线程直接实际竞争，且锁竞争时间长的时候，锁就会膨胀为重量级锁。<strong>重量级锁会让其它申请缺拿不到锁的线程进入到阻塞状态。</strong></p>
</li>
</ul>
<p>偏向锁性能最好，可以避免执行CAS操作。而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p>
</li>
<li><p><strong>可重入锁/不可重入锁</strong></p>
<p>可重入锁指的是线程当前已经持有这把锁了，能在不释放这个锁的情况下，再次获取这把锁。不可重入锁指的是虽然当前持有了这把锁，但如果想再次获取此锁，也必须先要释放锁后才能再次尝试获取。</p>
</li>
<li><p><strong>共享锁/独占锁</strong></p>
<p>共享锁指同一把锁可以被多个线程同时获得，而独占锁指这个锁只能同时被一个线程获得。如读写锁中的读锁是共享锁，而写锁是独占锁。</p>
</li>
<li><p><strong>公平锁/非公平锁</strong></p>
<ul>
<li><p>公平锁</p>
<p>如果线程现在拿不到这把锁，那么线程都会进入等待，开始排队，在等待队列等待时间长的线程会优先拿到这把锁，先来先得。</p>
</li>
<li><p>非公平锁</p>
<p>在一定情况下，忽略掉已经在排队的线程，发生插队现象。</p>
</li>
</ul>
</li>
<li><p><strong>悲观锁/乐观锁</strong></p>
<ul>
<li><p>悲观锁</p>
<p>在获取资源之前，必须先拿到锁，以便达到”独占”的状态。</p>
</li>
<li><p>乐观锁</p>
<p>并不要求在获取资源前拿到锁，也不会锁住资源，利用CAS理念，在不独占资源的情况下，完成对资源的修改。</p>
</li>
</ul>
</li>
<li><p><strong>自旋锁/非自旋锁</strong></p>
<ul>
<li><p>自旋锁</p>
<p>如果线程现在拿不到锁，并不直接陷入阻塞或者释放CPU资源，而是开始利用循环，不停的尝试获取锁。</p>
</li>
<li><p>非自旋锁</p>
<p>拿不到锁就直接放弃，或者进行其它的处理逻辑，如阻塞、排队等。</p>
</li>
</ul>
</li>
<li><p><strong>可中断锁/不可中断锁</strong></p>
<p>synchronized关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路，只能等拿到锁以后才能进行其它的逻辑处理。</p>
<p>ReentrantLock是一种典型的可中断锁，如使用lockInterruptibly方法在获取锁的过程中，突然不想获取了，可以在中断之后去做其它的事。</p>
</li>
</ol>
<h4 id="3-2-悲观锁与乐观锁"><a href="#3-2-悲观锁与乐观锁" class="headerlink" title="3.2 悲观锁与乐观锁"></a>3.2 悲观锁与乐观锁</h4><ul>
<li><p><strong>悲观锁</strong></p>
<p>为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问。</p>
<p>线程A拿到了锁，并且正在操作同步资源，那么此时线程B就必须进行等待。</p>
<p><img data-src="../../../../assets/img/Cgq2xl38fTSAE0T3AABXxHZ9Gus225.png" alt></p>
<p>当线程A执行完毕后，CPU才会唤醒正在等待这把锁的线程B再次尝试获取锁</p>
<p><img data-src="../../../../assets/img/Cgq2xl38fTSALLQ8AABbKYnu-eg621.png" alt></p>
<p>如果线程B获取到了锁，才可以对同步资源进行自己的操作。</p>
<p><img data-src="../../../../assets/img/CgpOIF38fTSAPYuRAABkLHzXEVA431.png" alt></p>
</li>
<li><p><strong>乐观锁</strong></p>
<p>认为自己在操作资源的时候不会有其他线程干扰，所以并不会锁住被操作对象。为了确保数据正确性，在更新之前，会去对比在修改数据期间，数据有没有被其他线程修改过。</p>
<p><img data-src="../../../../assets/img/Cgq2xl38fqeACYJNAACQDeJBU58075.png" alt></p>
<p>例子：</p>
<ul>
<li><p>悲观锁：synchronized关键字和Lock接口</p>
<p>以Lock接口为例，如Lock的实现类ReentrantLock，类中的lock()等方法就是执行加锁，而unlock()方法就是执行解锁()。处理资源之前必须要先加锁并拿到锁，等到处理完之后再解开锁。</p>
</li>
<li><p>乐观锁：原子类</p>
<p>如AtomicInteger在更新数据时，多个线程可以同时操作同一个原子变量。</p>
</li>
</ul>
<p><strong>两种锁各自的使用场景：</strong></p>
<ul>
<li>悲观锁适合于并发写入多、临界区代码复杂、竞争激烈等场景，此时悲观锁可以避免大量的无用的反复尝试等消耗。</li>
<li>乐观锁适用于读取多，修改少的场景，也适合虽然读写都很多，但是并发不激烈的场景。</li>
</ul>
</li>
</ul>
<h4 id="3-3-synchronized背后的monitor锁"><a href="#3-3-synchronized背后的monitor锁" class="headerlink" title="3.3 synchronized背后的monitor锁"></a>3.3 synchronized背后的monitor锁</h4><p>获取和释放monitor锁的时机：线程在进入synchronized保护的代码块之前，会自动获取锁；并且无论是正常退出，还是抛出异常退出，在退出的时候都会自动释放锁。</p>
<p>查看反汇编命令：javac SynTest.java    javap -verbose SynTest.class</p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">           ......</span><br><span class="line"><span class="number">3</span>: monitorenter</span><br><span class="line">           4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">           7: ldc           #3                      // String lagou</span><br><span class="line">           9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">          <span class="number">12</span>: aload_1</span><br><span class="line">          <span class="number">13</span>: monitorexit</span><br><span class="line">          <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">          <span class="number">17</span>: astore_2</span><br><span class="line">          <span class="number">18</span>: aload_1</span><br><span class="line">          <span class="number">19</span>: monitorexit</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>monitorenter可以理解为加锁，monitorexit理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未锁定的对象的该计数器未0。</p>
<ul>
<li><p>monitorenter</p>
<ol>
<li>如果该monitor的计数为0，则线程获得该monitor并将其计数设置为1，该线程就是这个monitor的所有者。</li>
<li>如果线程已经拥有了这个monitor，则它将重新进入，并且累加计数。</li>
<li>如果其他线程已经拥有了这个monitor，那么这个线程就会被阻塞，直到这个monitor的计数器变为0，代表这个monitor已经被释放了，于是当前这个线程就会再次尝试获取这个monitor。</li>
</ol>
</li>
<li><p>monitorexit</p>
<p>作用：将monitor的计数器减1，直到减为0为止。代表这个monitor已经被释放了，已经没有任何线程拥有它了，也就代表着解锁。其他正在等待这个monitor的线程，此时可以再次尝试获取这个monitor的所有权。</p>
</li>
</ul>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>;</span><br><span class="line">      descriptor: ()V</span><br><span class="line">      flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">        Code:</span><br><span class="line">          stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>被synchronized修饰的方法会有一个ACC_SYNCHRONIZED标志，当某个线程要访问某个方法时，会首先检查方法是否有ACC_SYNCHRONIZED标志，如果有则需要先获得monitor锁，方法执行之后再释放monitor锁。</code></pre><h4 id="3-4-synchronized与Lock"><a href="#3-4-synchronized与Lock" class="headerlink" title="3.4 synchronized与Lock"></a>3.4 synchronized与Lock</h4><ul>
<li><p>相同点</p>
<ol>
<li>synchronized和Lock都是用来保护资源线程安全的</li>
<li>都可以保证可见性</li>
<li>synchronized和ReentrantLock(Lock的一个实现类)都拥有可重入的特点</li>
</ol>
</li>
<li><p>不同点</p>
<ol>
<li><p>用法区别</p>
<p>synchronized关键字可以加在方法上，不需要指定锁对象(此时的锁对象为this)；也可以修饰同步代码块并且自定义monitor对象。而Lock锁对象必须显示的开始加锁lock()和解锁unlock()，并且一般会在finally块中确保用unlock()来解锁，以防止发生死锁。</p>
</li>
<li><p>加解锁顺序不同</p>
<p>对于Lock而言如果有多把Lock锁，Lock可以不完全按照加锁的反序解锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">lock2.lock();</span><br><span class="line">...</span><br><span class="line">lock1.unlock();</span><br><span class="line">lock2.unlock();</span><br></pre></td></tr></table></figure>

<p>synchronized解锁的顺序和加锁的顺序必须完全相反，obj2先解锁，obj1后解锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized锁不够灵活</p>
<p>一旦synchronized锁已经被某个线程获得了，此时其他线程如果还想获得，那么它只能被阻塞，直到持有锁的线程运行完毕或发生异常从而释放这个锁。Lock类在等待锁的过程中，如果使用的时lockInterruptibly方法，如果等待时间太长，可以中断退出，也可以使用tryLock()等方法尝试获取锁，如果获取不到可以执行其他逻辑。</p>
</li>
<li><p>synchronized锁只能同时被一个线程拥有，但Lock锁没有这个限制。</p>
<p>如在读写锁中的读锁，是可以被多个线程同时拥有的，但synchronized不行。</p>
</li>
<li><p>原理区别</p>
<p>synchronized是内置锁，由JVM实现获取锁和解锁，还分为偏向锁、轻量级锁、重量级锁。Lock根据实现不同，原理也不同，如ReentrantLock内部是通过AQS来获取和释放锁的。</p>
</li>
<li><p>是否可以设置公平/非公平</p>
<p>ReentrantLock可以根据需求来设置公平或非公平，synchronized则不能设置。</p>
</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li>最好既不使用Lock也不使用synchronized，尽量使用java.util.concurrent包中的机制。</li>
<li>尽量使用synchronized，避免忘记在finally里忘记unlock。</li>
<li>需要Lock的特殊功能时，如尝试获取锁、可中断、超时功能等，才使用Lock。</li>
</ol>
</li>
</ul>
<h4 id="3-5-Lock的常用方法"><a href="#3-5-Lock的常用方法" class="headerlink" title="3.5 Lock的常用方法"></a>3.5 Lock的常用方法</h4><ul>
<li><p>lock()</p>
<p>在线程获取锁时如果锁已被其他线程获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取到了被本锁保护的资源，处理任务</span></span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock()</p>
<p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false，代表获取锁失败，可以根据是否能获取到锁来决定后续程序行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock(long time, TimeUnit unit)</p>
<p>和tryLock()类似，tryLock(long time, TimeUnit unit)会有一个超时时间，在拿不到锁时会等待一定的时间，时间期限结束后，还获取不到锁，就会返回false，如果在最开始或等待期间内获取到锁就返回true。</p>
</li>
<li><p>lockInterruptibly()</p>
<p>除非当前线程在获取锁期间被中断，否则会一直尝试获取直到获取到为止。相当于超时时间无限长的tryLock(long time, TimeUnit unit)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              lock.lockInterruptibly();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">"操作资源"</span>);</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unlock()</p>
<p>用于解锁，对ReentrantLock而言，执行unlock()的时候，内部会把锁的”被持有计数器”减1，直到减到0就代表当前这把锁已经完全释放了，如果减1后计数器不为0，说明这把锁之前被”重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。</p>
</li>
</ul>
<h4 id="3-6-公平锁与非公平锁"><a href="#3-6-公平锁与非公平锁" class="headerlink" title="3.6 公平锁与非公平锁"></a>3.6 公平锁与非公平锁</h4><p>公平锁：按照线程请求顺序来分配锁</p>
<p>非公平锁：不完全按照请求的顺序，在一定情况下，可以允许插队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairAndUnfair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);<span class="comment">//false:非公平锁 true:公平锁 默认false</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span> </span>&#123;</span><br><span class="line">            queueLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10000</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job during %d seconds\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(), (duration / <span class="number">1000</span>));</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                queueLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queueLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10000</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job during %d seconds\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(), (duration / <span class="number">1000</span>));</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                queueLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s: Going to print a job\n"</span>, Thread.currentThread().getName());</span><br><span class="line">            printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.printf(<span class="string">"%s: The document has been printed\n"</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平情况下，存在抢锁”插队”现象，如Thread 0 在释放锁后又能优先获取到锁，虽然此时在等待队列中已经有Thread 1~Thread 9在排队了。</p>
<p><strong>各自的优缺点</strong></p>
<p><img data-src="../../../../assets/img/CgpOIF4Jsh6AbVZ-AAB_Y_MH7f4077.png" alt></p>
<p><strong>源码分析</strong></p>
<p>ReentrantLock中包含一个Sync类，这个类继承自AQS(AbstractQueuedSynchronizer)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure>

<p>Sync有公平锁FairSync和非公平锁NonfairSync两个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁与非公平获取锁的lock()方法唯一区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors()为false，这个方法就是在判断在等待队列中是否已经有线程在排队了。公平锁，一旦有线程在排队，当前线程就不再尝试获取锁了；对于非公平锁，无论是否有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。</p>
<p>tryLock()，一旦有线程释放了锁，那么正在tryLock的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，即tryLock可以插队。调用的是nonfairTryAcquire()，表明是不公平的，和锁本身是否公平锁无关。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-读写锁"><a href="#3-7-读写锁" class="headerlink" title="3.7 读写锁"></a>3.7 读写锁</h4><p>保证多个线程同时读的效率，同时可以保证有写入操作时的线程安全。</p>
<p><strong>读写锁的获取规则</strong></p>
<ol>
<li>如果一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为<strong>读写不能同时操作</strong>。</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或读锁，都必须等待之前的线程释放锁，因为<strong>读写、写写不能同时操作</strong>。</li>
</ol>
<p>要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。即读读共享，其他都互斥。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到读锁，正在读取"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放读锁"</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到写锁，正在写入"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放写锁"</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread<span class="number">-0</span>得到读锁，正在读取</span><br><span class="line">Thread<span class="number">-1</span>得到读锁，正在读取</span><br><span class="line">Thread<span class="number">-0</span>释放读锁</span><br><span class="line">Thread<span class="number">-1</span>释放读锁</span><br><span class="line">Thread<span class="number">-2</span>得到写锁，正在写入</span><br><span class="line">Thread<span class="number">-2</span>释放写锁</span><br><span class="line">Thread<span class="number">-3</span>得到写锁，正在写入</span><br><span class="line">Thread<span class="number">-3</span>释放写锁</span><br></pre></td></tr></table></figure>

<p>读写锁适用于读多写少的情况</p>
<h4 id="3-8-读锁应该插队么？什么是读写锁的升降级？"><a href="#3-8-读锁应该插队么？什么是读写锁的升降级？" class="headerlink" title="3.8 读锁应该插队么？什么是读写锁的升降级？"></a>3.8 读锁应该插队么？什么是读写锁的升降级？</h4><ul>
<li><p>公平锁</p>
<p>只要等待队列中有线程在等待，即hasQueueedPredecessors()返回true的时候，那么write和reader都会block，即不允许插队。</p>
</li>
<li><p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁：随时可以插队</p>
<p>读锁：</p>
<ol>
<li><p>允许插队</p>
<p><img data-src="../../../../assets/img/Cgq2xl4O9F2AR8XVAACUtGWSKRc535.png" alt></p>
<p>有可能导致需要拿到写锁的线程会陷入”饥饿”状态，它将在长时间内得不到执行。</p>
</li>
<li><p>不允许插队</p>
<p>即使是非公平锁，只要<strong>等待队列的头结点是尝试获取写锁的线程，那么读锁依然不能插队</strong>，目的是避免”饥饿”。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLockJumpQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到读锁，正在读取"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放读锁"</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到写锁，正在写入"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"释放写锁"</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">"Thread-2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">"Thread-4"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; write(), <span class="string">"Thread-3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; read(), <span class="string">"Thread-5"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Thread<span class="number">-2</span>得到读锁，正在读取</span><br><span class="line">Thread<span class="number">-4</span>得到读锁，正在读取</span><br><span class="line">Thread<span class="number">-2</span>释放读锁</span><br><span class="line">Thread<span class="number">-4</span>释放读锁</span><br><span class="line">Thread<span class="number">-3</span>得到写锁，正在写入</span><br><span class="line">Thread<span class="number">-3</span>释放写锁</span><br><span class="line">Thread<span class="number">-5</span>得到读锁，正在读取</span><br><span class="line">Thread<span class="number">-5</span>释放读锁</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>锁的升降级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">//在获取写锁之前，必须首先释放读锁。</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里需要再次判断数据的有效性,因为在我们释放读锁和获取写锁的空隙之内，可能有其他线程修改了数据。</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = <span class="keyword">new</span> Object();</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在不释放写锁的情况下，直接获取读锁，这就是读写锁的降级。</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放了写锁，但是依然持有读锁</span></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一处修改数据的代码，后面都是读取，如果一直使用写锁的话，就不能让多个线程同时来读取了，这个时候利用锁的降级，可以提高整体性能。</p>
<p><strong>支持锁的降级，不支持升级</strong></p>
<p>ReentrantReadWriteLock不支持读锁升级到写锁。</p>
<p>不可能有读锁和写锁同时持有的情况，升级写锁的过程中，需要等到所有的读锁都释放才能升级。另一种特殊情况，线程A、B都想升级到写锁，对于A而言，它需要等待其他线程(包括B)释放读锁，而线程B也是如此，则会发生死锁。</p>
<h4 id="3-9-自旋锁"><a href="#3-9-自旋锁" class="headerlink" title="3.9 自旋锁"></a>3.9 自旋锁</h4><p><img data-src="../../../../assets/img/Cgq2xl4S44OAXtbZAAG7wulxruI786.png" alt></p>
<p>非自旋锁和自旋锁最大的区别，如果它遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒；而自旋锁会不停地尝试。</p>
<p><strong>自旋锁的好处</strong></p>
<p>自旋锁用循环去不停地尝试获取锁，让线程始终处于Runnable状态，节省了线程切换带来的开销。</p>
<p>自己实现可重入的自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="comment">// 重入次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == owner.get()) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="keyword">null</span>, currentThread)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"自旋了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能解锁</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == owner.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此处无需CAS操作，因为没有竞争，因为只有线程持有者才能解锁</span></span><br><span class="line">                owner.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantSpinLock spinLock = <span class="keyword">new</span> ReentrantSpinLock();</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始尝试获取自旋锁"</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取到了自旋锁"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"释放了了自旋锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>开始尝试获取自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>开始尝试获取自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>获取到了自旋锁</span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line"><span class="params">...</span><span class="params">...</span></span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>获取到了自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>释放了了自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>释放了了自旋锁</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<p>虽然避免了线程切换的开销，但带来了新的开销，因为它需要不停地去尝试获取锁。</p>
<p><strong>适用场景</strong></p>
<p>自旋锁适用于并发度不是特别高，以及临界区比较短小的情况，这样可以避免线程切换来提高效率。可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不适合自旋锁，因为自旋会一直占用CPU却无法拿到锁，白白消耗资源。</p>
<h4 id="3-10-JVM对锁的优化"><a href="#3-10-JVM对锁的优化" class="headerlink" title="3.10 JVM对锁的优化"></a>3.10 JVM对锁的优化</h4><ul>
<li><p>自适应的自旋锁</p>
<p>自旋的缺点在于如果自旋时间过长，那么性能开销很大，浪费CPU资源。自适应意味着自旋的时间不再固定，而是根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。如：最近尝试自旋获取某一把锁成功了，那么下次可能还会继续使用自旋，并且允许自旋更长时间；但如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。</p>
</li>
<li><p>锁消除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是被synchronized修饰的同步方法，因为它可能会被多个线程同时使用。但在大多数情况下，它只会在一个线程内使用，如果编译器能确定这个StringBuffer只会在一个线程内使用，那么编译器便会做出优化，把synchronized消除，省去加锁和解锁，以便增加整体的效率。</p>
</li>
<li><p>锁粗化</p>
<p>如果释放了锁，紧接着什么都没做，又重新获取锁，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把同步区域扩大，即最开始加一次锁，并且在最后直接解锁，减少性能开销。</p>
<p>如果在循环中也这样做，会导致其他线程长时间无法获得锁。锁粗化的功能默认打开，用-XX:-EliminateLocks可以关闭该功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>偏向锁/轻量级锁/重量级锁</p>
<p>这三种锁是特指synchronized锁的状态的，通过对象头中的mark word来表明锁的状态。</p>
<ul>
<li><p>偏向锁</p>
<p>这把锁自始至终不存在竞争，那么没必要上锁，只要打个标记就行了。一个对象被初始化后，如果还没有任何线程来获取它的锁，它就是可偏向的，当第一个线程来访问它尝试获取锁的时候，它就记录下来这个线程，如果后面尝试获取锁的线程正是这个偏向锁的拥有者，就可以直接获取锁，开销小。</p>
</li>
<li><p>轻量级锁</p>
<p>synchronized中的代码块是被多个线程交替执行的，也就是不存在实际的竞争，或者只有短时间的竞争，用CAS就可以解决。轻量级锁指当锁原来是偏向锁的时候，被另一线程所访问，说明存在竞争，那么偏向锁升级为轻量级锁，线程会通过自旋的方式尝试获取锁，不会阻塞。</p>
</li>
<li><p>重量级锁</p>
<p>当多个线程直接有实际竞争，并且锁竞争时间比较长的时候，此时偏向锁和轻量级锁都不能满足需求，锁就会膨胀为重量级锁，会让其他申请却拿不到锁的线程进入阻塞状态。</p>
</li>
</ul>
<p><img data-src="../../../../assets/img/CgpOIF4VUHSAFpAZAAANfyy0aXE323.png" alt></p>
</li>
</ul>
<h4 id="3-10-HashMap为什么是线程不安全的？"><a href="#3-10-HashMap为什么是线程不安全的？" class="headerlink" title="3.10 HashMap为什么是线程不安全的？"></a>3.10 HashMap为什么是线程不安全的？</h4><ul>
<li><p>扩容期间取出的值不准确</p>
<p>HashMap扩容期间，会新建一个新的空数组，并用旧的项填充到这个新的数组中。如果这个填充的过程中，如果有线程取值，很可能会取到null值。</p>
</li>
<li><p>同时put碰撞导致数据丢失</p>
<p>如果有多个线程同时put，而且恰好两个put的key是一样的，它们发生了碰撞，也就是根据hash值计算出来的bucket位置一样，并且两个线程又同时判断该位置是空的，可以写入，所以这两个线程的两个不同的value便会添加到数组的同一位置，就丢失了一个数据。</p>
</li>
<li><p>可见性问题</p>
<p>线程1给某个key放入了一个新值，那么线程2在获取对应的key的值的时候，它的可见性是无法保证的。</p>
</li>
<li><p>死循环造成CPU100%</p>
<p>在扩容的时候，也就是内部新建新的HashMap的时候，扩容的逻辑会反转散列桶中的节点顺序，当多个线程同时进行扩容的时候，如果两个线程同时反转的话，便可能形成一个循环，并且这种循环是链表的循环，相当于A节点指向B节点，B节点又指回A节点，在下一次想要获取该key所对应的value的时候，便会在遍历链表的时候发生永远无法遍历结束的情况。</p>
</li>
</ul>
<h4 id="3-11-为什么Map桶中超过8个才转为红黑树？"><a href="#3-11-为什么Map桶中超过8个才转为红黑树？" class="headerlink" title="3.11 为什么Map桶中超过8个才转为红黑树？"></a>3.11 为什么Map桶中超过8个才转为红黑树？</h4><p>最开始的Map是空的，因为里面没有任何元素，往里放元素时会计算hash值，计算之后，第1个个value会占用一个桶(也称为槽点)位置，后续经过计算键值key计算hash值得到插入的数组索引i相同，那么会使用链表的形式往后延长，俗称拉链法。当链表长度大于或等于阈值(默认为8)，且数组长度大于或等于MIN_TREEIFY_CAPACITY(默认64)时，就会把链表转为红黑树。当红黑树的节点小于或等于6个以后，又会恢复为链表形态。</p>
<p><img data-src="../../../../assets/img/CgpOIF4ejCmAPqZMAAGZw5NzqtE067.png" alt></p>
<ol>
<li><p>链表查找时间复杂度：O(n)    红黑树查找时间复杂度：O(log(n))</p>
</li>
<li><p>单个TreeNode需要占用的空间大约是Node的两倍</p>
<p><strong>时间与空间的平衡</strong></p>
</li>
</ol>
<p>如果hash计算结果离散的好，各个值都均匀分配，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为8时，概率仅为0.00000006，小于千万分之一概率，通常情况下并不会发生链表向红黑树的转换。</p>
<p>链表长度为8转为红黑树的设计，为了防止自定义实现了不好的hash算法导致链表长度过长，从而导致查询效率低。</p>
<h4 id="3-12-Hashtable与ConcurrentHashMap的区别"><a href="#3-12-Hashtable与ConcurrentHashMap的区别" class="headerlink" title="3.12 Hashtable与ConcurrentHashMap的区别"></a>3.12 Hashtable与ConcurrentHashMap的区别</h4><ol>
<li><p>出现版本不同</p>
<p>Hashtable在JDK1.0就存在了，并在JDK1.2实现了Map接口；ConcurrentHashMap在JDK1.5中才出现。</p>
</li>
<li><p>实现线程安全的方式不同</p>
<p>Hashtable通过<strong>synchronized</strong>关键字实现线程安全；ConcurrentHashMap利用了<strong>CAS+synchronized+Node(volatile)</strong>。</p>
</li>
<li><p>性能不同</p>
<p>随着线程数量的增加，Hashtable性能会急剧下降，每一次修改会锁住整个对象，而其他线程在此期间不能操作，还会带来额外的上下文切换；ConcurrentHashMap只会对一部分上锁而不是全部都上锁。</p>
</li>
<li><p>迭代时的修改不同</p>
<p><strong>Hashtable(包括HashMap)不允许在迭代期间修改内容</strong>，否则会抛出ConcurrentModificationException异常，ConcurrentHashMap不会。</p>
</li>
</ol>
<h4 id="3-13-CopyOnWriteArrayList"><a href="#3-13-CopyOnWriteArrayList" class="headerlink" title="3.13 CopyOnWriteArrayList"></a>3.13 CopyOnWriteArrayList</h4><p>ArrayList    LinkedList</p>
<p>线程安全：Vector    Collections.synchronized()</p>
<p><strong>Vector内部使用synchronized来保证线程安全</strong>，并且锁的粒度比较大，都是方法级别的锁，在并发高的时候，很容易发生竞争，并发效率相对较低。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>读操作可以尽可能的快，而写即使慢一些也没关系</li>
<li>读多写少</li>
</ul>
<p><strong>读写规则：</strong></p>
<p>读写锁的思想是：读读共享，其他都互斥，因为读操作不会修改原有的数据，因此并发读不会有安全问题；而写操作发生时，不允许读和写操作加入。CopyOnWriteArrayList读取是完全不用加锁的，并且写入也不会阻塞读取操作，也就是说可以在写入的同时进行读取，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但可以在写入时允许读取发生。</p>
<p> <strong>特点：</strong></p>
<ul>
<li><p>CopyOnWrite</p>
<p>当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行Copy，复制出一个新容器，然后修改新的容器，完成修改之后，再将容器的引用指向新的容器。读写分离的思想，读和写使用不同的容器。</p>
</li>
<li><p>迭代期间允许修改集合内容</p>
<p>ArrayList源码里的ListItr的next()方法中有一个checkForComodification()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modCount是保存修改次数，每次调用add、remove时都会增加，expectedComodification是迭代器的变量，创建迭代器时会初始化并记录当时的modCount，后面迭代期间如果发现modCount和expectedModCount不一致，就会抛出异常。CopyOnWriteArrayList的迭代器在迭代时，迭代器使用的依然是原数组，只不过迭代器的内容可能已经过时了。CopyOnWrite的迭代器一旦被建立，如果往之前的CopyOnWriteArrayList对象中去新增元素，在迭代器中既不会显示出元素的变更情况，同时也不会报错。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>内存占用问题</p>
</li>
<li><p>在元素较多或者复杂的情况下，复制的开销很大</p>
</li>
<li><p>数据一致性问题</p>
<p>由于CopyOnWrite容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。</p>
</li>
</ul>
<p><strong>源码分析：</strong></p>
<ul>
<li><p>数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 可重入锁对象 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** CopyOnWriteArrayList底层由数组实现，volatile修饰，保证数组的可见性 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化CopyOnWriteArrayList相当于初始化数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>add()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到原数组的长度和元素</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">       <span class="comment">// 复制出一个新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加时，将新元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将volatile Object[] array 的指向替换成新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加的时候首先上锁，并复制一个新数组，增加操作在新数组上完成，然后将array指向到新数组，最后解锁。上面的步骤实现了CopyOnWrite的思想：<strong>写操作是在原来容器的拷贝上进行的，并且在读取数据的时候不会锁住list。如果对容器拷贝操作的过程中有新的读线程进来，那么读到的还是旧的数据，因为那个时候对象的引用还没有被更改。</strong></p>
</li>
<li><p><strong>迭代器 COWIterator 类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>snapshot：数组的快照，即创建迭代器那个时刻的数组情况</p>
<p>cursor：迭代器的游标</p>
<p>迭代器在被构建的时候，会把当时的elements赋值给snapshot，而之后的迭代器所有的操作都基于snapshot数组进行的，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，返回的内容是snapshot对象，所以，后续就算原数组被修改，这样snapshot既不会感知到，也不会受影响，<strong>执行迭代操作不需要加锁，也不会因此抛出异常。迭代器返回的结果，和创建迭代器的时候内容一致。</strong></p>
</li>
</ul>
<h3 id="4-阻塞队列"><a href="#4-阻塞队列" class="headerlink" title="4.阻塞队列"></a>4.阻塞队列</h3><h4 id="4-1-什么是阻塞队列？"><a href="#4-1-什么是阻塞队列？" class="headerlink" title="4.1 什么是阻塞队列？"></a>4.1 什么是阻塞队列？</h4><p>BlockingQueue，是一个接口，继承了Queue接口，是队列的一种，是线程安全的。</p>
<p><img data-src="../../../../assets/img/Cgq2xl4le8SAYKHDAABbO_HZa9c237.png" alt></p>
<p><strong>主要并发队列关系图</strong></p>
<p><img data-src="../../../../assets/img/Cgq2xl4le9SAL6enAAGpXZi8Wcg079.jpg" alt></p>
<p><strong>阻塞队列</strong>典型代表就是BlockingQueue接口的实现类，分别是ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、DelayQueue、PriorityBlockingQueue和LinkedTransferQueue。<strong>非阻塞队列</strong>的典型代表是ConcurrentLinkedQueue，这个类不会让线程阻塞，利用CAS保证线程安全。</p>
<p>Deque为双端队列，它从头和尾都能添加和删除元素；而普通的Queue只能从一端进入，另一端出去。</p>
<p><strong>特点</strong></p>
<p>阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。</p>
<ul>
<li><p>take方法</p>
<p>获取并移除队列的头结点，在队列里有数据时可以正常移除，一旦执行take方法的时候，队列无数据，则阻塞，直到队列有数据。</p>
<p><img data-src="../../../../assets/img/Cgq2xl4le_eAafhbAABp-t8dt_8312.png" alt></p>
</li>
<li><p>put方法</p>
<p>put方法插入元素时，如果队列已满，那么就无法继续插入，则阻塞，直到队列有了空闲空间。</p>
<p><img data-src="../../../../assets/img/CgpOIF4lfAyAC4zxAAB1UtAAltk817.png" alt></p>
</li>
</ul>
<h5 id="是否有界-容量有多大"><a href="#是否有界-容量有多大" class="headerlink" title="是否有界(容量有多大)"></a>是否有界(容量有多大)</h5><p>无界队列意味着里面可以容纳非常多的元素，如LinkedBlockingQueue的上限是Integer.MAX_VALUE，约为2^31。有些阻塞队列是有界的，如ArrayBlockingQueue如果容量满了，也不会扩容，所以一旦满了，就无法再往里面放数据了。</p>
<h4 id="4-2-阻塞队列常用方法"><a href="#4-2-阻塞队列常用方法" class="headerlink" title="4.2 阻塞队列常用方法"></a>4.2 阻塞队列常用方法</h4><p>第一组：无法正常执行的情况下抛出异常；第二组：在无法正常执行的情况下不抛出异常，但会用返回值提示运行失败；第三组：在遇到特殊情况时让线程阻塞，等到可以运行再继续执行。</p>
<p><img data-src="../../../../assets/img/CgpOIF4lheGALDjnAAHFyzrSvqU109.png" alt></p>
<p><strong>带有超时时间的offer和poll</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">offer(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>插入不成功时会等待指定的超时时间，时间到了依然没有插入成功，就会返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">poll(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>如果移除时，如果队列是空的就会进行等待，超时时间到了，如果队列中依然没有元素可供移除，则会返回null为提示</p>
<h4 id="4-3-几种常见的阻塞队列"><a href="#4-3-几种常见的阻塞队列" class="headerlink" title="4.3 几种常见的阻塞队列"></a>4.3 几种常见的阻塞队列</h4><ul>
<li><p>ArrayBlockingQueue</p>
<p><strong>有界队列</strong>，其内部是用数组存储元素的，利用ReentrantLock实现线程安全，在创建它的时候就需要指定它的容量，之后不可以再扩容了，可以在构造函数中指定是否公平。</p>
<p>非公平：存在插队的可能；公平：等待最长时间的线程会被优先处理</p>
</li>
<li><p>LinkedBlockingQueue</p>
<p>内部用链表实现，不指定容量时默认为Integer.MAX_VALUE，被称为无界队列。</p>
</li>
<li><p>SynchronousQueue</p>
<p><img data-src="../../../../assets/img/Cgq2xl4lhhSAZIuZAABMMZW2RVk163.png" alt></p>
<p>容量为0，所以没有地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据也会阻塞，直到有消费者来取。Synchronous的容量不是1而是0，它不需要去持有元素，它所做的就是直接传递。</p>
</li>
<li><p>PriorityBlockingQueue</p>
<p>支持优先级的无界阻塞队列，可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。同时插入的对象必须是可比较大小的，即Comparable的，否则会抛出ClassCastException。</p>
</li>
<li><p>DelayQueue</p>
<p>具有”延迟”的功能，可以设定让队列中的任务延迟多久之后执行，如”30 分钟后未付款自动取消订单”。它是无界队列，放入的元素必须实现Delayed接口，而Delayed接口又继承了Comparable接口，拥有了比较和排序的能力。元素会根据延迟时间的长短放到队列的不同位置，越靠近头队列代表越早过期。</p>
</li>
</ul>
<h4 id="4-4-阻塞队列和非阻塞队列的并发安全原理"><a href="#4-4-阻塞队列和非阻塞队列的并发安全原理" class="headerlink" title="4.4 阻塞队列和非阻塞队列的并发安全原理"></a>4.4 阻塞队列和非阻塞队列的并发安全原理</h4><ul>
<li><p>ArrayBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下3个是控制并发用的工具</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<p>这三个变量非常关键，第一个是ReentrantLock，下面两个Condition是由ReentrantLock产生出来的。读操作和写操作都需要先获取到ReentrantLock独占锁才能进行下一步操作。进行读操作时如果队列为空，线程就会进入到读线程专属的noEmpty的Condition的队列中去排队，等待写线程写入新的元素；同理如果队列已满，写操作的线程会进入到写线程专属的notFull队列中去排队，等待读线程将队列元素移除并腾出空间。</p>
<p>put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue的内部有两把锁，分别锁住队列的头和尾，比共用一把锁的效率高。</p>
</li>
<li><p>非阻塞队列ConcurrentLinkedQueue</p>
<p>offer方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个是以一个大的for循环，p.casNext()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里运用了UNSAFE.compareAndSwapObject方法来完成CAS操作，而compareAndSwapObject是一个native方法，最终会利用CPU的CAS指令保证其不可中断。非阻塞队列ConcurrentLinkedQueue使用CAS非阻塞算法+不停重试，来实现线程安全，适合用在不需要阻塞功能，且并发不是特别剧烈的场景。</p>
</li>
</ul>
<h4 id="4-5-如何选择合适的阻塞队列？"><a href="#4-5-如何选择合适的阻塞队列？" class="headerlink" title="4.5 如何选择合适的阻塞队列？"></a>4.5 如何选择合适的阻塞队列？</h4><ul>
<li><p>线程池对于阻塞队列的选择</p>
<p><img data-src="../../../../assets/img/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png" alt></p>
</li>
</ul>
<p>从以下5个角度考虑，来选择合适的阻塞队列。</p>
<ul>
<li><p>功能</p>
<p>是否需要阻塞队列来排序，如优先级排序、优先执行等。</p>
</li>
<li><p>容量</p>
<p>是否需要有存储要求，还是只需要”直接传递”。</p>
</li>
<li><p>能否扩容</p>
<p>业务可能有高峰期、低谷期，如果需要动态扩容，就不能选择ArrayBlockingQueue。</p>
</li>
<li><p>内存结构</p>
<p>如ArrayBlockingQueue的内部结构是”数组”的形式，LinkedBlockingQueue的内部是链表实现的，ArrayBlockingQueue没有链表所需要的”节点”，空间链表利用率更高。</p>
</li>
<li><p>性能</p>
<p>如LinkedBlockingQueue拥有两把锁，操作粒度更细，并发程度高的时候，相对于只有一把锁的ArrayBlockingQueue性能会更好。SynchronousQueue性能往往优于其他实现，因为它只需要”直接传递”，而不需要存储的过程。</p>
</li>
</ul>
<h3 id="5-原子类"><a href="#5-原子类" class="headerlink" title="5.原子类"></a>5.原子类</h3><h4 id="5-1-原子类如何利用CAS保证线程安全？"><a href="#5-1-原子类如何利用CAS保证线程安全？" class="headerlink" title="5.1 原子类如何利用CAS保证线程安全？"></a>5.1 原子类如何利用CAS保证线程安全？</h4><p>原子类的作用和锁有类似之处，都是为了保证并发情况下线程安全。</p>
<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。</li>
<li>效率更高：除高度竞争的情况下，原子类的效率通常比使用同步互斥锁的效率更高，因为原子类利用了CAS操作，不会阻塞线程。</li>
</ul>
<p><strong>6类原子类纵览</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>具体类</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Atomic* 基本类型原子类</td>
<td>AtomicInteger、AtomicLong、AtomicBoolean</td>
<td></td>
</tr>
<tr>
<td>Atomic*Array 数组类型原子类</td>
<td>AtomicIntegerArray(整形数组原子类)、AtomicLongArray(长整形数组原子类)、AtomicReferenceArray(引用类型数组原子类)</td>
<td></td>
</tr>
<tr>
<td>Atomic*Reference 引用类型原子类</td>
<td>AtomicReference、AtomicStampedReference(对AtomicReference的升级，在此基础上还加了时间戳，用于解决CAS的ABA问题)、AtomicMarkableReference(和AtomicReference类似，多了一个绑定的布尔值，可以用于表示该对象已删除等场景)</td>
<td>AtomicInteger可以让一个整数保证原子形，AtomicReference可以让一个对象保证原子性。</td>
</tr>
<tr>
<td>Atomic*FieldUpdater升级类型原子类</td>
<td>AtomicIntegerFieldUpdater(原子更新整形的更新器)、AtomicLongFieldUpdater(原子更新长整形的更新器)、AtomicReferenceFieldUpdater(原子更新引用的更新器)</td>
<td>可以把已经声明的变量进行升级，使其拥有CAS操作的能力。</td>
</tr>
<tr>
<td>Adder累加器</td>
<td>LongAdder、DoubleAdder</td>
<td></td>
</tr>
<tr>
<td>Accumulator积累器</td>
<td>LongAccumulator、DoubleAccumulator</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Score math;</span><br><span class="line">    <span class="keyword">static</span> Score computer;</span><br><span class="line">    static AtomicIntegerFieldUpdater&lt;Score&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Score.class, "score");</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            computer.score++;</span><br><span class="line">            scoreUpdater.getAndIncrement(math);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        math = <span class="keyword">new</span> Score();</span><br><span class="line">        computer = <span class="keyword">new</span> Score();</span><br><span class="line">        AtomicIntegerFieldUpdaterDemo updaterDemo = <span class="keyword">new</span> AtomicIntegerFieldUpdaterDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(updaterDemo);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(updaterDemo);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"普通变量的结果："</span>+ computer.score);</span><br><span class="line">        System.out.println(<span class="string">"升级后的结果："</span>+ math.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以AtomicInteger为例，分析其如何利用CAS实现原子操作？</strong></p>
<ul>
<li><p>getAndAdd()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 1.8实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Unsafe类</strong></p>
<p>Unsafe类是CAS的核心类。Java无法直接访问底层操作系统，而需要通过native方法实现。在JDK中有一个Unsafe类，提供了硬件级别的原子操作，可以利用它直接操作内存数据。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           valueOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static代码块会在类加载的时候执行，执行时会调用Unsafe的objectFieldOffset方法，从而得到当前这个原子类的value的偏移量(在内存中的偏移地址)，并且赋给valueOffset变量，并且赋值给valueOffset变量，Unsafe根据内存偏移地址获取数据的原值，这样就可以通过Unsafe来实现CAS了。</p>
<p>value是用volatile修饰的，它就是我们原子类存储的值的变量，由于它被volatile修饰，我们就可以保证在多线程之间看到的value是同一份，保证了可见性。</p>
<p>Unsafe的getAndAddInt方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);<span class="comment">//获取var1中的var2偏移处的值 var1:当前原子类 var2:最开始获取到的offset</span></span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="comment">//var1:object 当前原子类对象 var2:offset 即偏移量，借助它就可以获取到value的数值 var3:expectedValue 代表"期望值"，传入的是刚才获取到的var5 var5+var4:newValue 是希望修改的数值，等于之前取到的数值var5+var4，var4是希望原子类所改变的数值，如+1或-1。</span></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSwapInt方法的作用：判断如果现在原子类里的value的值和之前获取到的var5相等的话，那么就把计算出来的var5+var4给更新上去。一旦CAS操作成功，就会退出这个while循环，但也有可能操作失败。如果操作失败就意味着在获取到var之后，并在CAS操作之前，value的数值已经发生变化了，证明有其他线程修改过这个变量。会再次执行循环体里面的代码，重新获取var5，即获取最新的原子变量的数值，并再次利用CAS尝试更新，直到更新成功。</p>
</li>
</ul>
<h4 id="5-2-AtomicInteger在高并发下性能不好，如何解决？为什么？"><a href="#5-2-AtomicInteger在高并发下性能不好，如何解决？为什么？" class="headerlink" title="5.2 AtomicInteger在高并发下性能不好，如何解决？为什么？"></a>5.2 AtomicInteger在高并发下性能不好，如何解决？为什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLongDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(AtomicLong counter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.counter = counter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter.incrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"..."</span>+counter.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicLong counter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        ExecutorService poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            poolExecutor.submit(<span class="keyword">new</span> Task(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">"result:"</span>+counter.get());</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/Cgq2xl46RpiAC7t7AAAa3NLU-Uk716.png" alt></p>
<p>每一个线程是运行在自己的core中的，并且它们都有一个本地内存是自己独用的。在本地内存下方有两个CPU核心共用的共享内存。对于AtomicLong内部的value属性而言，它是被volatile修饰的，需要保证自身可见性。每次它的数值变化的时候，都需要进行flush到共享内存和refresh到本地内存。</p>
<p>flush和refresh操作耗费了很多资源，而且CAS也会经常失败。</p>
<p><strong>LongAdder</strong></p>
<p>LongAdder引入了分段累加的概念，内部一共有两个参数参与计数：</p>
<ol>
<li>base，是一个变量，用在竞争不激烈的情况下，可以直接把来家结果改到base变量上。</li>
<li>Cell[]，是一个数组，一旦竞争激烈，各个线程会分散累加到自己所对应的那个Cell[]数组的某一个对象中，而大家不会共用同一个。</li>
</ol>
<p>竞争激烈的时候，LongAdder会通过计算出每个线程的hash值来给线程分配到不同的Cell上去，每个Cell相当于是一个独立的计数器，Cell之间并不存在竞争，所以自加过程中，大大减少了flush和refresh，以及降低了冲突的概率。空间换时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Cell[] as = cells; Cell a;</span><br><span class="line">   <span class="keyword">long</span> sum = base;</span><br><span class="line">   <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">               sum += a.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何选择</strong></p>
<p>如何仅仅是需要用到加和减操作的场景，那么可以直接使用LongAdder。</p>
<p>如果需要利用CAS比如compareAndSet等操作的话，就需要使用AtomicLong来完成。</p>
<h4 id="5-3-原子类与volatile"><a href="#5-3-原子类与volatile" class="headerlink" title="5.3 原子类与volatile"></a>5.3 原子类与volatile</h4><p><img data-src="../../../../assets/img/Cgq2xl49B9GAHIQWAABs3zG_-08605.png" alt></p>
<p>线程1和线程2分别在不同的CPU核心，每一个核心都有自己的本地内存，并且在下方也有它们的共享内存。在变量加上volatile关键字，线程1的更改会被flush到共享内存，然后又被refresh到线程2的本地内存，保证了可见性。</p>
<p>但对于value++这种，即使用volatile修饰value也是不能保证线程安全的，无法保证其原子性。此时可以使用原子类。</p>
<p><strong>原子类和volatile的使用场景</strong></p>
<p>通常情况下，volatile可以用来修饰boolean类型的标记位，对于标记位来讲，直接的赋值操作本身就具有原子性，再加上volatile保证了可见性，那么就是线程安全的了。而对于会被多个线程同时操作的计数器counter的场景，即不仅仅是赋值操作，还需要读取当前值，然后在此基础上进行一定的修改，再把它给赋值回去，此时需要使用原子类保证线程安全。</p>
<h4 id="5-4-Adder与Accumlator的区别"><a href="#5-4-Adder与Accumlator的区别" class="headerlink" title="5.4 Adder与Accumlator的区别"></a>5.4 Adder与Accumlator的区别</h4><p>高并发场景下AtomicLong CAS冲突概率大，会导致经常自旋。而LongAdder引入了分段锁的概念，竞争不激烈的时候，所有线程都是通过CAS对同一个Base变量进行修改，但竞争激烈的时候，LongAdder会把不同线程对应到不同的Cell上进行修改，降低了冲突的概率。</p>
<p>LongAccumulator就是个更通用版本的Adder，提供了自定义的函数操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAccumulatorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">16</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(i-&gt;executorService.submit(()-&gt;&#123;</span><br><span class="line">            accumulator.accumulate(i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"..."</span>+accumulator.get());</span><br><span class="line">        &#125;));</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(accumulator.getThenReset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LongAccumulator counter = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">LongAccumulator result = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; x * y, <span class="number">0</span>);</span><br><span class="line">LongAccumulator min = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; Math.min(x, y), <span class="number">0</span>);</span><br><span class="line">LongAccumulator max = <span class="keyword">new</span> LongAccumulator((x, y) -&gt; Math.max(x, y), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ol>
<li>需要大量的计算，并且当需要并行计算的时候。</li>
<li>计算的执行顺序并不关键。</li>
</ol>
<h3 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6.ThreadLocal"></a>6.ThreadLocal</h3><h4 id="6-1-ThreadLocal适用场景"><a href="#6-1-ThreadLocal适用场景" class="headerlink" title="6.1 ThreadLocal适用场景"></a>6.1 ThreadLocal适用场景</h4><ol>
<li><p>场景1</p>
<p><strong>保存每个线程独享的对象</strong>，为每个线程都创建一个副本，这样每个线程都可以修改自己拥有的副本，而不会影响其他线程的副本，确保了线程安全。</p>
<p>这种场景下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量。因为每个线程独享副本，而不是共用的，所以不存在多线程间共享的问题。</p>
<p>这种场景通常用于保存线程不安全的工具类，如SimpleDateFormat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; formatThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"mm:ss"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">16</span>, <span class="number">32</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * seconds);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = formatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>).forEach(i -&gt; executorService.submit(() -&gt; &#123;</span><br><span class="line">            String date = <span class="keyword">new</span> ThreadLocalDemo05().date(i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + date);</span><br><span class="line">        &#125;));</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景2</p>
<p><strong>每个线程内需要独立保存信息，以便其他方法更方便的获取该信息的场景</strong>。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息之后，后续方法可以通过ThreadLocal直接获取到，避免了传参，类似于全局变量的概念。</p>
<p>每个线程内需要保存类似于全局变量的信息(列如拦截器中获取的用户信息)，可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享(因为不同线程获取到的用户信息不一样)。</p>
<p>例如，用ThreadLocal保存一些业务内容(用户权限信息)，这些信息在同一个线程内相同，但在不同的线程使用的业务内容是不相同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service1().service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>);</span><br><span class="line">        userContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> Service2().service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">"Service2拿到用户名："</span> + user.getUsername());</span><br><span class="line">        <span class="keyword">new</span> Service3().service3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">"Service3拿到用户名："</span> + user.getUsername());</span><br><span class="line">        userContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="6-2-ThreadLocal是用来解决共享资源的多线程访问的问题吗？"><a href="#6-2-ThreadLocal是用来解决共享资源的多线程访问的问题吗？" class="headerlink" title="6.2 ThreadLocal是用来解决共享资源的多线程访问的问题吗？"></a>6.2 ThreadLocal是用来解决共享资源的多线程访问的问题吗？</h4><p>不是，虽然ThreadLocal是用于解决多线程情况下的线程安全问题，但其资源并不是共享的，而是每个线程独占的。</p>
<p>如果把放到ThreadLocal中的资源用static修饰，让它变为一个共享资源的话，那么即便使用ThreadLocal，同样有线程安全问题。</p>
<p><strong>ThreadLocal和synchronized是什么关系？</strong></p>
<ul>
<li>ThreadLocal是通过让每个线程独享自己的副本，避免了资源的竞争。</li>
<li>synchronized主要用于临界资源的分配，在同一时刻限制最多只有一个线程能够访问该资源</li>
</ul>
<p>相比于ThreadLocal而言，synchronized的效率会更低一些，但花费的内存也更少。但对于ThreadLocal而言，它还有不同的使用场景。比如避免传参。</p>
<h4 id="6-3-ThreadLocal的结构"><a href="#6-3-ThreadLocal的结构" class="headerlink" title="6.3 ThreadLocal的结构"></a>6.3 ThreadLocal的结构</h4><p><strong>Thread、ThreadLocal及ThreadLocalMap三者之间的关系</strong></p>
<p><img data-src="../../../../assets/img/Cgq2xl5M5a6ADeCKAABC52ZxZCk238.png" alt></p>
<p>每个Thread对象中都持有一个ThreadLocalMap类型的成员变量，这个ThreadLocalMap自身类似一个Map，里面会有一个个key-value形式的，key就是ThreadLocal的引用，value就是希望ThreadLocal存储的内容。</p>
<p><strong>get方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取到当前线程内的ThreadLocalMap对象，每个线程内都有一个ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取ThreadLocalMap中的Entry对象并拿到value，每个线程内都有一个ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程内之前没创建过ThreadLocalMap，就创建</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getMap方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>set方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程内的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//第一个参数this：当前ThreadLocal的引用，key的类型则是ThreadLocal；第二个参数即为所传入的value</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocalMap类，即Thread.threadLocals</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ThreadLocalMap中会有一个Entry类型的数组，名字叫table。可以理解为一个map，其键值对为：</p>
<ul>
<li>键，当前的ThreadLocal</li>
<li>值，实际需要存储的变量，比如user用户对象或者simpleDateFormat对象</li>
</ul>
<p>HashMap在面对hash冲突的时候，采用的是拉链法，它会先把对象hash到一个对应的格子中，如果有冲突就用链表的形式往下链；但ThreadLocalMap采用的是线性探测法，如果发生冲突，并不会用链表的形式往下链，而是会继续寻找下一个空的格子。</p>
<h4 id="6-4-为何每次用完-ThreadLocal-都要调用-remove-？"><a href="#6-4-为何每次用完-ThreadLocal-都要调用-remove-？" class="headerlink" title="6.4 为何每次用完 ThreadLocal 都要调用 remove()？"></a>6.4 为何每次用完 ThreadLocal 都要调用 remove()？</h4><p>内存泄漏：当某一个对象不再有用的时候，占用的内存却不能被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry是extends WeakReference。弱引用的特点：如果这个对象只被弱引用关联，而没有任何强引用关联，那么这个对象就可以被回收，所以弱引用不会阻止GC。</p>
<p>但是这个Entry包含了一个对value的强引用。value=v这行代码就代表了强引用的发生。</p>
<p><img data-src="../../../../assets/img/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt></p>
<p>Thread Ref → Current Thread → ThreadLocalMap → Entry → Value → 可能泄漏的value实例。</p>
<p>这条链路是随着线程的存在而一直存在，如果线程迟迟不会终止，那么当垃圾回收进行可达性分析的时候，这个value就是可达的，所以不会被回收。但与此同时可能已经完成了业务逻辑处理，不再需要这个value了，此时就发生了内存泄漏。</p>
<p>在执行ThreadLocal的set、remove、rehash等方法时，都会扫描key为null的Entry，如果发现某个Entry的key为null，则代表它所对应的value也没有作用了，所以就会把对应的value设置为null，这样，value对象就可以被正常回收了。但假设ThreadLocal已经不被使用了，那么实际上set、remove、rehash方法也不会被调用。</p>
<p><strong>如何避免内存泄漏</strong></p>
<p>调用 ThreadLocal 的 remove 方法。调用这个方法就可以删除对应的 value 对象，可以避免内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Future"><a href="#7-Future" class="headerlink" title="7.Future"></a>7.Future</h3><h4 id="7-1-Callable和Runnable的不同"><a href="#7-1-Callable和Runnable的不同" class="headerlink" title="7.1 Callable和Runnable的不同"></a>7.1 Callable和Runnable的不同</h4><ul>
<li><p>Runnable的不足</p>
<ol>
<li><p>不能返回一个返回值</p>
</li>
<li><p>不能抛出checked Exception</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThrowException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通方法内可以 throw 异常，并在方法签名上声明 throws</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  run方法上无法声明 throws 异常，且run方法内无法 throw 出 checked Exception，除非使用try catch进行处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Runnable规定了run()方法的返回类型是void，而且没有声明抛出任何异常。所以，当实现并重写这个方法的时候，既不能改变返回值类型，也不能更改对于异常抛出的描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable接口</p>
<p>call方法已经声明了throws Exception，前面还有一个V泛型的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable和Runnable的不同之处</p>
<ol>
<li>方法名：Callable规定的执行方法是call()，而Runnable规定的执行方法是run()</li>
<li>返回值：Callable的任务执行后有返回值，而Runnable的任务执行后是没有返回值的</li>
<li>抛出异常：call()方法可抛出异常，而run方法是不能抛出检查异常的</li>
<li>和Callable配合使用的Future类，通过Future可以了解任务的执行情况，或者取消任务的执行，还可获取任务的执行结果等。</li>
</ol>
</li>
</ul>
<h4 id="7-2-Future的主要功能"><a href="#7-2-Future的主要功能" class="headerlink" title="7.2 Future的主要功能"></a>7.2 Future的主要功能</h4><p><strong>Future的作用</strong></p>
<p>比如当做一定较耗时的任务时，可以把任务放到子线程去执行，再通过Future去控制子线程执行的过程，最后获取到计算结果。通过异步的思想，提高程序的运行效率。</p>
<p><strong>Callable和Future的关系</strong></p>
<p>Callable接口相比于Runnable可以通过Future类的get方法返回结果。因此，Future类相当于一个存储器，它存储了Callable的call方法的任务结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get() 获取结果</p>
<p>获取任务执行的结果</p>
<ol>
<li>当执行get的时候，任务已经执行完毕了。可以立刻返回，获取到任务执行的结果。</li>
<li>任务还未开始或任务正在执行中，调用get时，都会把当前线程阻塞，直到任务完成再把结果返回回来。</li>
<li>任务执行过程中抛出异常，调用get时，就会抛出ExecutionException，且无论执行call方法时里面抛出的异常类型是什么，在执行get方法时所获得的异常都是ExecutionException。</li>
<li>任务被取消了，如果任务被取消，调用get方法时则会抛出CancellationException。</li>
<li>任务超时，调用带延迟参数的get方法之后，如果call方法在规定时间内仍没有完成任务，get方法则会抛出TimeoutException，代表超时了。</li>
</ol>
<p><img data-src="../../../../assets/img/Cgq2xl5WX0OAUkXdAADovQH3upQ950.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *一个Future的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneFuture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt()+Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Future future = executorService.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isDone() 判断是否执行完毕</p>
<p>判断当前线程是否执行完毕，返回true代表已经执行完毕，返回false则代表还没完成。但这里如果返回true，并不代表这个任务是成功执行的，比如说任务执行到一半抛出了异常，仍然会返回true，所以isDone方法在返回true的时候，不代表这个任务是成功执行的，只代表它执行完毕了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Callable抛出异常！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        Future future = executorService.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(future.isDone());</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.IllegalArgumentException: Callable抛出异常！</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这段代码的运行结果证明了：</p>
<ol>
<li>即便任务抛出异常，isDone方法依然会返回true。</li>
<li>虽然call方法抛出的异常是IllegalArgumentException，但对于get而言，它抛出的异常依然是ExecutionException。</li>
<li>虽然在任务执行一开始就抛出了异常，但真正要等到执行get的时候，才看到了异常。</li>
</ol>
</li>
<li><p>cancel 取消任务的执行</p>
<ol>
<li>任务还未执行，任务会被正常取消，未来也不会被执行，返回true。</li>
<li>任务已经完成或被取消过，返回false。</li>
<li>任务正在执行，会根据传入的参数mayInterruptIfRunning，如果传入的参数是true，执行任务的线程会收到一个中断的信号。如果传入的是false，就代表不中断正在运行的任务，同时返回false。</li>
</ol>
<p>true：明确知道这个任务能够处理中断</p>
<p>false：明确知道这个任务不能处理中断；不知道这个任务是否支持取消(是否能够响应中断)；如果这个任务一旦开始运行，就希望它完全的执行完毕。</p>
</li>
<li><p>isCancelled() 判断是否被取消</p>
</li>
</ul>
<p><strong>用FutureTask创建Future</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(task);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果："</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在计算！"</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-Future注意点"><a href="#7-3-Future注意点" class="headerlink" title="7.3 Future注意点"></a>7.3 Future注意点</h4><ol>
<li><p>当for循环批量获取Future的结果时容易block，get方法调用时应该使用timeout限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlowTask</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"速度慢的任务"</span> + Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastTask</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"速度快的任务"</span> + Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MICROSECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Future future;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">                future = executorService.submit(<span class="keyword">new</span> SlowTask());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future = executorService.submit(<span class="keyword">new</span> FastTask());</span><br><span class="line">            &#125;</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Future future = futures.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String result = (String)future.get();</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">速度慢的任务pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">速度慢的任务pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">速度快的任务pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">速度快的任务pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../../../../assets/img/CgpOIF5Y0OGAKVKjAACCEFYDuCw593.png" alt></p>
<p>第三个任务量比较小，可以很快返回结果，紧接着第四个任务也会返回结果。但由于前两个任务速度很慢，所以get方法执行时，会卡在第一个任务上。所以，即使第三、四个任务很早就得到结果了，但在此使用for循环的方式去获取结果，依然无法及时获取第三、四个任务的结果。直到5秒后，第一个任务出结果了，我们才能获取到，紧接着获取剩下任务的结果。</p>
<p>此时可以使用Future的带超时参数的get(long timeout, TimeUnit unit)方法，如果在限定时间内没能返回结果，即抛出TimeoutException。</p>
</li>
<li><p>Future的生命周期不可后退</p>
<p>Future的生命周期不可后退，一旦完成了任务，它就永久停在了”已完成”的状态，不能重头再来，即不能让一个已经完成计算的Future再次重新执行任务。</p>
</li>
</ol>
<p><strong>Future产生新的线程了吗</strong></p>
<p>Callable和Future本身并不能产生新的线程，它们需要借助其它的比如Thread类或者线程池才能执行任务。例如：在把Callable提交到线程池后，真正执行Callable的其实还是线程池中的线程，而线程池中的线程是由ThreadFactory产生的。</p>
<h4 id="7-4-CountDownLatch、Completable"><a href="#7-4-CountDownLatch、Completable" class="headerlink" title="7.4 CountDownLatch、Completable"></a>7.4 CountDownLatch、Completable</h4><p><img data-src="../../../../assets/img/Cgq2xl5c0xaASO8FAAFKHNM1bu8607.png" alt></p>
<ul>
<li><p>线程池实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolDemo threadPoolDemo = <span class="keyword">new</span> ThreadPoolDemo();</span><br><span class="line">        System.out.println(threadPoolDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Integer&gt; <span class="title">getPrices</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">123</span>, prices));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">456</span>, prices));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">789</span>, prices));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.productId = productId;</span><br><span class="line">            <span class="keyword">this</span>.prices = prices;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price= (<span class="keyword">int</span>) (Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatchDemo countDownLatchDemo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line">        System.out.println(countDownLatchDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Integer&gt; <span class="title">getPrices</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">123</span>, prices, countDownLatch));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">456</span>, prices, countDownLatch));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> Task(<span class="number">789</span>, prices, countDownLatch));</span><br><span class="line">        countDownLatch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices,</span></span></span><br><span class="line"><span class="function"><span class="params">                CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.productId = productId;</span><br><span class="line">            <span class="keyword">this</span>.prices = prices;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> price = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price = (<span class="keyword">int</span>) (Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行countDownLatch.await(3, TimeUnit.SECONDS)等待时，如果三个任务都非常快速得执行完毕了，那么都已经执行了countDown方法，相当于把计数减1。如果有一个线程没有执行countDown方法，来不及在3秒内执行完毕，那么这个带超时参数的await方法也会在3秒以后，及时的放弃这一次等待，于是就把prices返回了。</p>
</li>
<li><p>CompletableFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.productId = productId;</span><br><span class="line">            <span class="keyword">this</span>.prices = prices;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> price = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price = (<span class="keyword">int</span>)(Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Integer&gt; <span class="title">getPrices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(<span class="keyword">new</span> Task(<span class="number">123</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(<span class="keyword">new</span> Task(<span class="number">456</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; task3 = CompletableFuture.runAsync(<span class="keyword">new</span> Task(<span class="number">789</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task2, task3);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            allTasks.get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompletableFutureDemo completableFutureDemo = <span class="keyword">new</span> CompletableFutureDemo();</span><br><span class="line">        System.out.println(completableFutureDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompletableFuture的runAsync()方法，这个方法会异步的去执行任务。</p>
</li>
</ul>
<h3 id="8-线程协作"><a href="#8-线程协作" class="headerlink" title="8.线程协作"></a>8.线程协作</h3><h4 id="8-1-信号量"><a href="#8-1-信号量" class="headerlink" title="8.1 信号量"></a>8.1 信号量</h4><p>  控制需要限制并发访问量的资源。</p>
<p>  <strong>使用流程</strong></p>
<ol>
<li><p>初始化一个信号量，并传入许可证的数量。public Semaphore(int permits, boolean fair)，传入两个参数，第一个参数是许可证的数量，另一个参数是是否公平，如果为true，代表是公平的策略，会把之前已经在等待的线程放入到队列中，当有新的许可证时，会按照顺序发放；如果为false，则代表非公平策略，也就有可能插队。</p>
</li>
<li><p>在调用慢服务之前，线程调用acquire()或者acquireUninterruptibly()获取许可证。如果此时信号量没有剩余的许可证，那么线程会等在acquire()的这一行代码中，不会进一步执行下面调用服务的方法。</p>
<p>acquire()和acquireUninterruptibly()的区别：是否能够中断。acquire()支持中断，即在获取信号量期间，假如这个线程被中断了，那么它就会跳出acquire()，不再继续尝试获取了，而acquireUninterruptibly()方法是不会中断的。</p>
</li>
<li><p>任务执行完毕之后，调用release()释放许可证。</p>
</li>
</ol>
<p><strong>其他的主要方法</strong></p>
<ol>
<li><p>public boolean tryAcquire()</p>
<p>尝试获取许可证，获取不到不会阻塞，可以去做其他事。</p>
</li>
<li><p>public boolean tryAcquire(long timeout, TimeUnit unit)</p>
<p>超时时间到，依然获取不到许可证，认为获取失败，返回false。</p>
</li>
<li><p>availablePermits()</p>
<p>查询可用许可证的数量，返回一个整形的结果。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;StopWatch&gt; stopWatchThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> StopWatch());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"获取到许可证，开始执行任务！"</span>);</span><br><span class="line">            StopWatch stopWatch = stopWatchThreadLocal.get();</span><br><span class="line">            stopWatch.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                stopWatch.stop();</span><br><span class="line">                System.out.println(<span class="string">"慢服务执行完毕，耗时："</span> + stopWatch.getTotalTimeMillis() + <span class="string">"---"</span></span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">"释放了许可证！"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                stopWatchThreadLocal.remove();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">50</span>, <span class="number">50</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊用法：一次获取或释放多个许可证</p>
<p>semphore.acquire(2)        semaphore.release(3)</p>
<p><strong>注意点</strong></p>
<ul>
<li>获取和释放的许可证数量尽量保持一致</li>
<li>在初始化时可以设置公平性，true会让它更公平，false则会让总的吞吐量更高</li>
<li>信号量是支持跨线程、跨线程池的，并且并不是哪个线程获得的许可证，就必须由这个线程去释放，对于获取和释放许可证的线程是没有要求的。</li>
</ul>
<h4 id="8-2-CountDownLatch-是如何安排线程执行顺序的？"><a href="#8-2-CountDownLatch-是如何安排线程执行顺序的？" class="headerlink" title="8.2 CountDownLatch 是如何安排线程执行顺序的？"></a>8.2 CountDownLatch 是如何安排线程执行顺序的？</h4><p><img data-src="../../../../assets/img/Cgq2xl5h8oSAKLBQAABld2EcD7Q385.png" alt></p>
<p><strong>主要方法</strong></p>
<ol>
<li><p>构造函数</p>
<p>public CountDownLatch(int count){</p>
<p>}</p>
<p>count是需要倒数的值</p>
</li>
<li><p>await()</p>
<p>调用await()方法的线程开始等待，直到倒数结束，也就是count值为0的时候才会继续执行。</p>
</li>
<li><p>await(long timeout, TimeUnit unit)</p>
<p>和await()类似，但这里可以设置超时时间，如果超时就不等待了。</p>
</li>
<li><p>countDown()</p>
<p>把数值倒数1，也就是将count值减1，直到减为0时，之前等待的线程会被唤起。</p>
</li>
</ol>
<p><strong>用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        CountDownLatch downLatch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        CountDownLatch downLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i + <span class="number">1</span>;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(finalI + <span class="string">"号运动员准备完毕，等待裁判员的发令枪"</span>);</span><br><span class="line">                        downLatch2.await();</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        System.out.println(finalI + <span class="string">"号运动员完成了比赛"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        downLatch1.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"5秒准备时间已过，发令枪响，比赛开始！"</span>);</span><br><span class="line">        downLatch2.countDown();</span><br><span class="line">        System.out.println(<span class="string">"等待5个运动员都跑完...."</span>);</span><br><span class="line">        downLatch1.await();</span><br><span class="line">        System.out.println(<span class="string">"所有人都跑完了，比赛结束"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<ul>
<li>CountDownLatch是不能够重用的，比如已经完成了倒数，不可以在下一次继续去重新倒数。可以考虑使用CyclicBarrier或创建一个新的CountDownLatch实例。</li>
</ul>
<h4 id="8-3-CyclicBarrier和CountdownLatch"><a href="#8-3-CyclicBarrier和CountdownLatch" class="headerlink" title="8.3 CyclicBarrier和CountdownLatch"></a>8.3 CyclicBarrier和CountdownLatch</h4><p>CyclicBarrier可以构造出一个集结点，当某一个线程执行await()的时候，它就会到这个集结点开始等待，等待这个栅栏被撤销。直到预定数量的线程都到了这个集结点之后，这个栅栏就会撤销，之前等待的线程就在此刻统一出发，继续去执行剩下的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"同学"</span> + id + <span class="string">"现在从大门出发，前往自行车驿站"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">"同学"</span> + id + <span class="string">"到了自行车驿站，开始等待其他人到达"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">"同学"</span> + id + <span class="string">"开始骑车"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">// 当线程达到集结点，执行下一次动作之前，会执行一次这个动作</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"凑齐3人了，GO！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(i + <span class="number">1</span>, cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行动作barrierAction</strong></p>
<p>public CyclicBarrier(int parties, Runnable barrierAction): 当parties线程到达集结点时，继续往下执行前，会执行这一次这个动作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">同学<span class="number">1</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">5</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">6</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">4</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">3</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">2</span>现在从大门出发，前往自行车驿站</span><br><span class="line">同学<span class="number">5</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学<span class="number">2</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学<span class="number">6</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">凑齐<span class="number">3</span>人了，GO！</span><br><span class="line">同学<span class="number">6</span>开始骑车</span><br><span class="line">同学<span class="number">5</span>开始骑车</span><br><span class="line">同学<span class="number">2</span>开始骑车</span><br><span class="line">同学<span class="number">3</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学<span class="number">4</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学<span class="number">1</span>到了自行车驿站，开始等待其他人到达</span><br><span class="line">凑齐<span class="number">3</span>人了，GO！</span><br><span class="line">同学<span class="number">1</span>开始骑车</span><br><span class="line">同学<span class="number">3</span>开始骑车</span><br><span class="line">同学<span class="number">4</span>开始骑车</span><br></pre></td></tr></table></figure>

<p><strong>CyclicBarrier和CountDownLatch的异同</strong></p>
<p>相同点：都能阻塞一个或一组线程，直到某个预设条件达成，再统一出发。</p>
<p>不同点：</p>
<ul>
<li><p>作用对象不同：</p>
<p>CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说CountDownLatch作用于事件，但CyclicBarrier作用于线程；CountDownLatch是在调用了countDown方法之后把数字减1，而CyclicBarrier是在某线程开始等待后把计数减1。</p>
</li>
<li><p>可重用性不同：</p>
<p>CountDownLatch在倒数0并且触发门闩打开后，就不能再次使用了，除非新建一个新的实例；而CyclicBarrier可以重复使用。CyclicBarrier还可以随时调用reset方法进行重置，如果重置时有线程已经调用了await方法并开始等待，那么这些线程则会抛出BrokenBarrierException异常。</p>
</li>
<li><p>执行动作不同：</p>
<p>CyclicBarrier有执行动作barrierAction，而CountDownLatch没这个功能。</p>
</li>
</ul>
<h4 id="8-4-Condition、object都wait-何notify-的关系"><a href="#8-4-Condition、object都wait-何notify-的关系" class="headerlink" title="8.4 Condition、object都wait()何notify()的关系"></a>8.4 Condition、object都wait()何notify()的关系</h4><p>假设线程1需要等待某些条件满足后，才能继续运行，如等待某个时间点到达或者等待某些任务处理完毕。此时，就可以执行Condition的await方法，一旦执行了该方法，这个线程就会进入WATTING状态。通常还有另外一个线程2，它去达成对应的条件，直到这个条件达成之后，那么线程2调用signal方法或signalAll方法，代表”<strong>条件达成，之前等待这个条件的线程现在可以苏醒了</strong>“。这个时候，JVM就会找到等待该Condition的线程，并予以唤醒，线程1在此时就会被唤醒，线程状态又会回到Runnable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":条件不满足，开始await"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"条件满足了，开始执行后续的任务"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":需要5秒钟的准备时间"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":准备工作完成，唤醒其他的线程"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionDemo conditionDemo = <span class="keyword">new</span> ConditionDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionDemo.task2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        conditionDemo.task1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:条件不满足，开始await</span><br><span class="line">Thread-<span class="number">0</span>:需要<span class="number">5</span>秒钟的准备时间</span><br><span class="line">Thread-<span class="number">0</span>:准备工作完成，唤醒其他的线程</span><br><span class="line">main条件满足了，开始执行后续的任务</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<ul>
<li><p>线程2解锁后，线程1才能获得锁并继续执行</p>
<p>调用signal之后，还需要等待子线程完全退出这个锁，即执行unlock之后，这个主线程才有可能去获取到这把锁，并且当获取锁成功之后才能继续执行后面的任务。</p>
</li>
<li><p>signalAll()和signal()区别</p>
<p>signalAll()会唤醒所有正在等待的线程，而signal()只会唤醒一个线程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Condition实现简易版阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueueForCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueueForCondition</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = maxSize;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == max) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(object);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object item = queue.remove();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用wait/notify来实现简易版阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBlockingQueueForWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBlockingQueueForWaitNotify</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == maxSize) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(object);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        Object item = queue.remove();</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition把Object的wait/notify/notifyAll转化为了一种相应的对象，其实现的效果基本一样，但是把更复杂的用法，变成了更直观可控的对象方法，是一种升级。await方法会自动释放持有的Lock锁，否则会抛出异常，和Object的wait一样，不需要自己手动释放锁。另外，调用await的时候必须持有锁，否则会抛出异常，这一点和Object的wait一样。</p>
<h3 id="9-Java内存模型"><a href="#9-Java内存模型" class="headerlink" title="9.Java内存模型"></a>9.Java内存模型</h3><h4 id="9-1-什么是Java内存模型？"><a href="#9-1-什么是Java内存模型？" class="headerlink" title="9.1 什么是Java内存模型？"></a>9.1 什么是Java内存模型？</h4><p><strong>JVM内存结构</strong></p>
<ul>
<li><p>堆</p>
<p>堆是存放类实例和数组的，通常是内存中最大的一块。比如new Object()就会产生一个实例；而数组也是保存在堆上，因为在Java中，数组也是对象。</p>
</li>
<li><p>虚拟机栈</p>
<p>保存局部变量和部分结果，并在方法调用和返回中起作用。</p>
</li>
<li><p>方法区</p>
<p>它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括用于类初始化以及接口初始化的特殊方法。</p>
</li>
<li><p>本地方法栈</p>
<p>与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p>
</li>
<li><p>程序计数器</p>
<p>最小的一块内存区域，它的作用通常是保存当前正在执行的JVM指令地址。</p>
</li>
<li><p>运行时常量池</p>
<p>是方法区的一部分，包含多种常量，范围从编译时已知的数字到必须在运行时解析的方法和字段引用。</p>
</li>
</ul>
<p><strong>为什么需要JMM(Java Memory Model, Java内存模型)</strong></p>
<p>程序最终执行的效果依赖于具体的处理器，而不同的处理器的规则又不一样，需要一个标准，让多线程运行结果可以预期，这个标准就是JMM。</p>
<p><strong>JMM是什么</strong></p>
<ul>
<li><p>JMM是规范</p>
<p>JMM是和多线程相关的一组规范，需要各个JVM的实现来遵守JMM规范。因此JMM与处理器、缓存、并发、编译器有关，它解决了CPU多级缓存、处理器优化、质量重排序等导致的结果不可预期的问题。</p>
</li>
<li><p>JMM是工具类和关键字的原理</p>
<p>如volatile、synchronized、Lock等原理都涉及JMM。重排序、原子性、内存可见性。</p>
</li>
</ul>
<h4 id="9-2-什么是指令重排序？为什么要进行重排序？"><a href="#9-2-什么是指令重排序？为什么要进行重排序？" class="headerlink" title="9.2 什么是指令重排序？为什么要进行重排序？"></a>9.2 什么是指令重排序？为什么要进行重排序？</h4><p>假设我们写了一个Java程序，实际上语句的运行顺序可能可写的代码顺序不一致。编译器、JVM或者CPU都有可能出于优化等目的，对于实际指令执行的顺序进行调整。</p>
<p><strong>重排序的好处：提高处理速度</strong></p>
<p><img data-src="../../../../assets/img/CgpOIF5vI8yAE1n_AACnC3UQ3xM235.png" alt></p>
<p><img data-src="../../../../assets/img/Cgq2xl5vI8yAfRpUAACP4YXZ3sg831.png" alt></p>
<p><strong>重排序的3种情况</strong></p>
<ol>
<li><p>编译器优化</p>
<p>编译器(包括JVM、JIT编译器等)；重排序并不意味着可以任意排序，它需要保证重排序后，不改变单线程内的语义。</p>
</li>
<li><p>CPU重排序</p>
<p>CPU同样会有优化行为，即使之前的编译器不发生冲排，CPU也可能进行重排。</p>
</li>
<li><p>内存的”重排序”</p>
<p>内存系统不存在真正的重排序，但是内存会带来看上去和重排序一样的效果。由于内存有缓存的存在，在JMM里表现为主内存和本地内存，而主内存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</p>
</li>
</ol>
<h4 id="9-3-Java中的原子操作有哪些注意事项？"><a href="#9-3-Java中的原子操作有哪些注意事项？" class="headerlink" title="9.3 Java中的原子操作有哪些注意事项？"></a>9.3 Java中的原子操作有哪些注意事项？</h4><p>原子操作指一系列操作要么全部发生，要么全部不发生，不会出现执行一半的情况。</p>
<p><strong>Java中的原子操作有哪些</strong></p>
<ul>
<li>除了long和double之外的基本类型(int、byte、boolean、short、char、float)的读/写操作，都天然的具备原子性</li>
<li>所有引用reference的读/写操作</li>
<li>加了volatile后，所有变量的读/写操作(包含long/double)</li>
<li>java.concurrent.Atomic包中的一部分类的一部分方法，比如AtomicInteger的incrementAndGet</li>
</ul>
<p><strong>long和double的原子性</strong></p>
<p>long和double的值需要占用64位的内存空间，而对于64位值的写入，可以分为两个32位的操作进行。因此，本来是一个整体的赋值操作，就可能被拆分为低32位和高32位两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。</p>
<p>JVM的开发者可以自由选择是否把64位的long和double的读写操作作为原子操作去实现，并且规范推荐JVM将其实现为原子操作。</p>
<p><strong>原子操作 + 原子操作 != 原子操作</strong></p>
<h4 id="9-4-什么是内存可见性"><a href="#9-4-什么是内存可见性" class="headerlink" title="9.4 什么是内存可见性"></a>9.4 什么是内存可见性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内存可见性问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityProblem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"b="</span> + b + <span class="string">";a="</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            VisibilityProblem visibilityProblem = <span class="keyword">new</span> VisibilityProblem();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    visibilityProblem.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    visibilityProblem.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第1种情况：假设第1个线程，也就是执行change的线程先运行，并且运行完毕了，然后，第2个线程开始运行，打印出b=30;a=30</li>
<li>第2种情况：与第1种情况相反。因为线程先start，并不代表它真的先执行，所以第2种情况是第2个线程先打印b=20;a=10，然后第1个线程再去进行change</li>
<li>第3种情况：它们几乎同时运行，所以会出现交叉的情况。如第1个线程的change执行到一半，已经把a的值改为30了，而b的值还未来得及修改，此时第2个线程就开始打印，即打印结果为b=20;a=30</li>
<li>第4种情况：<strong>发生可见性问题</strong>，a的值已经被第1个线程修改了，但是其他线程却看不到，由于a的最新值没能及时同步过来，打印出b=30;a=10</li>
</ul>
<p><strong>volatile关键字解决可见性问题</strong></p>
<p><strong>synchronized不仅保证了原子性，还保证了可见性</strong></p>
<p>synchronized不仅保证了临界区内最多同时只有一个线程执行操作，同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。</p>
<h4 id="9-5-主内存与工作内存的关系"><a href="#9-5-主内存与工作内存的关系" class="headerlink" title="9.5 主内存与工作内存的关系"></a>9.5 主内存与工作内存的关系</h4><p><strong>CPU有多级缓存，导致读的数据过期</strong></p>
<p>为了提高CPU的整体运行效率，减少空闲时间，在CPU和内存之间会有cache层(缓存层)。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中L1缓存的速度仅次于寄存器的速度。</p>
<p><img data-src="../../../../assets/img/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt></p>
<p>线程间对于共享变量的可见性问题，并不是由多核引起的，而是由多级缓存引起的。每个核心在获取在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的L1缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。</p>
<p>假设core1修改了变量a的值，并写入到了core1的L1缓存里，但是还没来得及继续往下同步，由于core1有它自己的L1缓存，core4是无法直接获取core1的L1缓存的值，那么此时对于core4而言，变量a的值就不是core1修改后的最新的值，core4读取到的可能是一个过期的值，从而引起多线程时的可见性问题发生。</p>
<p><strong>JMM的抽象：主内存和工作内存</strong></p>
<p><img data-src="../../../../assets/img/Ciqah154fUGAS19LAAGap07f1AU762.png" alt></p>
<p>每个线程都只能直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是JMM控制的。</p>
<p><strong>主内存和工作内存的关系</strong></p>
<ol>
<li>所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容内容是主内存中该变量的拷贝。</li>
<li>线程不能直接读/写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改。</li>
<li>主内存是由多个线程所共享的，但线程之间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存主内存来完成。</li>
</ol>
<h4 id="9-6-什么是happens-before规则？"><a href="#9-6-什么是happens-before规则？" class="headerlink" title="9.6 什么是happens-before规则？"></a>9.6 什么是happens-before规则？</h4><p>Happens-before关系是用来描述可见性相关问题的：如果第一个操作happens-before第二个操作，那么可以认为第一个操作对于第二个操作一定是可见的。</p>
<p><strong>Happens-before的规则</strong></p>
<ol>
<li><p>单线程规则</p>
<p>在一个单独的线程中，按照程序代码的顺序，先执行的操作happens-before后执行的操作。</p>
<p><img data-src="../../../../assets/img/Ciqah157Dw6AfJVGAABiifLhJkU236.png" alt></p>
<p>但只要重排序后的结果依然符合happens-before关系，也就是能保持可见性的话，并不会限制重排序的发生。</p>
</li>
<li><p>锁操作规则(synchronized和Lock接口)</p>
<p>如果操作A是解锁，而操作B是对同一个锁的加锁，那么hb(A,B)。</p>
<p><img data-src="../../../../assets/img/Ciqah157Dw6Aeo7EAAA0bxPJeKw538.png" alt></p>
</li>
<li><p>volatile变量规则</p>
<p>对于一个volatile变量的写操作happens-before后面对该变量的读操作。</p>
</li>
<li><p>线程启动规则</p>
<p>Thread对象的start方法happens-before此线程run方法中的每一个操作。</p>
<p><img data-src="../../../../assets/img/Cgq2xl57Dw6AdKyOAADBt-00qXo349.png" alt></p>
</li>
<li><p>线程join规则</p>
<p>join可以让线程之间等待，假设线程A通过调用threadB.start()启动了一个新线程B，然后调用threadB.join()，那么线程A将一直等待到线程B的run方法结束(不考虑中断等特殊情况)，然会join方法才返回。在join方法返回后，线程A中的所有后续操作都可以看到线程B的run方法执行的所有操作的结果，也就是线程B的run方法里面的操作hanppens-before线程A的join之后的语句。</p>
<p><img data-src="../../../../assets/img/Cgq2xl57Dw6ADE7rAADRJKFrbWE816.png" alt></p>
</li>
<li><p>中断规则</p>
<p>对线程interrupt方法的调用happens-before检测该线程的中断事件。</p>
</li>
<li><p>并发工具类的规则</p>
<ul>
<li>线程安全的并发容器(如ConcurrentHashMap)在get某个值时一定能看到在此之前发生的put等存入操作的结果。</li>
<li>信号量(Semaphore)会释放许可证，也会获取许可证。释放许可证的操作happens-before获取许可证的操作。</li>
<li>Future：当Future的get方法得到结果的时候，一定可以看到之前任务中所有的操作。</li>
<li>线程池：提交任务的操作happens-before任务的执行。</li>
</ul>
</li>
</ol>
<h4 id="9-7-volatile的作用是什么？与synchronized有什么异同？"><a href="#9-7-volatile的作用是什么？与synchronized有什么异同？" class="headerlink" title="9.7 volatile的作用是什么？与synchronized有什么异同？"></a>9.7 volatile的作用是什么？与synchronized有什么异同？</h4><p>volatile是Java中的一个关键字，是一种同步机制。当某个变量是共享变量，且这个变量被volatile修饰，那么在修改了这个变量的值之后，再读取该变量的值时，可以保证获取到的是修改后的最新的值。</p>
<p>相比于synchronized或者Lock，volatile更加轻量，因为使用volatile不会发生上下文切换等开销很大的情况，不会让线程阻塞。</p>
<p><strong>volatile不适用于a++</strong></p>
<p>volatile不适合运用于需要保证原子性的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a++ 不适合使用volatile</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DontVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line">    AtomicInteger realA = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DontVolatile dontVolatile = <span class="keyword">new</span> DontVolatile();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(dontVolatile);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(dontVolatile);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(dontVolatile.a);</span><br><span class="line">        System.out.println(dontVolatile.realA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            realA.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1926</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场合1：布尔标记位</strong></p>
<p>第一个例子的操作是a++，这是个复合操作，不具备原子性，而下面这个例子只是把flag设置为true，这样的赋值操作本身就是具备原子性的，所以适合使用volatile。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以使用volatile的场景 布尔标记位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YesVolatile1</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="literal">false</span>;</span><br><span class="line">    AtomicInteger realA = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;</span><br><span class="line">        YesVolatile1 yesVolatile1 = <span class="keyword">new</span> YesVolatile1();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(yesVolatile1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(yesVolatile1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.<span class="built_in">println</span>(yesVolatile1.flag);</span><br><span class="line">        System.out.<span class="built_in">println</span>(yesVolatile1.realA);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            realA.incrementAndGet();</span><br><span class="line">            setDone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场合2：作为触发器，保证其他变量的可见性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line">. . .</span><br><span class="line"><span class="comment">// In thread A</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line">. . .</span><br><span class="line"><span class="comment">// In thread B</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) </span><br><span class="line">  sleep();</span><br><span class="line"><span class="comment">// use configOptions</span></span><br></pre></td></tr></table></figure>

<p>happens-before具有传递性，根据happens-before的单线程规则，线程A中configOptions的初始化happens-before对iniialized变量的写入，而线程B中对initialized的读取happens-before对configOptions变量的使用，同时根据happens-before关系的volatile规则，线程A中对initialized的写入为true的操作happens-before线程B中随后对initialized变量的读取。</p>
<p><strong>volatile的作用</strong></p>
<ol>
<li><p>保证可见性</p>
<p>对于一个volatile变量的写操作happen-before后面对该变量的读操作，即如果变量被volatile修饰，那么每次修改之后，接下来在读取这个变量的时候一定能读到该变量的最新值。</p>
</li>
<li><p>禁止重排序</p>
<p>as-if-serial：不管怎么重排序，单线程的执行结果不变。多线程情况下的重排序可能会导致严重的线程安全问题。使用volatile关键字可以在一定程度上禁止这种重排序。</p>
</li>
</ol>
<p><strong>volatile和synchronized的关系</strong></p>
<p>相似性：volatile可以看作是一个轻量版的synchronized，如果一个共享变量如果自始至终只被各个线程赋值和读取，而没有其他操作的话，那么就可以用volatile来代替synchronized或者代替原子变量。</p>
<p>不可代替：volatile是不能代替synchronized的，volatile并没有提供原子性和互斥性的。</p>
<p>性能方面：volatile的读写操作都是无锁的，比synchronized性能更好。</p>
<h4 id="9-8-单例模式的双重检查锁模式为什么必须加volatile？"><a href="#9-8-单例模式的双重检查锁模式为什么必须加volatile？" class="headerlink" title="9.8 单例模式的双重检查锁模式为什么必须加volatile？"></a>9.8 单例模式的双重检查锁模式为什么必须加volatile？</h4><p>单例模式：保证一个类只有一个实例，并且提供一个可以全局访问的入口。</p>
<p><strong>为什么需要使用单例模式？</strong></p>
<ol>
<li><p>为了节省内存、节省计算。</p>
</li>
<li><p>保证结果正确。</p>
</li>
<li><p>方便管理。</p>
<p>有一个私有的Singleton类型的singleton对象；同时构造方法也是私有的，为了防止他人调用构造函数来生成实例；还有一个public的getInstance方法，可通过这个方法获取到单例。</p>
</li>
</ol>
<p><strong>双重检查锁模式的写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile 双重检查锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行了两次if(singleton==null)检查，即”双重检查锁”。假设有两个线程同时到达synchronized语句块，那么实例化代码只会由其中先抢到锁的线程执行一次，而后抢到锁的线程会在第二个if判断中发现singleton不为null，所以跳过创建实例的语句。再后面的其他线程再来调用getInstance方法时，只需判断第一次的if(singleton==null)，然后跳过整个if块，直接return实例化后的对象。</p>
<p><strong>为什么需要双重检查？</strong></p>
<p>如果有两个线程同时调用getInstance方法，由于singleton是空的，因此两个线程可以通过第一重if的检查，然后由于锁的存在，会有一个线程先进入同步语句，并进入第二重检查，而另外一个线程就在外面等待。不过当第一个线程执行完new Singleton()语句后，就会退出synchronized保护的区域，这时如果没有第二重if(singleton==null)判断的话，那么第二个线程也会创建一个实例，破环了单例。</p>
<p>如果去掉第一个检查，那么所有线程都会串行执行，效率低下。</p>
<p><strong>双重检查模式中为什么需要使用volatile关键字？</strong></p>
<p>singleton = new Singleton() 并非是一个原子操作，在JVM中至少做了以下3件事。</p>
<p><img data-src="../../../../assets/img/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png" alt></p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数，来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步singleton就不是null了)</li>
</ol>
<p>因为存在指令排序的优化，所以第2，3步的顺序是不能保证的，最终的执行顺序可能是1-2-3，也有可能是1-3-2。</p>
<p>如果是1-3-2：</p>
<p><img data-src="../../../../assets/img/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png" alt></p>
<p>使用volatile之后，相当于是表明了该字段的更新可能是在其他线程中发生的，在JDK5及后续版本所使用的JMM中，在使用了volatile后，会在一定程度禁止相关语句的重排序。</p>
<h3 id="10-CAS"><a href="#10-CAS" class="headerlink" title="10.CAS"></a>10.CAS</h3><h4 id="10-1-什么是CAS"><a href="#10-1-什么是CAS" class="headerlink" title="10.1 什么是CAS?"></a>10.1 什么是CAS?</h4><p>CAS(Compare And Swap)，是一种思想，为了保证并发安全，可以使用互斥锁，而CAS的特点就是避免使用互斥锁，当多个线程同时使用CAS更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并<strong>不会被阻塞</strong>，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。</p>
<p><strong>CAS的思路</strong></p>
<p>CAS相关的指令是具备原子性的，”<strong>比较和交换</strong>“操作在执行期间不会被打断。</p>
<p>CAS有3个操作数：内存值V，预期值A、要修改的值B。当预期值A和当前的内存值V相同时，才将内存值修改为B。</p>
<p>CAS会提前假定当前内存值V应该等于值A，而值A往往是之前读取到当时的内存值V，如果发现当前的内存值V恰好是值A的话，那CAS就会把内存值V改成B。如果执行CAS时发现此时的内存值V不等于值A，则说明在刚才计算B的期间内，内存值已经被其他线程修改过了，那么本次CAS就不应该再修改了。</p>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟CAS操作 等价代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAngSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SimulatedCAS simulatedCAS = <span class="keyword">new</span> SimulatedCAS();</span><br><span class="line">        simulatedCAS.value = <span class="number">100</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(simulatedCAS);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(simulatedCAS);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(simulatedCAS.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compareAngSwap(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-CAS的应用"><a href="#10-2-CAS的应用" class="headerlink" title="10.2 CAS的应用"></a>10.2 CAS的应用</h4><p><strong>并发容器</strong></p>
<ol>
<li><p>ConcurrentHashMap</p>
<p>putVal方法部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>casTabAt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>U是Unsafe类型的，Unsafe类包含compareAndSwapInt、compareAndSwapLong、compareAndSwapObject等和CAS密切相关的native层的方法，其底层正是利用CPU对CAS指令的支持实现的。</p>
</li>
<li><p>ConcurrentLinkedQueue</p>
<p>非阻塞并发队列ConcurrentLinkedQueue的offer方法里也有CAS的身影，offer方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    casTail(t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>数据库</strong></p>
<p>在更新数据时，可以利用version字段在数据库中实现乐观锁和CAS操作，而在获取和修改数据时都不需要加悲观锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">	<span class="keyword">name</span> = ‘小王’, <span class="keyword">version</span> = <span class="number">2</span>        </span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">	<span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">AND</span> <span class="keyword">version</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>先去比较version是不是最开始获取到的1，如果和初始值相同才去进行name字段的修改，同时也要把version的值加1。</p>
<p><strong>原子类</strong></p>
<p>在原子类中，如AtomicInteger，也使用了CAS。如AtomicInteger的getAndAdd方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>var1</th>
<th>o</th>
<th>object</th>
<th>将要修改的对象，传入的是this，也就是atomicInteger这个对象本身</th>
</tr>
</thead>
<tbody><tr>
<td>var2</td>
<td>offset</td>
<td>offset</td>
<td>偏移量，借助它就可以获取到oldvalue的数值</td>
</tr>
<tr>
<td>var5</td>
<td>v</td>
<td>expectedValue</td>
<td>代表”期望值”</td>
</tr>
<tr>
<td>var5+var4</td>
<td>v+delta</td>
<td>newValue</td>
<td>希望修改为的新值，var4就是希望原子类所改变的数值，比如可以传入+1，也可以传入-1</td>
</tr>
</tbody></table>
<p>Unsafe的getAndAddInt方法是通过<strong>循环+CAS</strong>的方式来实现的，在此过程中，它会通过compareAndSwapInt方法来尝试更新value的值，如果更新失败就重新获取，然后再次更新，直到更新成功。</p>
<h4 id="10-3-CAS有什么缺点？"><a href="#10-3-CAS有什么缺点？" class="headerlink" title="10.3 CAS有什么缺点？"></a>10.3 CAS有什么缺点？</h4><p><strong>ABA问题</strong></p>
<p>CAS检查的并不是值有没有发生过变化，而是去比较这当前值和预期值是不是相等，如果变量的值从旧值A变成了新值B再变回旧值A，由于最开始是值A和现在的值A是相等的，所以CAS会认为变量的值在此期间没有发生过变化。所以，<strong>CAS并不能检测在此期间值是不是被修改过，它只能检查出现在的值和最初的值是不是一样</strong>。</p>
<p>在变量自身之外，再添加一个<strong>版本号</strong>，A-&gt;B-&gt;A，1A-&gt;2B-&gt;3A，可以通过版本号来判断值是否变化过。</p>
<p>atomic包中提供了<strong>AtomicStampedReference</strong>这个类，它是专门用来解决ABA问题，解决思路正是利用版本号，AtomicStampedReference会维护一种类似&lt;Object,int&gt;的数据结构，其中的int就是用于计数的，也就是版本号。</p>
<p><strong>自旋时间过长</strong></p>
<p>由于单次CAS不一定能执行成功，所以<strong>CAS往往是配合着循环来实现的</strong>，有的时候甚至是死循环，不停重试，直到竞争不激烈的时候，才能修改成功。</p>
<p>如果是<strong>高并发场景</strong>，有可能导致CAS一直操作不成功，循环的时间会越来越长。CPU资源一直在被消耗，会对性能产生很大的影响，高并发情况下，通常CAS的效率是不高的。</p>
<p><strong>范围不能灵活控制</strong></p>
<p>通常执行CAS的时候，是针对某一个，而不是多个共享变量的，多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。</p>
<p>有一个解决方案就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用atomic包中的AtomicReference来把这个新对象整体进行CAS操作。</p>
<p>相比之下，如使用synchronized关键字时，如果想把更加的代码加锁，<strong>只需把更多的代码放到同步代码块里面</strong>就可以了。</p>
<h3 id="11-死锁问题"><a href="#11-死锁问题" class="headerlink" title="11.死锁问题"></a>11.死锁问题</h3><h4 id="11-1-写一个必然死锁的例子"><a href="#11-1-写一个必然死锁的例子" class="headerlink" title="11.1 写一个必然死锁的例子"></a>11.1 写一个必然死锁的例子</h4><p><strong>什么是死锁？</strong></p>
<p><strong>发生在并发中</strong>，两个或多个线程(或进程)被无限期的阻塞，相互等待对方手中资源。</p>
<p><strong>例子</strong></p>
<p>两个线程：</p>
<p><img data-src="../../../../assets/img/Cgq2xl6NrzGAMfz3AABHRjw_QSE080.png" alt></p>
<p>多个线程：</p>
<p><img data-src="../../../../assets/img/Cgq2xl6NrzGAeQrqAAA0YIeU1Qg392.png" alt></p>
<p><strong>死锁的影响</strong></p>
<p>数据库中：</p>
<p>在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能会发生死锁的情况。当数据库检测到这一组事务发生了死锁，根据策略的不同，可能会选择放弃一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其它事务继续进行。此时程序可以重新执行被强行终止的事务。</p>
<p>JVM中：</p>
<p>JVM并不会自动进行处理，发生几率不高但危害大，在巨量的次数面前，整个系统发生问题的几率也会被放大。</p>
<p><strong>发生死锁的例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必然死锁的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"的flag为"</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()+<span class="string">"获取到了两把锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()+<span class="string">"获取到了两把锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MustDeadLock mustDeadLock1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock mustDeadLock2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        mustDeadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        mustDeadLock2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(mustDeadLock1,<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(mustDeadLock2,<span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程thread1的flag为<span class="number">1</span></span><br><span class="line">线程thread2的flag为<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当第1个线程运行的时候，它会发现自己的flag是1，所以它会尝试先获得object1这把锁，然后休眠500毫秒。</li>
<li>在线程1启动并休眠的期间，线程2同样会启动。由于线程2的flag是2，所以线程2首先会去获取object2这把锁，然后休眠500毫秒。</li>
<li>当线程1的500毫秒休眠时间结束，它会尝试去获取object2这把锁，此时object2这把锁正在被线程2持有，所以线程1无法获取到object2。</li>
<li>紧接着线程2也会苏醒过来，它将尝试获取object1这把锁，此时object1已被线程1持有。</li>
</ul>
<p>线程1卡在获取object2这把锁的位置，而线程2卡在获取object1这把锁的位置。</p>
<h4 id="11-2-发生死锁的4个必要条件"><a href="#11-2-发生死锁的4个必要条件" class="headerlink" title="11.2 发生死锁的4个必要条件"></a>11.2 发生死锁的4个必要条件</h4><ul>
<li><p><strong>互斥条件</strong></p>
<p>每个资源每次只能被一个线程(或进程)使用。</p>
</li>
<li><p><strong>请求与保持条件</strong></p>
<p>当一个线程因请求资源而阻塞时，则需对已获得的资源保持不放。</p>
</li>
<li><p><strong>不剥夺条件</strong></p>
<p>线程已获得的资源，在未使用完之前，不会被强行剥夺。</p>
</li>
<li><p><strong>循环等待条件</strong></p>
<p>只有若干个线程之间形成一种头尾相接的循环等待资源关系时，才有可能形成死锁。</p>
</li>
</ul>
<h4 id="11-3-如何定位死锁？"><a href="#11-3-如何定位死锁？" class="headerlink" title="11.3 如何定位死锁？"></a>11.3 如何定位死锁？</h4><ul>
<li><p>命令：<strong>jstack</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\IDEAProbject\JavaStudyDemo\Multithreading&gt;jps</span><br><span class="line">3044 Launcher</span><br><span class="line">4084 MustDeadLock</span><br><span class="line">11816 Jps</span><br><span class="line"></span><br><span class="line">D:\IDEAProbject\JavaStudyDemo\Multithreading&gt;jstack 4084</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"thread2":</span><br><span class="line">  waiting to lock monitor 0x000000001c601e68 (object 0x0000000776319ce0, a java.lang.Object),</span><br><span class="line">  which is held by "thread1"</span><br><span class="line">"thread1":</span><br><span class="line">  waiting to lock monitor 0x000000001c6047a8 (object 0x0000000776319cf0, a java.lang.Object),</span><br><span class="line">  which is held by "thread2"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"thread2":</span><br><span class="line">        at com.example.MustDeadLock.run(MustDeadLock.java:34)</span><br><span class="line">        - waiting to lock &lt;0x0000000776319ce0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x0000000776319cf0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"thread1":</span><br><span class="line">        at com.example.MustDeadLock.run(MustDeadLock.java:22)</span><br><span class="line">        - waiting to lock &lt;0x0000000776319cf0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x0000000776319ce0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码：<strong>ThreadMXBean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必然死锁的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MustDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"的flag为"</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获取到了两把锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获取到了两把锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MustDeadLock mustDeadLock1 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        MustDeadLock mustDeadLock2 = <span class="keyword">new</span> MustDeadLock();</span><br><span class="line">        mustDeadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        mustDeadLock2.flag = <span class="number">2</span>;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(mustDeadLock1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(mustDeadLock2, <span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="keyword">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="keyword">null</span> &amp;&amp; deadlockedThreads.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deadlockedThreads.length; i++) &#123;</span><br><span class="line">                ThreadInfo threadInfo = threadMXBean.getThreadInfo(deadlockedThreads[i]);</span><br><span class="line">                System.out.println(threadInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程thread1的flag为<span class="number">1</span></span><br><span class="line">线程thread2的flag为<span class="number">2</span></span><br><span class="line"><span class="string">"thread2"</span> Id=<span class="number">21</span> BLOCKED on java.lang.Object@<span class="number">27</span>d6c5e0 owned by <span class="string">"thread1"</span> Id=<span class="number">20</span></span><br><span class="line"><span class="string">"thread1"</span> Id=<span class="number">20</span> BLOCKED on java.lang.Object@<span class="number">4f</span>3f5b24 owned by <span class="string">"thread2"</span> Id=<span class="number">21</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="11-4-解决死锁问题的策略"><a href="#11-4-解决死锁问题的策略" class="headerlink" title="11.4 解决死锁问题的策略"></a>11.4 解决死锁问题的策略</h4><ul>
<li><p><strong>避免策略</strong></p>
<p>优化代码逻辑，从根本上消除发生死锁的可能性，如调整锁的获取顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整锁的获取顺序来避免死锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> Account a = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> Account b = <span class="keyword">new</span> Account(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(b, a, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="comment">// 先获取两把锁，然后开始转账</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足，转账失败！"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    from.balance -= account;</span><br><span class="line">                    to.balance += account;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + account + <span class="string">"元！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toHash &gt; fromHash) &#123;</span><br><span class="line">            <span class="comment">// 先获取两把锁，然后开始转账</span></span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足，转账失败！"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    from.balance -= account;</span><br><span class="line">                    to.balance += account;</span><br><span class="line">                    System.out.println(<span class="string">"成功转账"</span> + account + <span class="string">"元！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TransferMoney r1 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        TransferMoney r2 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"a的余额"</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">"b的余额"</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务实际上不在乎获取锁的顺序，调整获取锁的顺序，使先获取的账户是”转入”或”转出”无关，而是使<strong>用HashCode的值来决定顺序</strong>，从而保证线程安全。但依然有极小的概率会发生HashCode相同的情况，在实际生产中，需要排序的往往是一个实体类，而一个实体类一般都会具有主键ID，<strong>主键ID具有唯一、不重复的特点</strong>，直接使用主键ID排序，按照主键ID的大小来决定获取锁的顺序，以确保避免死锁。</p>
</li>
<li><p><strong>检测与恢复策略</strong></p>
<p>先允许系统发生死锁，然后再解除。例如系统可以在每次调用锁的时候，都记录下来调用信息，形成一个”锁的调用链图”，然后隔一段时间就用死锁检测算法来检测一下，搜索这个图中是否存在环路，一旦发生死锁，就可以用死锁恢复机制，解开死锁，进行恢复。</p>
<ol>
<li><p>线程终止</p>
<p>系统逐个去终止已经陷入死锁的线程，线程被终止，同时释放资源，死锁就会被解开。有各种各样的算法和策略，根据实际业务进行调整。</p>
<ul>
<li><p>优先级</p>
<p>先终止优先级低的线程。</p>
</li>
<li><p>已占用资源、还需要的资源</p>
<p>如果某线程已经占有了一大堆资源，只需要最后一点点资源就可以顺利完成任务，那么系统会优先终止别的线程来优先促成该线程的完成。</p>
</li>
<li><p>已经运行时间</p>
<p>如果某线程已经运行很多天了，很快就要完成任务了，可以让那些刚刚开始运行的线程终止，并在之后把它们重新启动，这样成本更低。</p>
</li>
</ul>
</li>
<li><p>资源抢占</p>
<p>不需要把整个线程终止，而是只需要把它已经获得的资源进行剥夺，如让线程回退几步、释放资源，这样就不需要终止掉整个线程，成本更低。但如果算法不好的话，我们抢占的那个线程可能一直是同一个线程，就会造成饥饿线程，即这个线程一直被剥夺它已经得到的资源，那么它就长期得不到运行。</p>
</li>
</ol>
</li>
<li><p>鸵鸟策略</p>
<p>如果系统发生死锁的概率极低，并且一旦发生其后果不是特别严重，可以先选择忽略它，直到发生死锁后，再人工修复。</p>
</li>
</ul>
<h3 id="12-final关键字"><a href="#12-final关键字" class="headerlink" title="12.final关键字"></a>12.final关键字</h3><h4 id="12-1-final的三种用法"><a href="#12-1-final的三种用法" class="headerlink" title="12.1 final的三种用法"></a>12.1 final的三种用法</h4><p><strong>final修饰变量</strong></p>
<p>final修饰的变量，<strong>一旦被赋值就不能被修改了</strong>。</p>
<p>目的：1.设计角度    2.线程安全</p>
<p>赋值时机：</p>
<ul>
<li><p>成员变量，类中的非static修饰的属性</p>
<ol>
<li><p>在变量的等号右边直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldAssignment1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> finalVar = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造函数中赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalFieldAssignment2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> finalVar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalFieldAssignment2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        finalVar = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的构造代码块中赋值(不常用)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalFieldAssignment3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> finalVar;</span><br><span class="line">    &#123;</span><br><span class="line">        finalVar = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><p>静态变量，类中的被static修饰的属性</p>
<ol>
<li><p>在声明变量的等号右边直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFieldAssignment1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个静态的static初始代码块中赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticFieldAssignment2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>static的final变量不能在构造函数中进行赋值</strong></p>
</li>
<li><p>局部变量，方法中的变量</p>
<p>使用前赋值即可</p>
</li>
</ul>
<p>final修饰参数，意味着在方法内部无法对参数进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalPara</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withFinal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//可以读取final参数的值</span></span><br><span class="line"><span class="comment">//        a = 9; //编译错误，不允许修改final参数的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final修饰方法</strong></p>
<ol>
<li>提高效率，早期的Java版本，会把final修饰的方法转为内嵌调用，消除方法调用的开销。</li>
<li><strong>final修饰的方法不可以被重写</strong>。</li>
</ol>
<p>final的private方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateFinalMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">privateEat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword">extends</span> <span class="title">PrivateFinalMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">privateEat</span><span class="params">()</span> </span>&#123;<span class="comment">//编译通过，但这并不是真正的重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的所有private方法都是隐式的指定为自动被final修饰的，由于这个方法是private类型的，所以对于子类而言，根本获取不到父类这个方法，更别说重写了。所以其实子类并没有真正意义上的去重写父类的privateEat方法，只是方法名碰巧一样而已。</p>
<p><strong>final修饰类</strong></p>
<p><strong>final修饰的类不可被继承</strong></p>
<p>类是final的，不代表里面的属性就会自动加上final。</p>
<p>final的类里面，所有的方法，不论是public、private还是其他权限修饰符修饰的，都会自动的、隐式的被指定为是final的。</p>
<h4 id="12-2-为什么加了final却依然无法拥有”不变性”？"><a href="#12-2-为什么加了final却依然无法拥有”不变性”？" class="headerlink" title="12.2 为什么加了final却依然无法拥有”不变性”？"></a>12.2 为什么加了final却依然无法拥有”不变性”？</h4><p>如果对象在被创建之后，其状态就不能修改了，那么它就具备”不变性”。</p>
<p><strong>final修饰对象时，只是引用不可变。</strong>当用final去修饰一个指向对象类型(而不是指向8种基本数据类型)的变量的时候，那么final起到的作用只是保证则个变量的引用不可变，而对象本身的内容依然是可变化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">20</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123; </span><br><span class="line">       <span class="keyword">final</span> Test t = <span class="keyword">new</span> Test();</span><br><span class="line">       t.p = <span class="number">30</span>; </span><br><span class="line">       System.out.println(t.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">//  注意，数组 arr 是 final 的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           arr[i] = arr[i]*<span class="number">10</span>;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>final修饰一个指向对象的变量的时候，对象本身的内容依然是可以变化的。</p>
<p><strong>final和不可变的关系</strong></p>
<p>final可以确保变量的引用保持不变，但是不变性意味着对象一旦创建完毕就不能改变其状态，<strong>它强调的是对象内容本身，而不是引用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; lessons = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lessons.add(<span class="string">"第01讲：为何说只有 1 种实现线程的方法？"</span>);</span><br><span class="line">        lessons.add(<span class="string">"第02讲：如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？"</span>);</span><br><span class="line">        lessons.add(<span class="string">"第03讲：线程是如何在 6 种状态之间转换的？"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLesson</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lessons.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含对象类型的成员变量的类的对象，具备不可变性的例子：对于ImmutableDemo类而言，它只有这么一个成员变量，而这个成员变量一旦构造完毕后又不能改变。</p>
<h4 id="12-3-为什么String被设计为是不可变的？"><a href="#12-3-为什么String被设计为是不可变的？" class="headerlink" title="12.3 为什么String被设计为是不可变的？"></a>12.3 为什么String被设计为是不可变的？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"lagou"</span>;</span><br><span class="line">s = <span class="string">"la"</span>;</span><br><span class="line"></span><br><span class="line">String lagou = <span class="string">"lagou"</span>;</span><br><span class="line">lagou = lagou.subString(<span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>只不是建了一个新的字符串而已，并把引用重新指向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private final的char数组value，存储着字符串的每一位字符，value一旦被赋值，引用就不能修改了；并且在String的源码中，除构造函数之外，并没有任何其他方法会修改value数组里面的内容，而value的权限是private，外部的类也访问不到，所以value是不可变的。String类是被final修饰的，所以这个String类是不会被继承的。</p>
<p><strong>String不变的好处</strong></p>
<ol>
<li><p>字符串常量池</p>
</li>
<li><p>用作HashMap的key</p>
<p>对于key来说，最重要的就是不可变，这样才能利用它去检索存储在HashMap里面的value。由于HashMap的工作原理是Hash，也就是散列，所以需要对象始终拥有相同的Hash值才能正常运行。</p>
</li>
<li><p>缓存HashCode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the String */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br></pre></td></tr></table></figure>

<p>在String类中有一个hash属性，保存的是String对象的HashCode。因为String是不可变的，所以对象一旦被创建之后，HashCode的值也就不可能变化了，就可以把HashCode缓存起来。以后每次想用到HashCode的时候，不需要重新计算，直接返回缓存过的hash的值就可以了，所以使得字符串非常适合用作HashMap的key。</p>
</li>
<li><p>线程安全</p>
<p>线程安全，具备不变性的对象一定是线程安全的，避免了很多不必要的同步操作。</p>
</li>
</ol>
<h3 id="13-AQS"><a href="#13-AQS" class="headerlink" title="13.AQS"></a>13.AQS</h3><h4 id="13-1-为什么需要AQS"><a href="#13-1-为什么需要AQS" class="headerlink" title="13.1 为什么需要AQS?"></a>13.1 为什么需要AQS?</h4><p><img data-src="../../../../assets/img/02021203223.png" alt></p>
<p>AQS在ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、ThreadPoolExcutor中都有运用(JDK1.8)，AQS是这些类的底层原理。</p>
<p>AQS是一个用于构建锁、同步器等线程协作工具类的框架，有了AQS之后，可以让更上层的开发极大的减少工作量，避免重复造轮子，同时也避免了上层因处理不当而导致的线程安全问题，因为AQS把这些事情都做好了。总之，有了AQS之后，构建线程协作工具类就容易多了。</p>
<h4 id="13-2-AQS内部原理"><a href="#13-2-AQS内部原理" class="headerlink" title="13.2 AQS内部原理"></a>13.2 AQS内部原理</h4><p><strong>状态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>state的含义并不是一成不变的，它会根据具体实现类的作用不同而表示不同的含义。</p>
<p>比如在信号量里，state表示的是剩余许可证的数量。当某一个线程衢州一个许可证之后，state会减1。</p>
<p>在CountDownLatch工具类里，state表示的是需要”倒数”的数量。每次调用CountDown方法时，state就会减1，直到减为0就代表这个”门闩”被放开。</p>
<p>在ReentrantLock中表示的是锁的占有情况。最开始是0，表示没有任何线程占有锁，如果state变成1，就代表这个锁已经被某一个线程所持有了。因为ReentrantLock是可重入的，同一个线程可以再次拥有这把锁就叫重入。如果这个锁被同一个线程多次获取，那么state就会逐渐的往上加，state的值表示重入的次数。在释放的时候也是逐步递减。</p>
<p>compareAndSetState：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用了Unsafe里面的CAS操作，利用CPU指令的原子性保证了这个操作的原子性。</p>
<p>setState：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于基本类型的变量进行直接赋值时，如果加了volatile就可以保证它的线程安全。</p>
<p><strong>FIFO队列</strong></p>
<p>先进先出队列，主要的作用是存储等待的线程。当多个线程去竞争同一把锁的时候，就需要用排队机制把那些没拿到锁的线程串在一起；而当前面的线程释放锁之后，这个管理器就会挑选一个合适的线程来尝试抢刚刚释放的那把锁。</p>
<p>队列内部是双向链表的形式：</p>
<p><img data-src="../../../../assets/img/Ciqc1F6pW3CAHYjKAACSEPDrUoc078.png" alt></p>
<p>在队列中，分别用head和tail来表示头节点和尾节点，两者在初始化的时候指向一个空节点。头节点可以理解为”当前持有锁的线程”，而在头节点之后的线程被阻塞了，它们会等待被唤醒，唤醒也是由AQS负责操作的。</p>
<p><strong>获取/释放方法</strong></p>
<ul>
<li><p>获取方法</p>
<p>获取操作通常会依赖state变量的值，获取方法在不同类中代表不同的含义，但往往和state值相关，也经常会让线程进入阻塞状态。</p>
<p>如ReentrantLock中的lock方法，执行时如果发现state不等于0且当前线程不是持有锁的线程，那么就代表这个锁已经被其他线程所持有了，这个时候，当然获取不到锁，于是就让该线程进入阻塞状态。</p>
<p>Semaphore中的acquire，作用是获取许可证。如果state是正数，那么代表还有剩余的许可证，数量足够就可以获取成功；但如果state是0，则代表已经没有更多的空余许可证了，会进入阻塞状态。</p>
<p>CountDownLatch获取方法就是await方法，作用是”等待，直到倒数结束”。执行await的时候会判断state的值，如果state不等于0，线程就进入阻塞状态，直到其他线程执行倒数方法把state减为0，此时就代表这个门闩放开了，所以之前阻塞的线程就会被唤醒。</p>
</li>
<li><p>释放方法</p>
<p>释放方法通常是不会阻塞线程的。</p>
<p>比如在Semaphore信号量，释放就是release方法，release()方法的作用是去释放一个许可证，会让state加1；而在CountDownLatch里面，释放就是countDown方法，作用是倒数一个数，让state减1。</p>
</li>
</ul>
<h4 id="13-3-AQS在CountDownLatch中应用原理"><a href="#13-3-AQS在CountDownLatch中应用原理" class="headerlink" title="13.3 AQS在CountDownLatch中应用原理"></a>13.3 AQS在CountDownLatch中应用原理</h4><p><strong>AQS用法</strong></p>
<ol>
<li>新建一个自己的线程协作工具类，在内部写一个Sync类，该类继承AbstractQueueSynchronizer，即AQS。</li>
<li>在Sync类中，根据是否是独占来重写对应的方法。独占，则重写tryAcquire和tryRelease等方法；非独占，则重写tryAcquireShared和tryReleaseShared等方法。</li>
<li>在自己的线程协作工具类中，实现获取/释放的相关方法，并在里面调用AQS对应的方法，独占调用acquire或release等方法；非独占调用acquireShared或releaseShared或acquireSharedInterruptibly。</li>
</ol>
<p><strong>AQS在CountDownLatch的应用</strong></p>
<p>在CountDownLatch里面有一个子类Sync，这个类正是继承自AQS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch.</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">   <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDown构造函数将传入的count最终传递到AQS内部的state变量，给state赋值，state就代表还需要倒数的次数。</p>
<p>getCount：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终获取到的就是Sync中state的值。</p>
<p>countDown：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync中的tryReleaseShared()，doReleaseShared()对之前阻塞的线程进行唤醒。</p>
<p>await：</p>
<p>该方法时CountDownLatch的”获取”方法，调用await会把线程阻塞，直到倒数为0才能继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync中的tryAcquireShared()，doAcquireSharedInterruptibly()会让线程进入阻塞状态。</p>
<p><strong>总结</strong></p>
<p>当线程调用CountDownLatch的await方法时，便会尝试获取”共享锁”，不过一开始通常获取不到锁，于是线程被阻塞。”共享锁”可以获取到的条件是”锁计数器”的值为0，而”锁计数器”的初始值为count，当每次调用CountDownLatch对象的countDown方法时，也可以把”锁计数器”-1。直到”锁计数器”为0，于是之前等待的线程就会继续运行了，并且此时如果再有线程想调用await方法时也会立刻放行，不会再去做任何阻塞操作了。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
