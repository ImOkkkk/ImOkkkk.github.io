<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="code-wyV34cCXc4" />
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="bUCDF5pEQe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66522575" charset="UTF-8"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imokkkk.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.基础篇1.1 一条SQL查询语句是如何执行的？  Server层 连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。">
<meta name="keywords" content="MySQL,数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="https://imokkkk.github.io/mysql/index.html">
<meta property="og:site_name" content="ImOkkkk BLOG">
<meta property="og:description" content="1.基础篇1.1 一条SQL查询语句是如何执行的？  Server层 连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-06-20T06:28:14.931Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL">
<meta name="twitter:description" content="1.基础篇1.1 一条SQL查询语句是如何执行的？  Server层 连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。">

<link rel="canonical" href="https://imokkkk.github.io/mysql/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | ImOkkkk BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ImOkkkk BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ImOkkkk BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">When they go low,we go high.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">35</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://imokkkk.github.io/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../assets/img/head.jpg">
      <meta itemprop="name" content="ImOkkkk">
      <meta itemprop="description" content="Java开发, 后端开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ImOkkkk BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-06 16:06:55" itemprop="dateCreated datePublished" datetime="2021-06-06T16:06:55+08:00">2021-06-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1.基础篇"></a>1.基础篇</h3><h4 id="1-1-一条SQL查询语句是如何执行的？"><a href="#1-1-一条SQL查询语句是如何执行的？" class="headerlink" title="1.1 一条SQL查询语句是如何执行的？"></a>1.1 一条SQL查询语句是如何执行的？</h4><p><img data-src="../assets/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt></p>
<ul>
<li><p>Server层</p>
<p>连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。</p>
<a id="more"></a>
</li>
<li><p>存储引擎层</p>
<p>负责数据的存储和提取。支持InnoDB、MyISAM、Memory等多个存储引擎。MySQL5.5.5版本后默认使用InnoDB。</p>
</li>
</ul>
<ol>
<li><p>连接器</p>
<p>连接器负责与客户端建立连接、获取权限、维持和管理连接。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&#123;ip&#125; -P&#123;port&#125; -u&#123;user&#125; -p</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一个用户成功建立连接后，即使使用管理员账户对该用户的权限做了修改，也不会影响已经存在的连接权限，只有新建的连接才会使用新的权限设置。</p>
</li>
<li><p>show processlist 可以查看各连接状态</p>
<p><img data-src="../assets/img/f2da4aa3a672d48ec05df97b9f992fed.png" alt></p>
<p>“Sleep”表示空闲连接，如果客户端太长时间没动静(wait_timeout，默认8小时)，连接器自动断开。</p>
</li>
<li><p>数据库长连接指连接成功后，客户端持续有请求，则一直使用同一个连接；短连接指每次执行完几次查询后就断开连接，下次查询再重新建立。MySQL在执行过程中临时使用的内存是管理在连接对象里的，如果长连接累积下来，会导致内存占用过大。</p>
<p>解决办法：</p>
<ul>
<li>定期断开长连接</li>
<li>MySQL5.7及以后，可以在每次执行一个比较大的操作后，执行mysql_reset_connection来将连接恢复到刚刚创建完的状态(不需要重连和权限验证)。</li>
</ul>
</li>
</ul>
</li>
<li><p>查询缓存</p>
<p>之前查询过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。但只要有对一个表的更新，那么这个表上的查询缓存就会被全部清除。MySQL8.0版本将查询缓存模块删除掉了。</p>
<ul>
<li><p>MySQL提供了”按需使用”的方式，将参数query_cache_type设置为DEMAND，这样对于默认的SQL不使用查询缓存。使用SQL_CACHE显式指定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select SQL_CACHE * from T <span class="built_in">where</span> ID=10；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分析器</p>
<p>如果没有命中查询缓存，就要开真正开始执行语句。</p>
<ol>
<li><p>词法分析</p>
<p>把”select”关键字识别出来，把字符串”T”识别为”表名T”，把字符串”ID”识别为”列ID”。</p>
</li>
<li><p>语法分析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> elect * from t <span class="built_in">where</span> ID=1;</span></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>优化器</p>
<p>在表里有多个索引的时候，决定使用哪个索引；或者一个语句有多表关联(join)的时候，决定各个表的连接顺序。</p>
</li>
<li><p>执行器</p>
<p>开始执行语句，先判断对这个表T是否有权限(如果命中查询缓存，会在查询缓存返回结果时做权限校验)。如果有权限，就开始执行语句。</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集。</li>
<li>调用引擎接口取”下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>将结果集返回给客户端。</li>
</ol>
<p>对于有索引的表，第一次调用的是”满足条件的第一行”这个接口，之后循环取”满足条件的下一行”接口。</p>
</li>
</ol>
<h4 id="1-2-日志系统：一条SQL更新语句是如何执行的"><a href="#1-2-日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="1.2 日志系统：一条SQL更新语句是如何执行的"></a>1.2 日志系统：一条SQL更新语句是如何执行的</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(ID int primary key, c int);</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span></span><br></pre></td></tr></table></figure>

<p><strong>重要的日志模块：redo log</strong></p>
<p>WAL(Write-Ahead Logging)：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的。</p>
<p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB。从头开始写，写到末尾就又回到开头循环写。</p>
<p><img data-src="../assets/img/16a7950217b3f0f4ed02db5db59562a7.png" alt></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos和checkpoint之间空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，这时不能再执行新的更新，得擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<p><strong>重要的日志模块：binlog</strong></p>
<p>MySQL整体看包括两块：一块是Server层，它主要做的是MySQL功能层面的事情；还一块是引擎层，负责存储相关的具体事宜。redo log是InnoDB(重做日志)引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)</p>
<p><strong>为什么会有两份日志？</strong></p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎MyIASM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是以插件形式引入MySQL的，使用另外一套日志系统-redo log来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同：</p>
<ol>
<li>redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是”在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1”。</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p><strong>InnoDB引擎内部执行流程</strong></p>
<ol>
<li>执行器先找引擎取ID=2这一行。(ID是主键，引擎直接用树搜索到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。)</li>
<li>执行器拿到引擎给的行数据，把这个值加1，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成commit状态，更新完成。</li>
</ol>
<p>浅色表示在InnoDB内部进行，深色表示在执行器中执行。</p>
<p><img data-src="../assets/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt></p>
<h4 id="1-3-事务隔离"><a href="#1-3-事务隔离" class="headerlink" title="1.3 事务隔离"></a>1.3 事务隔离</h4><p>事务：保证一组数据库操作，要么全部成功，要么全部失败。</p>
<p>ACID(原子性、一致性、隔离性、持久性)</p>
<p>当数据库上有多个事务同时执行的时候，可能会出现脏读、不可重复读、幻读的问题。SQL标准的事务隔离级别包括：</p>
<ul>
<li>读未提交：一个事务还没提交，它做的变更就能被其他事务看到。</li>
<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化：对于同一行记录，”写”会加”写锁”，”读”会加”读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img data-src="../assets/img/7dea45932a6b722eb069d2264d0066f8.png" alt></p>
<ul>
<li>读未提交：V1 = 2，V2、V3 = 2</li>
<li>读提交：V1 = 1，V2 = 2，V3 = 2</li>
<li>可重复读：V1、V2 = 1，V3 = 2；之所以V2还是1，是因为：事务在执行期间看到的数据前后必须一致</li>
<li>串行化：在事务B执行”将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以V1、V2 = 1，V3 = 2</li>
</ul>
<p><strong>事务隔离的实现</strong></p>
<p>数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。”可重复读”，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；”读提交”，这个视图是在每个SQL语句开始执行的时候创建的。”读未提交”，直接返回记录上的最新值，没有视图概念；”串行化”，直接用加锁的方式来避免并发访问。</p>
<p>MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，都可以得到前一个状态。当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除。</p>
<p>长事务意味着系统里会存在很老的事务视图，这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致占用大量存储空间。</p>
<p><strong>事务的启动方式</strong></p>
<ol>
<li>显式启动事务语句，begin或start transaction。配套的语句是commit或者rollback。</li>
<li>set autocommit = 0，将这个线程的自动提交关掉。意味着如果执行一个select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到主动执行commit或者rollback，或者断开连接。</li>
</ol>
<h4 id="1-4-索引"><a href="#1-4-索引" class="headerlink" title="1.4 索引"></a>1.4 索引</h4><p><strong>索引的常见模型</strong></p>
<ul>
<li><p>哈希表</p>
<p>以键-值(key-value)存储数据的结构。多个key经过哈希函数换算，会出现同一个值的情况，此时会拉出一个链表。因为不是有序的，所以哈希索引做区间查询的速度很慢。适用于只有等值查询的场景。</p>
</li>
<li><p>有序数组</p>
<p>支持范围查询，但在插入数据和删除数据时必须挪动后面所有的记录，成本太高。适用于静态存储查询，这类不会再修改的数据。</p>
</li>
<li><p>二叉搜索树</p>
<p><img data-src="../assets/img/04fb9d24065635a6a637c25ba9ddde68.webp" alt></p>
<p>二叉搜索树的特点：父节点左子树所有节点小于父节点的值，右子树所有的节点大于父节点的值。</p>
<p>多叉树就是每个节点有多个儿子，儿子的大小保证从左到右递增。索引不止在内存中，还要写到磁盘上。为了尽可能少的读磁盘，就必须让查询过程访问尽量少的数据块。”N叉树”的”N”取决于数据块的大小。</p>
</li>
</ul>
<p><strong>InnoDB的索引模型</strong></p>
<p>每一个索引在InnoDB中对应一棵B+树。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(</span></span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p>
<p><img data-src="../assets/img/dcda101051f28502bd5c4402b292e38d.webp" alt></p>
<p>索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也称为聚簇索引。</p>
<p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p>
<p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>select * from T where ID = 500 即主键查询方式，则只需要搜索ID这棵B+树</li>
<li>select * from T where k = 5 即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表。</li>
</ul>
<p><strong>索引维护</strong></p>
<p>B+树为了维护索引有序性，在插入新值时需要做必要的维护。以上图为例，如果插入新的行ID值为700，则只需要在R5后面插入一个新记录。如果新插入的ID为400，需要逻辑上挪动后面的数据，空出位置。如果R5所在的数据页已满，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂，性能会下降。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。</p>
<p>自增主键：NOT NULL PRIMARY KEY AUTO_INCREMENT。每次插入一条新纪录，都是追加操作，都不涉及挪动记录，也不会触发叶子节点的分裂。</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约２０个字节，而如果用整形做主键，则只需要４个字节。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p><strong>覆盖索引</strong></p>
<p><img data-src="../assets/img/ds224929.png" alt></p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。</p>
<p><strong>最左前缀原则</strong></p>
<p><img data-src="../assets/img/rrr225205.png" alt></p>
<p>索引项是按照索引定义里面出现的字段顺序排序的。当查询所有名字是”张三”的人时，可以快速定位到ID4，然后向后遍历。</p>
<p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>如果通过调整顺序，可以少维护一个索引，那么往往优先考虑这个顺序。</p>
<p><strong>索引下推</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值。</p>
<p>MySQL5.6之后引入索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的数据，减少回表次数。</p>
<p>无索引下推：回表4次</p>
<p><img data-src="../assets/img/625230314.png" alt></p>
<p>有索引下推：在(name，age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过，只需回表2次。</p>
<p><img data-src="../assets/img/156230553.png" alt></p>
<h4 id="1-5-全局锁和表锁"><a href="#1-5-全局锁和表锁" class="headerlink" title="1.5 全局锁和表锁"></a>1.5 全局锁和表锁</h4><p>数据库锁设计的初衷是处理并发问题。</p>
<p><strong>全局锁</strong></p>
<p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局锁的方法，命令是Flush tables with read lock(FTWRL)。当需要让整个库处于只读状态(不止DML，还包括DDL)时，可以使用该命令。使用场景是，<strong>全库逻辑备份</strong>的时候。</p>
<p>InnoDB引擎的库推荐使用一致性读(single-transcation)参数，对应用会更友好，全局锁一般在数据库引擎不支持事务时使用。</p>
<p>为什么不使用set global readonly=true？</p>
<ol>
<li>readonly的值会被用作其他逻辑，如判断主库备库。</li>
<li>异常处理机制有差别，执行FTWRL后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。readonly，如果客户端发生异常，则数据库就会一直保持readonly状态。</li>
</ol>
<p><strong>表级锁</strong></p>
<p>MySQL里面的表级别锁有两种：一种是表锁，一种是元数据锁(meta data lock，MDL)</p>
<ul>
<li><p>表锁</p>
<p>表锁的语法是lock tables..read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables不仅会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>某个线程A执行lock tables t1 read，t2 write；则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作，连写t1都不允许，自然也不能访问其他表。</p>
</li>
<li><p>元数据锁DML</p>
<p>不需要显示的使用，在访问一个表的时候会被自动加上，保证读写的正确性。</p>
<p>给一个表加字段，或者修改字段，或者加索引。需要扫描全表的数据。</p>
<p><strong>如何安全地给小表加字段？</strong></p>
<p>首先解决长事务的问题，事务不提交，就会一直占着MDL锁。在alter table语句里面设定等待时间，如果在这个指定的等待时间内未拿到MDL锁，则会放弃，不阻塞后面的业务。之后再通过重试命令重复这个过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="1-6-行锁"><a href="#1-6-行锁" class="headerlink" title="1.6 行锁"></a>1.6 行锁</h4><p>并不是所有的引擎都支持行锁，如MyISAM不支持行锁。行锁就是针对数据表中行记录的锁，比如事务A更新了一行，而这时事务B也要更新一行，则必须等事务A的操作完成后才能进行更新。</p>
<p><strong>两阶段锁</strong></p>
<p><img data-src="../assets/img/34234225501.png" alt></p>
<p>事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p>
<p><strong>在InnoDB事务中，行锁并不是不需要了就立刻释放，而是要等待事务结束时才能释放。</strong></p>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p><strong>死锁和死锁检测</strong></p>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源的时候，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p><img data-src="../assets/img/323230138.png" alt></p>
<ol>
<li>直接进入等待，直到超时。超时时间参数：innodb_lock_wait_timeout，默认50s</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其它事务得以继续执行。innodb_deadlock_detect：on，默认开启。</li>
</ol>
<p>正常情况下使用第二种策略，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，但如果遇到所有事务更新同一行的场景，每个新来的线程都需要判断会不会由于自己加入导致了死锁，会消耗大量的CPU资源。</p>
<p>如何解决热点行更新导致的性能问题？</p>
<ol>
<li>在确保该业务不会出现死锁的情况下，临时取消死锁检测。</li>
<li>控制并发度。(中间件、在MySQL里进入引擎之前排队)</li>
<li>将一行改成逻辑上的多行来减少锁冲突，如账户总额等于10个记录值的总和。</li>
</ol>
<h4 id="1-7-事务到底是隔离的还是不隔离的？"><a href="#1-7-事务到底是隔离的还是不隔离的？" class="headerlink" title="1.7 事务到底是隔离的还是不隔离的？"></a>1.7 事务到底是隔离的还是不隔离的？</h4><p>当前读：更新数据都是先读后写的，而这个读，只能读当前的值。</p>
<p>事务的可重复读的能力是怎么实现的？<br>可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读，如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>InnoDB的行数有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。<br>对于可重复读：查询只承认在事务启动前就已经提交完成的数据；<br>对于读提交：查询只承认在语句启动前就已经提交完成的数据；</p>
<p>为什么表结构不支持”可重复读”?<br>因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑</p>
<h3 id="2-实践篇"><a href="#2-实践篇" class="headerlink" title="2.实践篇"></a>2.实践篇</h3><h4 id="2-1-普通索引和唯一索引该如何选择？"><a href="#2-1-普通索引和唯一索引该如何选择？" class="headerlink" title="2.1 普通索引和唯一索引该如何选择？"></a>2.1 普通索引和唯一索引该如何选择？</h4><p><img data-src="../assets/img/css224736.png" alt></p>
<p><strong>查询</strong></p>
<p>select id from T where k=5</p>
<ul>
<li>普通索引：查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5的记录。</li>
<li>唯一索引：查找到第一个满足条件的记录后，就会停止检索。</li>
</ul>
<p>两者的性能差距：InnoDB的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录从磁盘读出来，而是以页为单位，将其整体读入内存，InnoDB中，每个数据页的大小默认是16KB。对于整形字段，一个数据页可以放近千个key，所以k=5这个记录刚好是数据页最后一个记录的几率会很低。</p>
<p><strong>更新过程</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在chang buffer中，在下次查询需要访问这个数据页的时候将数据页读入内存，然后执行change buffer中与这个页有关的参数。</p>
<p>虽然名字叫做change buffer，实际上它是可以持久化的数据，change buffer在内存中有拷贝，也会被写入磁盘中。</p>
<p>将change buffer中操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭(shutdown)的过程中，也会执行merge操作。</p>
<p>对于唯一索引，比如插入(4,400)这个记录，需要先判断表中是否存在k=4的记录，而这必须要将数据页读入到内存才能判断。如果已经读入内存了，直接更新内存即可，没必要再使用change buffer。因此，唯一索引的更新不能使用change buffer。</p>
<p>innodb_change_buffer_max_size: 50    表示change buffer的大小最多只能占用buffer pool的50%。</p>
<p>插入(4,400)：</p>
<ul>
<li>更新的目标页在内存中<ul>
<li>唯一索引：找到3和5之间的位置，判断没有冲突，插入值。</li>
<li>普通索引：找到3和5之间的位置，插入值。</li>
</ul>
</li>
<li>更新的目标页不在内存中<ul>
<li>唯一索引：将数据页读入内存，判断没有冲突，插入值。</li>
<li>普通索引：将更新记录在change buffer。</li>
</ul>
</li>
</ul>
<p><strong>change buffer的使用场景</strong><br>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多，收益越大。即适合于<strong>写多读少</strong>的场景。</p>
<p><strong>change buffer和redo log</strong><br>insert into t(id,k) values (id1,k1)(id2,k2);<br>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB<br>buffer pool) 中，k2 所在的数据页不在内存中。</p>
<ol>
<li>Page1在内存中，直接更新内存。</li>
<li>Page2不在内存中，将更新记录在change buffer。</li>
<li>将上述两个动作记录在redo log。</li>
</ol>
<p>select * from t where k in (k1, k2)</p>
<ol>
<li>读Page1时，直接从内存返回。</li>
<li>读Page2时，需要把Page2从磁盘读入内存，然后应用change buffer里的操作记录，生成一个正确的版本并返回结果。</li>
</ol>
<p>redo log主要节省的是随机写磁盘的IO消耗(转为顺序写)，而change buffer主要节省的是随机读磁盘的IO消耗。</p>
<h4 id="2-2-MySQL为什么有的时候会选错索引？"><a href="#2-2-MySQL为什么有的时候会选错索引？" class="headerlink" title="2.2 MySQL为什么有的时候会选错索引？"></a>2.2 MySQL为什么有的时候会选错索引？</h4><p><strong>优化器的逻辑</strong></p>
<p>扫描行数、是否使用临时表、是否排序等因素。</p>
<p>一个索引上不同的值越多(基数)，这个索引的区分度就越好。</p>
<p><strong>MySQL是怎样得到索引的基数的？</strong></p>
<p>采样统计：InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到这个索引的基数。而数据表是会持续更新的，索引统计信息也需要同步改变。所以，当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。</p>
<p>innodb_stats_persistent:<br>on：统计信息会持久存储，默认N是20，M是10。<br>off：统计信息只存储在内存中，默认N是8，M是16。</p>
<p>analyze table t：重新统计索引信息</p>
<p><strong>索引选择异常和处理</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b betwwen <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>采用force index强行选择一个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改语句，引导MySQL使用期望的索引</p>
<p>“order by b limit 1”改成”order by b,a limit 1”，语义逻辑相同。之前优化器选择索引b，因为它认为使用索引b可以避免排序(b本身就是索引，不需要再次进行排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。”order by b,a”，意味着使用这两个索引都需要排序，因此，扫描行数成了影响索引选择的主要条件，于是，此时优化器选择了只需要扫描1000行的索引a。</p>
<p>但这种优化方法并不通用。</p>
</li>
<li><p>新建一个更合适的索引，来提供给优化器做选择，或者删除掉误用的索引</p>
</li>
</ol>
<h4 id="2-3-怎么给字符串字段加索引？"><a href="#2-3-怎么给字符串字段加索引？" class="headerlink" title="2.3 怎么给字符串字段加索引？"></a>2.3 怎么给字符串字段加索引？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/fdfd222522.png" alt></p>
<p><img data-src="../assets/img/hgh222605.png" alt></p>
<p>由于email(6)这个索引结构中每个邮箱字段都只取前6个字节，所以<strong>占用的空间会更小，但可能会增加额外的记录扫描次数。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,emial <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果使用的是index1(即email整个字符串的索引结构)</p>
<ol>
<li>从index1索引树找到满足索引值是‘zhangssxyz@xxx.com’的这条记录，取得ID2的值。</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这条记录加入结果集。</li>
<li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
</li>
<li><p>如果使用的是index2(即emai(6)索引结构)</p>
<ol>
<li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li>
<li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’<span class="exturl" data-url="bWFpbHRvOnpoYW5nc3N4eXpAeHh4LmNvbQ==">zhangssxyz@xxx.com<i class="fa fa-external-link-alt"></i></span>’，这行记录丢弃；</li>
<li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p>
</li>
</ul>
<p><strong>使用前缀索引，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。</strong></p>
<p><strong>怎么确定该使用多长的前缀呢？</strong></p>
<p>区分度越高越好，意味着重复的键值越少。因此可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure>

<p>依次选取不同长度的前缀的值，如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">4</span>)) <span class="keyword">as</span> L4,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">5</span>)) <span class="keyword">as</span> L5,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">6</span>)) <span class="keyword">as</span> L6,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">7</span>)) <span class="keyword">as</span> L7 <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure>

<p>使用前缀索引很可能损失区分度，所以需要预先设定一个可以接收的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7都满足，你就可以选择前缀长度为 6。</p>
<p><strong>前缀索引对覆盖索引的影响</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure>

<p>与前面例子中的SQL语句相比，这个语句只要求返回id和email字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure>

<p>如果使用index1(即email整个字符串的索引结构)的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回表；而如果使用index2(即email(6)索引结构)的话，就不得不回到ID索引再去判断email的值。</p>
<p>即使将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p>
<p><strong>其他方式</strong></p>
<ol>
<li><p>使用倒序存储</p>
<p>如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用hash字段</p>
<p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc)</span><br></pre></td></tr></table></figure>

<p>每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能会冲突，所以查询语句where部分要判断id_card的值是否精确相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">'input_id_card_string'</span>) <span class="keyword">and</span> id_card=<span class="string">'input_id_card_string'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用倒序存储和使用 hash 字段的异同点</strong></p>
<ol>
<li>倒叙存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。</li>
<li>倒序方式每次写和读的时候，都需要额外调一次reverse函数，而hash字段需要额外调一次crc32()函数，单纯从计算复杂度来看，reverse函数额外消耗的CPU资源会更小。</li>
<li>hash字段方式的查询性能相对更加稳定，因为crc32()算出来的值虽然有冲突的概率，但概率非常小，可以认为每次查询平均扫描行数接近1，而倒序存储方式毕竟还是前缀索引的方式，即还是会增加扫描行数。</li>
</ol>
<h4 id="2-4-为啥SQL语句偶尔会变”慢”？"><a href="#2-4-为啥SQL语句偶尔会变”慢”？" class="headerlink" title="2.4 为啥SQL语句偶尔会变”慢”？"></a>2.4 为啥SQL语句偶尔会变”慢”？</h4><p>InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作(redo log)，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p>
<p>flush：把内存中的数据写入磁盘的过程</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存为”脏页”。内存数据写入到磁盘后，内存就和磁盘上的数据页上的数据页的内容就一致了，称为”干净页”。</p>
<p><img data-src="../assets/img/fdff151353.png" alt></p>
<p>平时执行很快的操作：写内存和日志<br>偶尔”抖”一下：刷脏页(flush)</p>
<p><strong>什么情况下会引发数据库的flush操作?</strong></p>
<ol>
<li><p>InnoDB的redo log写满了。这时系统会停止所有更新操作，把checkpont往前推进，redo log留出空间可以继续写。</p>
<p><img data-src="../assets/img/111152005.png" alt></p>
<p>把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志，对应的所有脏页都flush到磁盘上。</p>
</li>
<li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，淘汰一些数据页，空出内存。如果淘汰的是”脏页”，就需要先将脏页写到磁盘。</p>
</li>
<li><p>MySQL认为系统”空闲”的时候就刷一点”脏页”。</p>
</li>
<li><p>MySQL正常关闭的时候，会把内存的脏页都flush到磁盘上，这样MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p>
</li>
</ol>
<p><strong>对性能的影响</strong></p>
<ol>
<li><p>“redo log 写满了，要 flush 脏页”，这种情况，所有的更新都被堵塞，需要避免。</p>
</li>
<li><p>“内存不够用了，要先将脏页写到磁盘”，InnoDB使用缓冲池管理内存，缓冲池中的内存页有3种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页。</p>
<p>当要读入的数据页没有在内存中的时候，就必须到缓冲池申请一个数据页。这时需要把最久不使用的数据页从内存中淘汰掉。如果淘汰的是一个干净页，就直接释放出来复用；如果是脏页，就必须先刷到磁盘，变成干净页后才能复用。</p>
<ul>
<li>一个查询要淘汰的脏页个数太多。</li>
<li>日志写满，更新全部堵住。</li>
</ul>
</li>
</ol>
<p><strong>InnoDB刷脏页的控制策略</strong></p>
<p>参考因素：脏页比例，redo log写盘速度。</p>
<p>innodb_max_dirty_pages_pct：脏页比例上限，默认75%  F1(M)</p>
<p>InnoDB每次写日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，假设为F2(N)(N越大，算出来的值越大)。</p>
<p>F1(M)和F2(N)的最大值为R，接下来引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的数据。</p>
<p><img data-src="../assets/img/121154612.png" alt></p>
<p>合理设置innodb_io_capacity，多关注脏页比例，不要让它接近75%。</p>
<p>innodb_flush_neighbors，值为1时，对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷(机械硬盘时代，减少随机IO)。值为0时，只刷自己的，MySQL8.0之后，默认为0。</p>
<h4 id="2-5-为什么表数据删掉一半，表文件大小不变？"><a href="#2-5-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="2.5 为什么表数据删掉一半，表文件大小不变？"></a>2.5 为什么表数据删掉一半，表文件大小不变？</h4><p><strong>参数innodb_file_per_table</strong></p>
<p>innodb_file_per_table：MySQL5.6.6版本后默认为ON</p>
<ul>
<li>OFF：表的数据放在系统共享表空间，也就是跟数据字典放在一起。</li>
<li>ON：每个InnoDB表数据存储在一个.ibd为后缀的文件中。</li>
</ul>
<p>推荐设置为ON，一个表单独存储为一个文件更容易管理，不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。如果放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<p><strong>数据删除流程</strong></p>
<p><img data-src="../assets/img/jhj195615.png" alt><br>假设，我们需要删除掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>InnoDB的数据是按页存储的，如果删除一个数据页上的所有记录，整个数据页就可以被复用了，但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。<br>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。</p>
<p>如果用delete命令删除整个表的数据，所有的数据页都会被标记为可复用。但磁盘上，文件大小不变。</p>
<p>不止是删除数据会造成空洞，插入数据也会。</p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<p><img data-src="../assets/img/1212201259.png" alt></p>
<p>由于page A满了，申请一个新的页面page B来保存数据。页面分裂完成后，page A的末尾就留下了空洞。</p>
<p><strong>重建表</strong></p>
<p>新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行行地从表A里读出来再插入到表B中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert table A engine=InnoDB</span><br></pre></td></tr></table></figure>

<p>MySQL5.6版本开始引入Online DDL(往临时表插入数据的过程中，表A中不能有更新)。</p>
<p><img data-src="../assets/img/dsd203817.png" alt></p>
<ol>
<li>建立一个临时文件，扫描表A主键的所有数据页。</li>
<li>用数据页中表A的记录生成B+树，存储到临时文件。</li>
<li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件(row log)中，对应图中state2的状态。</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据与表A相同的数据文件，对应图中state3的状态。</li>
<li>用临时文件替换表A的数据文件。</li>
</ol>
<h4 id="2-6-count-的实现方式"><a href="#2-6-count-的实现方式" class="headerlink" title="2.6 count(*)的实现方式"></a>2.6 count(*)的实现方式</h4><p>MyISAM引擎把一个表的总行数存在了磁盘上，count(*)会直接返回这个数(不含where条件)。</p>
<p>InnoDB引擎需要把数据一行一行的从引擎里面读出来，然后累计计数。</p>
<p><strong>为什么InnoDB不像MyISAM一样把数字存放起来？</strong></p>
<p>和InnoDB的事务设计有关，可重复读是它的默认的隔离级别，通过多版本并发控制(MVCC)实现。每一行记录都要判断自己是否对这个会话可见，因此count(*)，InnoDB只好把数据一行一行的读出依次判断。</p>
<ul>
<li>MyISAM表虽然count(*)很快，但不支持事务；</li>
<li>show table status 命令虽然返回很快，但是不准确；</li>
<li>InnoDB直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<p><strong>不同的count用法</strong></p>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>
<p>原则：</p>
<ol>
<li>server原则要什么就什么；</li>
<li>InnoDB只给必要的值；</li>
<li>现在的优化器只优化了count(*)的语义取行数。</li>
</ol>
<ul>
<li><p>count(主键id)</p>
<p>InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空后，按行累加。</p>
</li>
<li><p>count(1)</p>
<p>InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字”1”进去，判断是不可能为空的，按行累加。</p>
<p>count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
</li>
<li><p>count(字段)</p>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
</li>
<li><p>count(*)</p>
<p>不取值。count(*) 肯定不是 null，按行累加。</p>
</li>
</ul>
<p>效率：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</p>
<h4 id="2-7-“order-by”是如何工作的？"><a href="#2-7-“order-by”是如何工作的？" class="headerlink" title="2.7 “order by”是如何工作的？"></a>2.7 “order by”是如何工作的？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p> <strong>全字段排序</strong><img data-src="../assets/img/image-20210714220341145.png" alt></p>
<p>Extra：”Using filesort”表示需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p>
<p><img data-src="../assets/img/220736.png" alt></p>
<ol>
<li>初始化sort_buffer，确定放入name、city、age三个字段；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name快速排序；</li>
<li>按照排序结果取前1000行返回给客户端。</li>
</ol>
<p>sort_buffer_size：MySQl为排序开辟的内存的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，否则利用磁盘临时文件辅助排序(外部排序。</p>
<p>外部排序一般使用归并算法，即将要排序的数据分成12份，每一份单独排序后，将这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。</p>
<p>只对原表的数据读了一遍，剩下的操作都是在sort_buffer或临时文件中执行，但如果要查询返回的字段特别多，则需要分成很多临时文件，排序性能很差。</p>
<p><strong>rowid排序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> max_length_for_sort_data = <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>如果单行的长度超过这个值，MySQL就认为单行太大，需要换个算法(city、name、age这3个字段的定义总长度36)。新的算法放入sort_buffer的字段，只要排序的列(即name字段)和主键id。</p>
<ol>
<li>初始化sort_buffer，确定放入两个字段，即name和id；</li>
<li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li>
<li>到主键id索引取出整行，取name、id字段，存入sort_buffer中；</li>
<li>从索引city取下一个记录的主键id；</li>
<li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li>
<li>对sort_buffer中的数据按照字段name快速排序；</li>
<li>遍历排序结果，取前1000行，并按照id的值回到原表取出city、name和age三个字段返回给客户端。</li>
</ol>
<p>rowid多访问了一次表t的主键索引，即步骤7。</p>
<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<p>MySQL之所以要生成临时表并且在临时表上做排序操作，是因为原来的数据都是无序的。</p>
<p><strong>联合索引</strong></p>
<p>如在这张表上创建一个city和name的联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city,<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/ds50223.png" alt></p>
<ol>
<li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id；</li>
<li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name)取下一个记录主键id；</li>
<li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li>
</ol>
<p><strong>覆盖索引</strong></p>
<p>覆盖索引上的信息足够满足查询请求，不需要再回到主键索引上取数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city,<span class="keyword">name</span>,age)</span><br></pre></td></tr></table></figure>

<ol>
<li>从索引(city,name,age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name和age这3个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引(city,name,age)取下一个记录，同样取出这3个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li>
</ol>
<h4 id="2-8-为什么这些SQL语句逻辑相同，但性能差异巨大"><a href="#2-8-为什么这些SQL语句逻辑相同，但性能差异巨大" class="headerlink" title="2.8 为什么这些SQL语句逻辑相同，但性能差异巨大"></a>2.8 为什么这些SQL语句逻辑相同，但性能差异巨大</h4><ol>
<li><p><strong>条件字段函数操作</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>查询所有年份中7月份的交易记录总数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>下面是t_modified索引的示意图，方框上面的数字就是month()函数对应的值。<img data-src="../assets/img/dd223828.png" alt></p>
<p>B+树的快速定位能力来源于同一层兄弟节点的有序性，<strong>对索引字段做函数操作，可能会破环索引值的有序性，因此优化器决定放弃走树搜索功能，导致全索引扫描(并不是放弃这个索引)。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span>(t_modified &gt;=<span class="string">'2016-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2016-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2017-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2017-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2018-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2018-7-1'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式类型转换</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid=<span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>tradeid的字段类型是varchar(32)，而输入的参数是整形，需要做类型转换。</p>
<p><strong>字符串和数字作比较：将字符串转换成数字</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">CAST</span>(tradeid <span class="keyword">AS</span> signed <span class="built_in">int</span>) = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure>

<p>因此触发：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
</li>
<li><p><strong>隐式字符编码转换</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`trade_detail`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`trade step`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 操作步骤 */</span></span><br><span class="line"><span class="string">`step_info`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure>

<p>查询id=2的交易的所有操作步骤信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210722215222511.png" alt></p>
<ol>
<li>优化器会先在交易记录表tradelog上查到id=2的行，这个步骤使用了主键索引，row=1表示只扫描一行；</li>
<li>第2行key=NULL，表示没用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li>
</ol>
<p>从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，tradelog称为驱动表，把trade_detail表称为被驱动表，把tradeid称为关联字段。</p>
<p><img data-src="../assets/img/image-20210722222051685.png" alt></p>
<ol>
<li>根据id在tradelog表中找到L2这一行；</li>
<li>从L2中取出tradeid字段的值；</li>
<li>根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key=NULL表示的就是，这个过程就是通过遍历主键索引的方式，一个个的判断tradeid的值是否匹配。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid=$L2.tradeid.value</span><br></pre></td></tr></table></figure>

<p>$L2.tradeid.value的字符集就是utf8mb4，字符集utf8mb4是utf8的超集，两个不同类型的字符串比较时，MySQL会把utf8字符串转成utf8mb4字符集再做比较。所以需要将被驱动数据表里的字段一个一个转成utf8mb4，再与L2比较，类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(tradeid <span class="keyword">USING</span> uth8mb4)=$L2.tradeid.value</span><br></pre></td></tr></table></figure>

<p>再次触发了：对索引字段做函数操作，优化器会放弃走树搜索功能。</p>
<p><strong>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =$R4.tradeid.value;</span><br></pre></td></tr></table></figure>

<p>改写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =<span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4);</span><br></pre></td></tr></table></figure>

<p>CONVERT函数加在输入参数上，可以用上被驱动表的tradeid索引。</p>
<p><strong>优化：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>把trade_detail表上的tradeid字段的字符集也改成utf8mb4</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail <span class="keyword">modify</span> tradeid <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改sql语句，主动把l.tradeid转成utf8，避免了被驱动表上的字符编码转换。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=<span class="keyword">CONVERT</span>(l.trade.id <span class="keyword">USING</span> utf8) <span class="keyword">on</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="2-9-为什么我只查一行的语句，也执行这么慢？"><a href="#2-9-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="2.9 为什么我只查一行的语句，也执行这么慢？"></a>2.9 为什么我只查一行的语句，也执行这么慢？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">while(i&lt;=100000)do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>查询长时间不返回</strong></p>
<p>大概率表t被锁住了，执行<code>show processlist</code>命令查看当前语句状态。</p>
<ul>
<li><p><strong>等MDL锁</strong></p>
<p><img data-src="../assets/img/image-20210726223343443.png" alt></p>
<p><code>Wating for table metadata lock</code>状态表示的是，现在有一个线程正在表t上请求或持有MDL写锁，把select语句堵住了。</p>
<p>找到谁持有MDL锁，然后把它kill掉。<br>通过查询sys.schema_table_lockwaits这张表，直接找出造成阻塞的process id，把这个连接用kill命令断开即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>等flush</strong></p>
<p><code>Waiting for table flush</code>表示，有一个线程正要对表t做flush操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;	<span class="comment">#只关闭表t</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;  <span class="comment">#关闭所有打开的表</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>正常情况下，这两个语句执行都很快，可能的情况：有一个flush tables 命令被别的语句堵住了，然后它又堵住了select语句。</code></pre><ul>
<li><p><strong>等行锁</strong></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br>update t set c=c+1 where id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from where id=1 lock in share mode;</td>
</tr>
</tbody></table>
<p>show processlist</p>
<p><img data-src="../assets/img/image-20210727221501088.png" alt></p>
<p>查询是谁占有了写锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> locked_table,waiting_pid,waiting_query,blocking_trx_id,blocking_pid <span class="keyword">from</span> sys.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ol start="2">
<li><p><strong>查询慢</strong></p>
<ul>
<li><p>查看是否开启慢查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置慢查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img data-src="../assets/img/image-20210802212135496.png" alt></p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction with consistent snapshot;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c=c+1;//执行100万池</td>
</tr>
<tr>
<td>select * from t where id=1;</td>
<td></td>
</tr>
<tr>
<td>select * from where id=1 lock in share mode;</td>
<td></td>
</tr>
</tbody></table>
<p><img data-src="../assets/img/image-20210802212638953.png" alt></p>
<p>session B更新完100万次，生成了100万个回滚日志(undo log)。(undo log里记录的其实是”把2改成1”，”把3改成2”这样的操作逻辑)</p>
<p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1是一致性读，因此需要从1000001开始，依次执行log，执行100万次以后，才将1这个结果返回。</p>
</li>
</ol>
<h4 id="2-10-幻读"><a href="#2-10-幻读" class="headerlink" title="2.10 幻读"></a>2.10 幻读</h4><ul>
<li><p>幻读有什么问题？</p>
<ul>
<li>语义</li>
<li>数据一致性</li>
</ul>
</li>
<li><p>如何解决幻读？</p>
<p>产生幻读的原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的”间隙”。</p>
<p><strong>间隙锁(Gap Lock)</strong></p>
<p>锁的就是两个值之间的空隙。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210804221313976.png" alt="批量插入数据"></p>
<p>当执行<code>select * from t where d=5 for update</code>的时候，就不止给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。即在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空袭，也加上了间隙锁。</p>
<p>行锁分为读锁和写锁：</p>
<p><img data-src="../assets/img/image-20210804221753434.png" alt></p>
<p>跟行锁有冲突关系的是”另外一个行锁”。</p>
<p>但跟间隙锁存在冲突关系的，是”往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</p>
<p>间隙锁和行锁合称next-key lock，next-key-lock解决了幻读的问题，但可能会导致同样的语句锁住更大的范围。</p>
<p>间隙锁在可重复读隔离级别下才会生效，<strong>把隔离级别设为读提交，就没有间隙锁了。但同时可能会出现数据和日志不一致问题，需要把binlog格式设置为row。</strong></p>
</li>
</ul>
<h4 id="2-11-next-key-lock"><a href="#2-11-next-key-lock" class="headerlink" title="2.11 next-key lock"></a>2.11 next-key lock</h4><ol>
<li>原则1：加锁的基本单位是next-key lock，前开后闭((5,10])</li>
<li>原则2：查找过程中访问到的对象才会加锁</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化成行锁</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁</li>
<li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为此</li>
</ol>
<p>删除数据的时候尽量加limit，不仅可以控制删除数据的条数，让操作更安全，还可减小加锁的范围。</p>
<p>next-key lock实际上是由间隙锁加行锁实现的。</p>
<h4 id="2-12-应急提高性能的方法"><a href="#2-12-应急提高性能的方法" class="headerlink" title="2.12 应急提高性能的方法"></a>2.12 应急提高性能的方法</h4><ul>
<li><p><strong>短连接风暴</strong></p>
<p>如果使用的是短链接，业务高峰期，连接数暴增。MySQL建立连接成本很高(网络连接3次握手、登录权限判断和获得这个连接的读写权限)。</p>
<p>数据库处理不及时；机器负载较高时，处理现有请求耗时变长，每个连接保持的时间也更长；连接数上限：max_connections，超过这个值时，会拒绝接下来的连接请求，并报错提示”Too many connections”。</p>
<ul>
<li><p><strong>先处理掉那些占着连接但不工作的线程</strong></p>
<p>max_connections，只要连着就占用一个计数位置。kill connection处理掉不需要保持的连接；设置wait_tineout参数(一个线程空闲wait_timeout这么多秒以后，就会被MySQL直接断开连接)。</p>
<blockquote>
<p>优先断开事务外空闲太久的连接，如果这样还不够，再考虑断开事务内的空闲太久的连接。(从 information_schema.innodb_trx 查询事务状态)</p>
</blockquote>
<p>kill connection + id，一个客户端处于sleep状态，它的连接被服务端主动断开，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到报错”ERROR 2013 (HY000): Lost connection to<br>MySQL server during query”。</p>
</li>
<li><p><strong>减少连接过程的消耗</strong></p>
<p>让数据库跳过权限验证阶段，重启数据库，并使用-skip-grant-tables参数启动，整个MySQL会跳过所有的权限验证，包括连接过程和语句执行过程，<strong>风险极高</strong>。</p>
<blockquote>
<p>MySQL8.0，如果启用-skip-grant-tables参数，MySQL会默认把-skip-networking参数打开，表示数据库只能被本地的客户端连接。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>慢查询性能问题</strong></p>
<p>引发慢查询的可能：</p>
<ol>
<li>索引没有设计好</li>
<li>SQL语句没写好</li>
<li>MySQL选错索引</li>
</ol>
<ul>
<li><p><strong>索引没有设计好</strong></p>
<p>紧急创建索引，MySQL5.6之后，创建索引支持Online DDL，直接执行alter table语句。</p>
<ol>
<li>在备库B上执行set sql_log_bin=off，即不写binlog，然后执行alter table语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是B，备库是A。在A上执行set sql_bin_log=off，然后执行alter table语句加上索引。</li>
</ol>
</li>
<li><p><strong>SQL语句没写好</strong></p>
<p>MySQL5.7之后提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p>
<p>如语句被错误地写成了 <code>select * from t where id + 1 = 10000</code>，可以通过下面的<br>方式，增加一个语句改写规则。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br><span class="line"><span class="comment">-- 这个存储过程，让插入的新规则生效，即"查询重写"</span></span><br></pre></td></tr></table></figure>

<p><img data-src="../assets/img/image-20210823224604330.png" alt></p>
</li>
<li><p><strong>MySQL选错索引</strong></p>
<p>使用查询重写功能，给原来的语句加上force index。</p>
</li>
</ul>
<p>通过以下方式，预先发现问题：</p>
<ol>
<li>上线前，在测试环境，把慢查询日志(show log)打开，并把long_query_time设为0。(确保每个语句都会被记录入慢查询日志)</li>
<li>在测试表里插入线上数据，进行回归测试。</li>
<li>观察慢查询日志里每类语句的输出，特别留意Rows_examined(每次执行过程中实际扫描的记录数)字段是否与预期一致。</li>
</ol>
</li>
<li><p><strong>QPS突增问题</strong></p>
<p>业务突然出现高峰或应用程序bug，导致某个语句QPS暴增。</p>
<ol>
<li><p>由全新业务的bug导致的，能够确定业务方会下掉这个功能，可以从数据库直接把白名单去掉。(白名单机制)</p>
</li>
<li><p>如果使用的是单独的数据库用户，可以用管理员账号把这个用户删掉。(业务账户分离)</p>
</li>
<li><p>如果新增的功能和主体功能是部署在一起的，可以通过查询重写功能，单独把这个语句以select 1的结果返回。</p>
<p>副作用：</p>
<ul>
<li>如果别的功能里也使用了这个SQL语句模板，会有误伤。</li>
<li>很多业务不是一个语句就完成逻辑的，单独把这个语句以select 1的结果返回，可能导致后面的业务逻辑一起失败。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-13-MySQL是如何保证数据不丢失的"><a href="#2-13-MySQL是如何保证数据不丢失的" class="headerlink" title="2.13 MySQL是如何保证数据不丢失的"></a>2.13 MySQL是如何保证数据不丢失的</h4><p>WAL机制(Write-Ahead Logging 先写日志，再写磁盘)，只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p>
<p><strong>binlog的写入机制</strong></p>
<p>事务执行过程中，先把日志写到binglog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过，就要暂存到磁盘。</p>
<p><img data-src="../assets/img/image-20210906222648205.png" alt="binlog写盘状态"><br>每个线程有自己的binlog cache，但共用同一份binlog文件。<br>write：把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，速度较快。<br>fsync：将数据持久化到磁盘，占用磁盘的IOPS。</p>
<p>参数sync_binlog：</p>
<ol>
<li>sync_binlog=0时，每次提交事务都只write，不fsync；</li>
<li>sync_binlog=1时，每次提交事务都会执行fsync；</li>
<li>sync_binlog=N(N&gt;1)时，表示每次提交事务都write，但累积N个事务后才能fsync。</li>
</ol>
<p><strong>如果IO出现瓶颈，可以将sync_binlog设为一个较大的值。</strong>但实际考虑到丢失日志量的可控性，常见的是将其设置为100-1000。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p>
<p><strong>redo log的写入机制</strong></p>
<p>redo log buffer：在事务执行的过程中，生成的redo log是要先写到redo log buffer的。</p>
<p><img data-src="../assets/img/image-20210906223901216.png" alt="redo log存储状态"></p>
<ol>
<li>存在redo log buffer中，物理上是在MySQL进程内存中，图中红色部分。</li>
<li>写到磁盘(write)，但是没有持久化(fsync)，物理上是在文件系统的page cache里，图中黄色部分。</li>
<li>持久化到磁盘，对应hard disk，图中绿色部分。</li>
</ol>
<p>innodb_flush_log_at_trx_commit参数：</p>
<ol>
<li>为0时，表示每次事务提交时都只是把redo log留在redo log buffer中；</li>
<li>为1时，表示每次事务提交时都将redo log持久化到磁盘。</li>
<li>为2时，表示每次事务提交时都只是把redo log写到page cache。</li>
</ol>
<p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cahce，然后调用fsync持久化到磁盘。</p>
<blockquote>
<p>事务执行中间过程的redo log也是直接卸载redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。所以，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p>
</blockquote>
<p>除了后台线程的轮询操作，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：</p>
<ol>
<li>redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，即只留在了文件系统的page cache。</li>
<li>并行的事务提交时，顺带将这个事务的redo log buffer持久化到磁盘。</li>
</ol>
<p>两阶段提交：时序上redo log先prepare，再写binlog，最后再把redo log commit。</p>
<p>如果把innodb_flush_log_at_trx_commit设置为1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖prepare的redo log，再加上binlog来恢复的。</p>
<p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p>
<p><strong>“双1”配置</strong>：sync_binlog和innodb_flush_log_at_trx_commit都设置为1，即<strong>一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare阶段)，一次是binlog。</strong></p>
<p><strong>组提交</strong></p>
<p>日志逻辑序列号(LSN)：单调递增，用来对应redo log的一个个写入点。每次写入长度为length的redo log，LSN的值就会加上length。LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p>
<p>三个并发事务在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。</p>
<p><img data-src="../assets/img/image-20210915222802904.png" alt></p>
<ol>
<li>trx1是第一个到达的，会被选为这组的leader；</li>
<li>等trx1要开始写盘的时候，这个组里已经有了三个事务，这时候LSN也变成了160。</li>
<li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li>
<li>这时候trx2和trx3就可以直接返回了。</li>
</ol>
<p><strong>一次组提交里面，组员越多，节约磁盘IOPS的效果越好。</strong>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p>
<p><strong>“拖时间”</strong></p>
<p>两阶段提交：</p>
<p><img data-src="../assets/img/image-20210915224702007.png" alt="image-20210915224702007"></p>
<p>其实”写binlog”是分成两步的：</p>
<ol>
<li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li>
<li>调用fsync持久化。</li>
</ol>
<p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后，则上图变成了：</p>
<p><img data-src="../assets/img/image-20210915225004511.png" alt></p>
<p>这样一来，binlog也可以组提交了，不过通常第3步执行的会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p>可以通过binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来提升binlog组提交的效果。</p>
<ol>
<li>binlog_group_commit_sync_delay：延迟多少微妙后才调用fsync；</li>
<li>binlog_group_commit_sync_no_delay_count：累积多少次以后才调用fsync。</li>
</ol>
<p>这两个条件是或的关系，只要一个满足条件就会调用fsync。因此，当 binlog_group_commit_sync_delay 设置为 0 的时候，binlog_group_commit_sync_no_delay_count 也无效了。</p>
<p><strong>WAL制作得益于</strong>：</p>
<ol>
<li>redo log和binlog都是顺序写，磁盘的顺序写比随机写速度要快。</li>
<li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li>
</ol>
<p><strong>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</strong></p>
<ol>
<li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。基于”额外的故意等待”实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将sync_binlog设置为大于1的值(常见的为100-1000)。风险：主机断电时会丢binlog日志。</li>
<li>将innodb_flush_log_at_trx_commit设置为2。风险：主机断电时会丢binlog日志。(不建议设置成 0。因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。)</li>
</ol>
<h4 id="2-14-MySQL是怎么保证主备一致的"><a href="#2-14-MySQL是怎么保证主备一致的" class="headerlink" title="2.14 MySQL是怎么保证主备一致的"></a>2.14 MySQL是怎么保证主备一致的</h4><p><strong>MySQL主备的基本原理</strong></p>
<p><img data-src="../assets/img/image-20211008220747983.png" alt></p>
<p>客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。需要切换的时候，就切换成状态2。这时客户端读写访问节点B，而节点A是B的备库。</p>
<p>备库虽然没有被直接访问，但仍建议设为只读(readonly)模式：</p>
<ol>
<li>有时一些运营类的查询语句会放到备库上查询，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有bug，如切换过程中出现双写，造成主备不一致；</li>
<li>可以通过readonly状态，判断节点的角色。</li>
</ol>
<p><code>readonly状态，怎么与主库保持同步更新？</code></p>
<p>readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p>
<p><img data-src="../assets/img/image-20211008222439618.png" alt="节点A到B的内部流程"></p>
<p>备库B跟主库A之间维持了一个长连接，主库A内部有一个线程，专门服务备库B的这个长连接。</p>
<p>一个事务日志同步的完整过程：</p>
<ol>
<li>在备库B上通过chang master命令，设置主库A的IP、端口、用户名、密码，以及从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread(主要负责与主库建立连接)和sql_thread。</li>
<li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B；</li>
<li>备库B拿到binlog之后，写到本地文件，称为中转日志(ready log)；</li>
<li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p>多线程复制方案的引入，sql_thread演化成了多个线程。</p>
</blockquote>
<p><strong>binlog的三种格式对比</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a&gt;=<span class="number">4</span> <span class="keyword">and</span> t_modified&lt;=<span class="string">'2018-11-10'</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>statement</p>
<p>记录到binlog里的语句原文，在主库执行时，用的是索引a，而在备库执行时，却用了索引t_modified，可能会造成主备不一致。</p>
</li>
<li><p>row</p>
<p>row格式的binlog里没有了SQL语句原文，而是替换成了两个event：Table_map(用于说明接下来操作的表)和Delete_rows(用于定义删除的行为)</p>
</li>
<li><p>mixed</p>
<p>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。但row格式，很占空间。如一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果是row格式，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</p>
<p>mixed格式：<strong>MySQL会自己判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。(线上至少应该把 binlog 的格式设置为 mixed)</strong></p>
</li>
</ol>
<p><strong>恢复数据</strong></p>
<p>现在越来越多场景要求把MySQL的binlog格式设为row，如<code>恢复数据</code>。</p>
<p>binlog恢复数据的标准做法：用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master.000001  <span class="comment">--start-position=2738 --stop-position=2942 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure>

<p>含义：将master.00001文件里面从2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p>
<p><strong>循环复制问题</strong></p>
<p><img data-src="../assets/img/image-20211010224052755.png" alt="MySQL 主备切换流程 -- 双 M 结构"></p>
<p>双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。</p>
<p>但如果业务逻辑在A上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（建议把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<p>日志执行流程：</p>
<ol>
<li>从节点A更新的事务，binlog里面记的都是A的server id；</li>
<li>传到节点B执行一次后，节点B生成的binlog的server id也是A的server id；</li>
<li>再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环就断掉了。</li>
</ol>
<h4 id="2-15-MySQL是怎么保证高可用的？"><a href="#2-15-MySQL是怎么保证高可用的？" class="headerlink" title="2.15 MySQL是怎么保证高可用的？"></a>2.15 MySQL是怎么保证高可用的？</h4><p> <strong>主备延迟</strong></p>
<p>主备切换：可能是一个主动运维动作，如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电等。</p>
<p><strong>同步延迟</strong></p>
<ol>
<li>主库A执行完成一个事务，写入binlog，这个时刻记为T1；</li>
<li>之后传给备库B，备库B接收完成这个binlog的时刻记为T2；</li>
<li>备库B执行完成这个事务，这个时刻记为T3。</li>
</ol>
<p><strong>主备延迟：同一个事务在备库执行完成的时间和主库执行完成的时间之间的差值</strong>，即T3-T1。</p>
<p>执行<code>show slave status</code>命令，返回结果<code>seconds_behind_master</code>(时间精度：秒)，用于表示当前备库延迟了多少秒。</p>
<p>seconds_behind_master的计算方法：</p>
<ol>
<li>每个事务binlog都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，即seconds_behind_master。</li>
</ol>
<p>主备库机器时间设置不一致，会不会导致主备延迟的值不准确？</p>
<p>不会，备库连接到主库时，会执行<code>SELECT UNIX_TIMESTAMP()</code>函数来获取当前主库的系统时间，如果不一致，备库在计算seconds_behind_master时会扣掉差值。</p>
<p>主备延迟主要来源是：<strong>备库接收完binlog和执行完成这个事务之间的时间差</strong>。</p>
<p><strong>主备延迟的来源</strong></p>
<ol>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p>
<p>对称部署</p>
</li>
<li><p>备库压力大</p>
<p>忽视备库的压力控制，一些分析查询语句在备库耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p>
<ol>
<li>一主多从，多接几个从库，分担读的压力；</li>
<li>通过binlog输出到外部系统，如Hadoop这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
</li>
<li><p>大事务</p>
<p>主库上必须等事务执行完成后才写入binlog，再传入给备库。如果一个主库上的语句执行10分钟，那这个事务可能导致主备延迟10分钟。</p>
<p>如一次性delete大量数据，大表DDL(建议使用gh-ost方案)。</p>
</li>
<li><p>备库的并行复制能力</p>
</li>
</ol>
<p>主备切换不同的策略：</p>
<p><strong>可靠性优先策略</strong></p>
<p><img data-src="../assets/img/image-20211205225611489.png" alt="MySQL可靠性优先主备切换流程"></p>
<ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值(如5秒)继续下一步，否则重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设为true；</li>
<li>判断备库B的senconds_behind_master的值，直到这个值变为0；</li>
<li>把备库B改成可读写状态，即把readonly设为false；</li>
<li>把业务请求切换到B库。</li>
</ol>
<p>不可用时间：步骤2到步骤5，步骤3耗费时间(步骤1保证步骤3尽可能短)。</p>
<p><strong>可用性优先策略</strong></p>
<p>步骤4、5调整到最开始执行，及不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写。</p>
<p>几乎没有不可用时间，可能出现数据不一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>继续执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>假设，现在主库上有大量的更新，导致主备延迟5秒。在插入一条c=4的语句后，发起了主备切换。</p>
<p><img data-src="../assets/img/image-20211206223345522.png" alt="可用性优先策略，且binlog_format=mixed"></p>
<ol>
<li><p>步骤2中，主库A执行完insert语句，插入一行数据(4,4)，之后开始进行主备切换；</p>
</li>
<li><p>步骤3中，由于主备之间有5秒延迟，所以备库B还未应用”插入c=4”这个中转日志，就开始接收”插入c=5”的命令；</p>
</li>
<li><p>步骤4中，备库B插入了一行数据(4,5)，并且把这个binlog发给主库A；</p>
</li>
<li><p>步骤 5 中，备库B执行”插入 c=4”这个中转日志，插入了一行数据(5,4)。而直接在备库B执行的”插入 c=5”这个语句，传到主库 A，就插入了一行新数据((5,5)。</p>
<p>主库A和备库B上出现了两行不一致的数据。</p>
</li>
</ol>
<p>可用优先策略，设置bnlog_format=row会怎样？</p>
<p>row格式在记录binlog的时候，会记录新插入的行的所有字段值，最后只会有一行不一致，两边的主备同步的应用线程会报错 duplicate key error 并停止。备库 B 的 (5,4) 和主库 A 的 (5,5) 这两行数据，都不会被对方执行。</p>
<p><img data-src="../assets/img/image-20211206224759317.png" alt="可用优先策略，且binlog_format=row"></p>
<p>结论：</p>
<ol>
<li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。</li>
<li>主备切换的可用性优先策略会导致数据不一致。</li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div>请作者喝瓶肥宅快乐水</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/img/vxpay.jpg" alt="ImOkkkk 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/img/alipay.jpg" alt="ImOkkkk 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
              <a href="/tags/数据库/" rel="tag"><i class="fa fa-tag"></i> 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/proxymode/" rel="prev" title="代理模式(JDK Proxy与CGLIB Proxy)">
      <i class="fa fa-chevron-left"></i> 代理模式(JDK Proxy与CGLIB Proxy)
    </a></div>
      <div class="post-nav-item">
    <a href="/computernetwork/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基础篇"><span class="nav-text">1.基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-一条SQL查询语句是如何执行的？"><span class="nav-text">1.1 一条SQL查询语句是如何执行的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-日志系统：一条SQL更新语句是如何执行的"><span class="nav-text">1.2 日志系统：一条SQL更新语句是如何执行的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-事务隔离"><span class="nav-text">1.3 事务隔离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-索引"><span class="nav-text">1.4 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-全局锁和表锁"><span class="nav-text">1.5 全局锁和表锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-行锁"><span class="nav-text">1.6 行锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-事务到底是隔离的还是不隔离的？"><span class="nav-text">1.7 事务到底是隔离的还是不隔离的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-实践篇"><span class="nav-text">2.实践篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-普通索引和唯一索引该如何选择？"><span class="nav-text">2.1 普通索引和唯一索引该如何选择？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-MySQL为什么有的时候会选错索引？"><span class="nav-text">2.2 MySQL为什么有的时候会选错索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-怎么给字符串字段加索引？"><span class="nav-text">2.3 怎么给字符串字段加索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-为啥SQL语句偶尔会变”慢”？"><span class="nav-text">2.4 为啥SQL语句偶尔会变”慢”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-为什么表数据删掉一半，表文件大小不变？"><span class="nav-text">2.5 为什么表数据删掉一半，表文件大小不变？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-count-的实现方式"><span class="nav-text">2.6 count(*)的实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-“order-by”是如何工作的？"><span class="nav-text">2.7 “order by”是如何工作的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-为什么这些SQL语句逻辑相同，但性能差异巨大"><span class="nav-text">2.8 为什么这些SQL语句逻辑相同，但性能差异巨大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-为什么我只查一行的语句，也执行这么慢？"><span class="nav-text">2.9 为什么我只查一行的语句，也执行这么慢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-幻读"><span class="nav-text">2.10 幻读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-next-key-lock"><span class="nav-text">2.11 next-key lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-12-应急提高性能的方法"><span class="nav-text">2.12 应急提高性能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-13-MySQL是如何保证数据不丢失的"><span class="nav-text">2.13 MySQL是如何保证数据不丢失的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-14-MySQL是怎么保证主备一致的"><span class="nav-text">2.14 MySQL是怎么保证主备一致的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-15-MySQL是怎么保证高可用的？"><span class="nav-text">2.15 MySQL是怎么保证高可用的？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ImOkkkk"
      src="/../assets/img/head.jpg">
  <p class="site-author-name" itemprop="name">ImOkkkk</p>
  <div class="site-description" itemprop="description">Java开发, 后端开发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vNjA2MjE3MjIyNC8=" title="Weibo → https://weibo.com/6062172224/"><i class="fab fa-weibo fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvbnltdWE=" title="GitHub → https://github.com/tonymua"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx3eTA4YUBmb3htYWlsLmNvbQ==" title="E-Mail → mailto:lwy08a@foxmail.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <a href="https://beian.miit.gov.cn/" target="_blank">皖ICP备19022525号-1</a>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImOkkkk</span>
</div><script color="0,137,108" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imokkkk.github.io/mysql/',]
      });
      });
  </script>

</body>
</html>
