<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="code-wyV34cCXc4" />
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="bUCDF5pEQe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66522575" charset="UTF-8"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "jtdeh55ucp");
</script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imokkkk.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.多线程基础1.1 实现多线程的方法 实现Runnable接口 123456public class Test_01 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;实现Runnable接口实现多线程&quot;);    &#125;&#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://imokkkk.github.io/multithreading/index.html">
<meta property="og:site_name" content="ImOkkkk BLOG">
<meta property="og:description" content="1.多线程基础1.1 实现多线程的方法 实现Runnable接口 123456public class Test_01 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;实现Runnable接口实现多线程&quot;);    &#125;&#125;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgoB5l3eH8mAAoJCAACEOKMHtpw036.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgotOV3g0WWAVWVlAAEsBI6lEEA162.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgoB5l3kzomAckv5AAAxf6FCPco696.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl3nUryAJBkpAAA0_WFSrB8184.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl38fTSAE0T3AABXxHZ9Gus225.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl38fTSALLQ8AABbKYnu-eg621.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF38fTSAPYuRAABkLHzXEVA431.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl38fqeACYJNAACQDeJBU58075.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4Jsh6AbVZ-AAB_Y_MH7f4077.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4O9F2AR8XVAACUtGWSKRc535.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4S44OAXtbZAAG7wulxruI786.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4VUHSAFpAZAAANfyy0aXE323.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4ejCmAPqZMAAGZw5NzqtE067.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4le8SAYKHDAABbO_HZa9c237.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4le9SAL6enAAGpXZi8Wcg079.jpg">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4le_eAafhbAABp-t8dt_8312.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4lfAyAC4zxAAB1UtAAltk817.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4lheGALDjnAAHFyzrSvqU109.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl4lhhSAZIuZAABMMZW2RVk163.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl46RpiAC7t7AAAa3NLU-Uk716.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl49B9GAHIQWAABs3zG_-08605.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5M5a6ADeCKAABC52ZxZCk238.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5WX0OAUkXdAADovQH3upQ950.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF5Y0OGAKVKjAACCEFYDuCw593.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5c0xaASO8FAAFKHNM1bu8607.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5h8oSAKLBQAABld2EcD7Q385.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/CgpOIF5vI8yAE1n_AACnC3UQ3xM235.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl5vI8yAfRpUAACP4YXZ3sg831.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl54fTKALhevAAB_l3axT_o532.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Ciqah154fUGAS19LAAGap07f1AU762.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Ciqah157Dw6AfJVGAABiifLhJkU236.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Ciqah157Dw6Aeo7EAAA0bxPJeKw538.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl57Dw6AdKyOAADBt-00qXo349.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl57Dw6ADE7rAADRJKFrbWE816.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl6NrzGAMfz3AABHRjw_QSE080.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Cgq2xl6NrzGAeQrqAAA0YIeU1Qg392.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/02021203223.png">
<meta property="og:image" content="https://imokkkk.github.io/assets/img/Ciqc1F6pW3CAHYjKAACSEPDrUoc078.png">
<meta property="article:published_time" content="2024-02-24T01:58:26.947Z">
<meta property="article:modified_time" content="2021-06-13T15:00:06.936Z">
<meta property="article:author" content="ImOkkkk">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imokkkk.github.io/assets/img/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.png">

<link rel="canonical" href="https://imokkkk.github.io/multithreading/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发编程 | ImOkkkk BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ImOkkkk BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ImOkkkk BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">When they go low,we go high.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">44</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://imokkkk.github.io/multithreading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../assets/img/head.jpg">
      <meta itemprop="name" content="ImOkkkk">
      <meta itemprop="description" content="Java开发, 后端开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ImOkkkk BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-24 09:58:26" itemprop="dateCreated datePublished" datetime="2024-02-24T09:58:26+08:00">2024-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-多线程基础"><a href="#1-多线程基础" class="headerlink" title="1.多线程基础"></a>1.多线程基础</h3><h4 id="1-1-实现多线程的方法"><a href="#1-1-实现多线程的方法" class="headerlink" title="1.1 实现多线程的方法"></a>1.1 实现多线程的方法</h4><ol>
<li><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现Runnable接口实现多线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<p>2. </p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_02</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;继承Thread类实现多线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>线程池创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">   </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，默认采用DefaultThreadFactory，它会给线程池创建的线程设置一些默认值，如：线程的名字、是否守护线程，以及线程的优先级等。但无论怎么设置这些这些属性，最终还是通过new Thread()创建线程的，只不过这里的构造函数传入的参数要多一些，<strong>本质还是通过new Thread()实现的</strong>。</p>
</li>
<li><p>实现有返回值的Callable创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test_03</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; : &quot;</span>+ i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">Test_03</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable创建线程是无返回值的，而Callable和与之相关的Future、FutureTask，它们可以把线程执行的结果作为返回值返回。</p>
</li>
</ol>
<p><strong>……</strong></p>
<p><strong>实现线程只有一种方式</strong></p>
<p>启动线程需要调用start()方法，而start方法最终会调用run()方法，分析run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>target实际上就是一个Runnable，即使用Runnable接口实现线程时传给Thread类的对象。第二种，继承Thread方式，继承Thread之后，会把run()方法重写，最终还是会调用thread.start()方法启动线程，而start()方法最终也会调用这个已经被重写的run()方法来执行任务。创建线程<strong>本质就是构造一个Thread类</strong>，不同点在于<strong>实现线程运行内容的方式不同</strong>，可以通过实现Runnable接口，或继承Thread类重写run()方法。</p>
<h4 id="1-2-实现Runnable接口比继承Thread类实现线程更好？"><a href="#1-2-实现Runnable接口比继承Thread类实现线程更好？" class="headerlink" title="1.2 实现Runnable接口比继承Thread类实现线程更好？"></a>1.2 实现Runnable接口比继承Thread类实现线程更好？</h4><ol>
<li>Java不支持多继承，一旦继承了Thread类，就无法再继承其它类，限制了代码的可扩展性。</li>
<li>Runnable里只有一个run()方法，定义了需要执行的内容，实现了Runnable与Thread类的解耦，Thread类负责线程启动和属性设置，权责分明。</li>
</ol>
<h4 id="1-3-如何正确停止线程？"><a href="#1-3-如何正确停止线程？" class="headerlink" title="1.3 如何正确停止线程？"></a>1.3 如何正确停止线程？</h4><p>对于Java而言，最正确的停止线程的方式是使用interrupt，但<strong>interrupt仅仅起到通知被停止线程的作用，而对于被停止的线程而言，它拥有完全的自主权</strong>，即可以选择立即停止，也可以一段时间后停止，也可以不停止。Java<strong>希望程序间可以相互通知、相互协作的管理线程，如果贸然停止线程可能会造成一些安全性问题</strong>，为了避免造成问题就需要给对方一定的时间来整理收尾工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦调用某个线程的interrupt后，该线程的中断标记位就会被设置成true，每个线程都有这样的标记位，当线程执行时应定期检查这个标记位。上面代码可以看到，while循环判断语句中，先通过Thread.currentThread().isInterrupt()判断是否被中断，随后检查是否还有工作要做。</p>
<h4 id="1-4-sleep期间能否感受到中断？"><a href="#1-4-sleep期间能否感受到中断？" class="headerlink" title="1.4 sleep期间能否感受到中断？"></a>1.4 sleep期间能否感受到中断？</h4><p>如果sleep、wait等可以让线程进入阻塞的方法使线程休眠了，而<strong>处于休眠中的线程被中断，线程是可以感受到中断信号的，并会抛出InterruptedException</strong>，同时清除中短信号，将中断标记位设为false。</p>
<p>处理方式：</p>
<ol>
<li><p>方法签名抛异常，run()强制try&#x2F;catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">subTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求每一个方法的调用方有义务去处理异常。<strong>调用方要不使用try&#x2F;catch并在catch中正确处理异常，要不将异常声明到方法签名中</strong>。如果每层逻辑都遵守规范，便可以将中断信号传递到顶层，最终让run()方法可以捕获到异常。而对于run()方法而言，它本身没有抛出checkedException的能力，只能通过try&#x2F;catch来处理异常。层层传递异常保障了异常不会被遗漏，而对于run()方法，就可以根据不同的业务逻辑来进行相应的处理。</p>
</li>
<li><p>再次中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在catch语句中再次中断线程。如果线程在休眠期间被中断，那么会自动清除中断信号。如果这时手动添加中断信号，中断信号依然可以被捕捉到。</p>
</li>
</ol>
<h4 id="1-5-为什么用volatile标记位的停止方法是错误的？"><a href="#1-5-为什么用volatile标记位的停止方法是错误的？" class="headerlink" title="1.5 为什么用volatile标记位的停止方法是错误的？"></a>1.5 为什么用volatile标记位的停止方法是错误的？</h4><p><strong>stop()会直接把线程停止，会导致出现数据完整性等问题。suspend()和resume()并不会释放锁，就开始进入休眠，但此时有可能仍持有锁，容易导致死锁问题。</strong></p>
<p><strong>volatile修饰标记位适用的场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCanStop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!canceled &amp;&amp; num &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num + <span class="string">&quot;是10的倍数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">VolatileCanStop</span> <span class="variable">canStop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileCanStop</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(canStop);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        canStop.canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动线程，经过3s，把volatile修饰的标记位设置为true，那么下一次while循环中判断出canceled的值为true，就跳出while循环，线程停止。</p>
<p><strong>volatile修饰标记位不适用的场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileCanNotStop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(storage);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line">        producerThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(storage);</span><br><span class="line">        <span class="keyword">while</span> (consumer.needMoreNums()) &#123;</span><br><span class="line">            System.out.println(consumer.storage.take() + <span class="string">&quot;被消费了&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者不需要更多数据了。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来</span></span><br><span class="line">        producer.canceled = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(producer.canceled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canceled &amp;&amp; num &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    storage.put(num);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num + <span class="string">&quot;是50的倍数，被放到仓库中了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者结束运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    BlockingQueue storage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">needMoreNums</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.97</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程被长时间阻塞的情况，就无法及时感受中断</strong>：尽管已经把canceled的标记位设置为true，但生产者仍然没有被停止，是因为生产者在执行storage.put(num)时发生阻塞，在它被叫醒之前是没有办法进入下次循环判断canceled的值的，这种情况下volatile没有办法让生产者停下来的，如果用interrupt语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做相应处理。</p>
<h4 id="1-6-线程是如何在6种状态之间转换的？"><a href="#1-6-线程是如何在6种状态之间转换的？" class="headerlink" title="1.6 线程是如何在6种状态之间转换的？"></a>1.6 线程是如何在6种状态之间转换的？</h4><p><strong>线程的6种状态</strong><br><img data-src="/../../../../assets/img/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.png"></p>
<ol>
<li>New(新建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed Waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ol>
<ul>
<li><p>New 新建<br>New表示线程被创建但尚未启动的状态：new Thread()新建一个线程时，如果线程没有开始运行start()方法，所以也没有开始执行run()方法里面的代码，此时它的状态就是New。一旦线程调用了start()，就变成Runnable。</p>
</li>
<li><p>Runnable 可运行<br>Java中的Runnable状态对应操作系统线程状态中的两种状态，分别是Running和Ready，即Java中处于Runnable状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配CPU资源。所以，如果一个正在运行的线程是Runnable状态，当它运行到任务的一半时，执行该线程的CPU被调度去做其他事情，导致该线程暂时不运行，它的状态仍为Runnable，因为它有可能随时被调度回来继续执行任务。</p>
</li>
<li><p>Blocked 被阻塞<br>从Runnable状态进入Blocked状态只有一种可能，就是进入synchronized保护的代码块&#x2F;方法时没有抢到monitor锁，Blocked仅仅针对synchronized monitor锁。</p>
</li>
<li><p>Waiting 等待<br>线程进入Waiting</p>
<ol>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.park()方法</li>
</ol>
<p>Blocked与Waiting的区别是Blocked在等待其它线程释放monitor锁，而Waiting则是在等待某个条件，比如join的线程执行完毕，或者是notify()&#x2F;notifyAll()。</p>
</li>
<li><p>Timed Waiting 限期等待<br>Waiting和Time Waiting区别：有没有时间限制，Timed Waiting会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。</p>
<p>线程进入Timed Waiting</p>
<ol>
<li>设置了时间参数的Thread.sleep(long millis)方法</li>
<li>设置了时间参数的Object.wait(long timeout)方法</li>
<li>设置了时间参数的Thread.join(long millis)方法</li>
<li>设置了时间参数的LockSupport.parkNanos(long nanos)方法和LockSupport.parkUntil(long deadline)方法</li>
</ol>
<p>Blocked—&gt;Runnable：线程获取monitor锁</p>
<p>Waiting—&gt;Runnable：执行了LockSupport.unpark()，或join的线程运行结束，或者被中断。</p>
<p>Waiting—&gt;Blocked：其它线程调用notify()或notifyAll()，因为唤醒Waiting线程的线程如果调用notify()或notifyAll()，必须首先持有该monitor锁，所以处于Waiting状态的线程被唤醒时拿不到该锁，就会进入Blocked状态，直到执行notify()&#x2F;notifyAll()的唤醒线程执行完毕并释放monitor锁，才可能轮到它去抢夺这把锁，抢到就会从Blocked状态回到Runnable状态。</p>
<p>TimedWaiting类似，但如果它的超时时间到了且能直接获取到锁&#x2F;join的线程运行结束&#x2F;被中断&#x2F;调用了LockSupport.unpark()，会直接恢复到Runnable状态。</p>
</li>
<li><p>Terminated<br>线程进入Terminated</p>
<ol>
<li>run()方法执行完毕，线程正常退出。</li>
<li>出现一个没有捕获的异常，终止了run()方法，最终导致意外终止。</li>
</ol>
</li>
</ul>
<p><strong>Tips</strong></p>
<ol>
<li>线程的状态是按照箭头方向走的，如线程从New不可以进入Blocked，它需要经历Runnable。</li>
<li>线程的生命周期不可逆：一旦进入Runnable就不能回到New状态；一旦被终止就不可能有任何状态的变化。所以一个线程只有一次New和Terminated状态，只有处于中间状态才可以相互转换。</li>
</ol>
<h4 id="1-7-为什么wait必须在synchronized保护的同步代码中使用？"><a href="#1-7-为什么wait必须在synchronized保护的同步代码中使用？" class="headerlink" title="1.7 为什么wait必须在synchronized保护的同步代码中使用？"></a>1.7 为什么wait必须在synchronized保护的同步代码中使用？</h4><h4 id="1-8-为什么wait-notify-notifyAll方法被定义在Object类中，而sleep定义在Thread类中？"><a href="#1-8-为什么wait-notify-notifyAll方法被定义在Object类中，而sleep定义在Thread类中？" class="headerlink" title="1.8 为什么wait&#x2F;notify&#x2F;notifyAll方法被定义在Object类中，而sleep定义在Thread类中？"></a>1.8 为什么wait&#x2F;notify&#x2F;notifyAll方法被定义在Object类中，而sleep定义在Thread类中？</h4><ol>
<li>Java中每个对象都有一把称之为monitor监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait&#x2F;notify&#x2F;notifyAll也都是锁级别的操作，它们的锁属于对象，所以把它们定义在Object类，因为Object类是所有对象的父类。</li>
<li>如果把wait&#x2F;notify&#x2F;notifyAll方法定义在Thread类中，会带有很大的局限性，如一个线程可能持有多个锁。如何明确当前线程等待的是哪把锁呢？既然是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现。</li>
</ol>
<h4 id="1-9-wait-notify和sleep方法的异同"><a href="#1-9-wait-notify和sleep方法的异同" class="headerlink" title="1.9 wait&#x2F;notify和sleep方法的异同"></a>1.9 wait&#x2F;notify和sleep方法的异同</h4><p>相同点</p>
<ol>
<li>都可以让线程阻塞</li>
<li>都可以响应interrupt中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出InterruptedException</li>
</ol>
<p>不同点</p>
<ol>
<li>wait方法必须在synchronized保护的代码中使用，而sleep方法并没这个要求。</li>
<li>在同步代码块中执行sleep方法，并不会释放monitor锁，但执行wait方法时会主动释放monitor锁。</li>
<li>sleep方法必须定义一个时间，时间到期后会主动会恢复，而对于没有参数的wait方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不主动恢复。</li>
<li>wait&#x2F;notify是Object类的方法，而sleep是Thread类的方法。</li>
</ol>
<h3 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2.线程安全"></a>2.线程安全</h3><p>如果某个对象是线程安全的，即使用时就不需要考虑方法间的协调问题。</p>
<h4 id="2-1-3种典型的线程安全问题"><a href="#2-1-3种典型的线程安全问题" class="headerlink" title="2.1 3种典型的线程安全问题"></a>2.1 3种典型的线程安全问题</h4><ol>
<li><p>运行结果错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongResult</span> &#123;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">       thread1.start();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">       thread2.start();</span><br><span class="line">       thread1.join();</span><br><span class="line">       thread2.join();</span><br><span class="line">       System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i++并不是一个原子操作</p>
</li>
<li><p>发布或初始化导致线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrongInit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, String&gt; students;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WrongInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                students = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                students.put(<span class="number">1</span>, <span class="string">&quot;王小美&quot;</span>);</span><br><span class="line">                students.put(<span class="number">2</span>, <span class="string">&quot;钱二宝&quot;</span>);</span><br><span class="line">                students.put(<span class="number">3</span>, <span class="string">&quot;周三&quot;</span>);</span><br><span class="line">                students.put(<span class="number">4</span>, <span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer, String&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WrongInit</span> <span class="variable">wrongInit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WrongInit</span>();</span><br><span class="line">        System.out.println(wrongInit.getStudents().get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>students 这个成员变量是在构造函数中新建的线程中进行的初始化和赋值操作，而线程的启动需要一定的时间，但是我们的 main 函数并没有进行等待就直接获取数据，导致 getStudents 获取的结果为 null，这就是<strong>在错误的时间或地点发布或初始化造成的线程安全问题</strong>。</p>
</li>
<li><p>活跃性问题</p>
<p>分别为死锁、活锁和饥饿</p>
<ul>
<li><p>死锁：两个线程之间相互等待对方资源，但同时又互不相让，都想自己先执行，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MayDeadLock</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1成功拿到两把锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thread2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2成功拿到两把锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MayDeadLock</span> <span class="variable">deadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MayDeadLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                deadLock.thread1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                deadLock.thread2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>活锁：与死锁类似，不过活锁是活的，因为正在运行的线程并没有阻塞，它始终在运行，缺一直得不到结果。假设有一个消息队列里放着需要被处理的消息，而某个消息由于自身的错误无法被正确处理，同时队列的重试机制会把它放在队列头进行优先重试处理。</p>
</li>
<li><p>饥饿：线程需要某些资源始终得不到，尤其是CPU资源，就会导致线程一直不能运行。</p>
<ol>
<li>在Java中有1-10的线程优先级，1最低，10最高。如果某个线程的优先级为1，该线程就有可能始终分配不到CPU资源，而导致长时间无法运行。</li>
<li>或者是某个线程始终持有某个文件的锁，其他线程想要修改文件必须先获取锁，这时想要修改文件的线程就会陷入饥饿。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-需要额外注意线程安全的场景"><a href="#2-2-需要额外注意线程安全的场景" class="headerlink" title="2.2 需要额外注意线程安全的场景"></a>2.2 需要额外注意线程安全的场景</h4><ol>
<li><p>访问共享变量和资源</p>
<p>如访问共享对象的属性、访问static静态变量、访问共享的缓存等。</p>
</li>
<li><p>依赖时序的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">    map.remove(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同数据之间存在绑定关系</p>
<p>不同的数据之间是成组出现的，存在着相互对应或绑定的关系，最典型的就是IP和端口号。</p>
</li>
<li><p>对方没有声明自己是线程安全的</p>
</li>
</ol>
<h4 id="2-3-为什么多线程会带来性能问题"><a href="#2-3-为什么多线程会带来性能问题" class="headerlink" title="2.3 为什么多线程会带来性能问题"></a>2.3 为什么多线程会带来性能问题</h4><p>单线程是独立工作的，不需要与其他线程进行交互，但多线程之间则需要调度以及协作，<strong>调度</strong>与<strong>协作</strong>就会带来性能开销从而产生性能问题。</p>
<ul>
<li><p>调度开销</p>
<ol>
<li><p><strong>上下文切换：</strong>线程数往往大于CPU核心数，操作系统会按照一定的调度算法，给每个线程分配时间片。而在进行调度时就会引起上下文切换，<strong>上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程。</strong></p>
</li>
<li><p><strong>缓存失效：</strong>进行了线程调度，切换到其他线程，CPU就会去执行不同的代码，<strong>原有的缓存就很有可能失效了，需要重新缓存新的数据。</strong></p>
<p>给被调度到的线程设置最小执行时间，即只有执行完这段时间后，才可能进行下一次的调度，由此减少上下文切换的次数。</p>
</li>
</ol>
</li>
<li><p>协作开销</p>
<p>为了避免共享数据错乱、保证线程安全，就有可能<strong>禁止编译器和CPU对其进行重排序等优化</strong>，也可能出于同步的目的，<strong>反复把线程工作内存的数据flush到主内存，然后再从主内存refresh到其他线程的工作内存中</strong>。</p>
</li>
</ul>
<h4 id="2-4-使用线程池的好处"><a href="#2-4-使用线程池的好处" class="headerlink" title="2.4 使用线程池的好处"></a>2.4 使用线程池的好处</h4><ol>
<li>线程池可以解决线程生命周期的系统开销问题，线程池里的线程可以复用，消除了线程创建带来的延迟，从而提高响应速度。</li>
<li>线程池可以统筹内存和CPU的使用，避免资源的使用不当。</li>
<li>线程池可以统一管理资源。</li>
</ol>
<h4 id="2-5-线程池各参数的含义"><a href="#2-5-线程池各参数的含义" class="headerlink" title="2.5 线程池各参数的含义"></a>2.5 线程池各参数的含义</h4><p><img data-src="/../../../../assets/img/CgoB5l3eH8mAAoJCAACEOKMHtpw036.png"></p>
<p><img data-src="/../../../../assets/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png"></p>
<p><strong>线程池的特点：</strong></p>
<ol>
<li>线程池希望保持较少的线程数，只有在负载变的很大时才增加线程。</li>
<li>线程池只有在任务队列满时才会创建多于corePoolSize的线程，如果使用的是无界队列(如LinkedBlockingQueue)，线程数不会超过corePoolSize。</li>
<li>设置corePoolSize和maxPoolSize为相同的值，可以创建固定大小的线程池。</li>
</ol>
<h4 id="2-6-线程池有哪几种拒绝策略？"><a href="#2-6-线程池有哪几种拒绝策略？" class="headerlink" title="2.6 线程池有哪几种拒绝策略？"></a>2.6 线程池有哪几种拒绝策略？</h4><p><img data-src="/../../../../assets/img/CgotOV3g0WWAVWVlAAEsBI6lEEA162.png"></p>
<ul>
<li>AbortPolicy：拒绝任务时直接抛出一个类型为RejectedExecutionException的RuntimeException，可以感知到任务被拒绝了，可以根据业务逻辑选择重试或放弃提交等。</li>
<li>DiscardPolicy：当新任务被提交后直接被丢弃掉，不会有任何通知。</li>
<li>DiscardOldestOlicy：丢弃任务队列的头节点，通常是存活时间最长的任务，也不会有任何通知。</li>
<li>CallerRunsPolicy：把任务交给提交任务的线程执行，即谁提交任务，谁就负责执行任务。<ol>
<li>提交的任务不会被丢弃</li>
<li>提交任务的线程负责执行任务，提交任务的线程被占用，不会再提交新的任务，线程池中的线程也可以利用这段时间执行掉一部分任务，相当于是给了线程池一定的缓冲期。</li>
</ol>
</li>
</ul>
<h4 id="2-7-有哪6种常见的线程池？什么是Java8的ForkJoinPool"><a href="#2-7-有哪6种常见的线程池？什么是Java8的ForkJoinPool" class="headerlink" title="2.7 有哪6种常见的线程池？什么是Java8的ForkJoinPool?"></a>2.7 有哪6种常见的线程池？什么是Java8的ForkJoinPool?</h4><ul>
<li><p>FixedThreadPool</p>
<p>核心线程数和最大线程数是一样的，可以看作是固定线程数的线程池，没有可用的线程的时候，任务会放在队列中等待，任务的长度无限制(LinkedBlockingQueue)</p>
</li>
<li><p>CachedThreadPool</p>
<p>线程数几乎可以无限增加(Integer.MAX_VALUE，2^31-1)，该线程池的线程数量不固定，不够使用时自动增加，闲置时自动回收。队列为SynchronousQueue，队列容量为0，实际不存储任务，只对任务进行中转和传递。</p>
</li>
<li><p>ScheduledThreadPool</p>
<p>支持定时或周期的执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//延迟指定时间后执行一次任务，10秒执行一次</span></span><br><span class="line">service.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//以固定的频率执行任务</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//与第二种类似，不过scheduledAtFixedRate以开始时间为起点，时间到就开始第二次，而scheduledWithFixedDelay以任务结束时间为下一次循环的时间起点开始计算</span></span><br><span class="line">service.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
</li>
<li><p>SingleThreadExecutor</p>
<p>原理与FixedThreadPool一样，线程只有一个，如果线程在执行过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。适合用于任务需要按被提交的顺序依次执行的场景。</p>
</li>
<li><p>SingleThreadScheduledExecutor</p>
<p>于ScheduledThreadPool类似，如源码所示：只是将ScheduledThreadPool的核心线程数设置为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="/../../../../assets/img/CgoB5l3kzomAckv5AAAxf6FCPco696.png"></p>
</li>
<li><p>ForkJoinPool</p>
</li>
</ul>
<h4 id="2-8-线程池常用的阻塞队列"><a href="#2-8-线程池常用的阻塞队列" class="headerlink" title="2.8 线程池常用的阻塞队列"></a>2.8 线程池常用的阻塞队列</h4><p><img data-src="/../../../../assets/img/Cgq2xl3nUryAJBkpAAA0_WFSrB8184.png"></p>
<ul>
<li><p>LinkedBlockingQueue</p>
<p>对于FixedThreadPool和SingleThreadExector，它们使用的是容量为Integer.MAX_VALUE的LinkedBlockingQueue，可以任务是无界队列。</p>
</li>
<li><p>SynchronousQueue</p>
<p>对于CachedThreadPool，最大线程数为Integer.MAX_VALUE，所以不需要任务队列来存储任务，一旦有任务提交就直接转发给线程或创建新线程来执行。</p>
</li>
<li><p>DelayedWorkQueue</p>
<p>对于ScheduledThreadPool和SingleThreadScheduledExecutor，DelayedWorkQueue内部元素并不是按照放入的时间排序，而是按照延迟的时间长短对任务进行排序，内部采用的是”堆”的数据结构。</p>
</li>
</ul>
<h4 id="2-9-为什么不应该自动创建线程池？"><a href="#2-9-为什么不应该自动创建线程池？" class="headerlink" title="2.9 为什么不应该自动创建线程池？"></a>2.9 为什么不应该自动创建线程池？</h4><ul>
<li><p>FixedThreadPool、SingleThreadPool</p>
<p>使用的队列是没有上限的LinkedBlockingQueue，如果处理任务过慢，队列中堆积的任务会越来越多，占用大量内存，导致OOM。</p>
</li>
<li><p>CachedThreadPool</p>
<p>不限制线程的数量，任务特别多时，有可能会创建非常多的线程，最终导致超过了操作系统的上限而无法创建线程，或导致内存不足。</p>
</li>
<li><p>ScheduledThreadPool、SingleThreadScheduledExecutor</p>
<p>DelayedWorkQueue也是一个无界队列。</p>
</li>
</ul>
<h4 id="2-10-合适的线程数是多少？"><a href="#2-10-合适的线程数是多少？" class="headerlink" title="2.10 合适的线程数是多少？"></a>2.10 合适的线程数是多少？</h4><ul>
<li><p>CPU密集型任务</p>
<p>如加密、解密、压缩、计算等大量耗费CPU资源的任务，线程数为CPU核心数的1-2倍。</p>
</li>
<li><p>耗时IO型任务</p>
<p>如数据库、文件的读写、网络通信等并不消耗CPU资源的任务，线程数&#x3D;CPU核心数*(1+平均等待时间&#x2F;平均工工作时间)</p>
</li>
</ul>
<p>线程的平均工作时间所占比例越高，就需要越少的线程。线程的平均等待时间所占比例越高，就需要越多的线程。</p>
<h4 id="2-11-如何正确关闭线程？"><a href="#2-11-如何正确关闭线程？" class="headerlink" title="2.11 如何正确关闭线程？"></a>2.11 如何正确关闭线程？</h4><ul>
<li><p>shutdown()</p>
<p>安全的关闭的一个线程池，调用shutdown()之后，如果还有新任务被提交，线程池会根据拒绝策略直接拒绝后续提交的任务，执行完正在执行的任务和队列中等待的任务后关闭。</p>
</li>
<li><p>isShutdown()</p>
<p>判断线程是否已经开始了关闭工作，即是否执行了shutdown()或shutdownNow()</p>
</li>
<li><p>isTerminated()</p>
<p>检测线程池是否真正”终结”了，即线程池已关闭，同时线程池中的所有任务都执行完毕了。</p>
</li>
<li><p>awaitTermination()</p>
<p>判断线程池状态，如给awaitTermination方法传入的参数为10秒，那么它会陷入10秒等待，直到</p>
<ol>
<li>等待期间(包括进入等待之前)，线程池已关闭并所有任务都执行完毕，相当于线程池”终结”了，方法便返回true。</li>
<li>等待超时时间到后，线程池始终未”终结”，返回false。</li>
<li>等待期间线程被中断，方法抛出InterruptedException异常。</li>
</ol>
<p>即调用awaitTermination方法后当前线程池会尝试等待一定指定的时间，如果在等待时间内，线程池已关闭并任务都执行完毕，方法返回true，否则返回false。</p>
</li>
<li><p>shutdownNow()</p>
<p>立刻关闭，执行shutdownNow()方法之后，首先会给线程池中的线程发送interrupt中断信号，尝试中断这些任务的执行，然后会将等待的所有任务转移到一个List中并返回。</p>
</li>
</ul>
<h3 id="3-各种各样的”锁”"><a href="#3-各种各样的”锁”" class="headerlink" title="3.各种各样的”锁”"></a>3.各种各样的”锁”</h3><h4 id="3-1-你知道哪几种锁？分别有什么特点？"><a href="#3-1-你知道哪几种锁？分别有什么特点？" class="headerlink" title="3.1 你知道哪几种锁？分别有什么特点？"></a>3.1 你知道哪几种锁？分别有什么特点？</h4><ol>
<li><p><strong>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</strong></p>
<p>特指synchronized锁的状态，通过在对象头中的mark word来表明锁的状态。</p>
<ul>
<li><p>偏向锁</p>
<p>如果，这把锁一直不存在竞争，就没必要上锁，只需打个标记就行。对象被初始化，还没有线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获取锁，开销很小，性能最好。</p>
</li>
<li><p>轻量级锁</p>
<p>synchronized中的代码是被多个线程交替执行的，并不存在实际的竞争、或只有短时间的竞争，用<strong>CAS</strong>就可以解决。轻量级锁是指当锁原来是偏向锁时，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过<strong>自旋</strong>的形式获取锁，而不会陷入阻塞。</p>
</li>
<li><p>重量级锁</p>
<p>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，开销相对较大。当多个线程直接实际竞争，且锁竞争时间长的时候，锁就会膨胀为重量级锁。<strong>重量级锁会让其它申请缺拿不到锁的线程进入到阻塞状态。</strong></p>
</li>
</ul>
<p>偏向锁性能最好，可以避免执行CAS操作。而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p>
</li>
<li><p><strong>可重入锁&#x2F;不可重入锁</strong></p>
<p>可重入锁指的是线程当前已经持有这把锁了，能在不释放这个锁的情况下，再次获取这把锁。不可重入锁指的是虽然当前持有了这把锁，但如果想再次获取此锁，也必须先要释放锁后才能再次尝试获取。</p>
</li>
<li><p><strong>共享锁&#x2F;独占锁</strong></p>
<p>共享锁指同一把锁可以被多个线程同时获得，而独占锁指这个锁只能同时被一个线程获得。如读写锁中的读锁是共享锁，而写锁是独占锁。</p>
</li>
<li><p><strong>公平锁&#x2F;非公平锁</strong></p>
<ul>
<li><p>公平锁</p>
<p>如果线程现在拿不到这把锁，那么线程都会进入等待，开始排队，在等待队列等待时间长的线程会优先拿到这把锁，先来先得。</p>
</li>
<li><p>非公平锁</p>
<p>在一定情况下，忽略掉已经在排队的线程，发生插队现象。</p>
</li>
</ul>
</li>
<li><p><strong>悲观锁&#x2F;乐观锁</strong></p>
<ul>
<li><p>悲观锁</p>
<p>在获取资源之前，必须先拿到锁，以便达到”独占”的状态。</p>
</li>
<li><p>乐观锁</p>
<p>并不要求在获取资源前拿到锁，也不会锁住资源，利用CAS理念，在不独占资源的情况下，完成对资源的修改。</p>
</li>
</ul>
</li>
<li><p><strong>自旋锁&#x2F;非自旋锁</strong></p>
<ul>
<li><p>自旋锁</p>
<p>如果线程现在拿不到锁，并不直接陷入阻塞或者释放CPU资源，而是开始利用循环，不停的尝试获取锁。</p>
</li>
<li><p>非自旋锁</p>
<p>拿不到锁就直接放弃，或者进行其它的处理逻辑，如阻塞、排队等。</p>
</li>
</ul>
</li>
<li><p><strong>可中断锁&#x2F;不可中断锁</strong></p>
<p>synchronized关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路，只能等拿到锁以后才能进行其它的逻辑处理。</p>
<p>ReentrantLock是一种典型的可中断锁，如使用lockInterruptibly方法在获取锁的过程中，突然不想获取了，可以在中断之后去做其它的事。</p>
</li>
</ol>
<h4 id="3-2-悲观锁与乐观锁"><a href="#3-2-悲观锁与乐观锁" class="headerlink" title="3.2 悲观锁与乐观锁"></a>3.2 悲观锁与乐观锁</h4><ul>
<li><p><strong>悲观锁</strong></p>
<p>为了确保结果的正确性，会在每次获取并修改数据时，都把数据锁住，让其他线程无法访问。</p>
<p>线程A拿到了锁，并且正在操作同步资源，那么此时线程B就必须进行等待。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl38fTSAE0T3AABXxHZ9Gus225.png"></p>
<p>当线程A执行完毕后，CPU才会唤醒正在等待这把锁的线程B再次尝试获取锁</p>
<p><img data-src="/../../../../assets/img/Cgq2xl38fTSALLQ8AABbKYnu-eg621.png"></p>
<p>如果线程B获取到了锁，才可以对同步资源进行自己的操作。</p>
<p><img data-src="/../../../../assets/img/CgpOIF38fTSAPYuRAABkLHzXEVA431.png"></p>
</li>
<li><p><strong>乐观锁</strong></p>
<p>认为自己在操作资源的时候不会有其他线程干扰，所以并不会锁住被操作对象。为了确保数据正确性，在更新之前，会去对比在修改数据期间，数据有没有被其他线程修改过。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl38fqeACYJNAACQDeJBU58075.png"></p>
<p>例子：</p>
<ul>
<li><p>悲观锁：synchronized关键字和Lock接口</p>
<p>以Lock接口为例，如Lock的实现类ReentrantLock，类中的lock()等方法就是执行加锁，而unlock()方法就是执行解锁()。处理资源之前必须要先加锁并拿到锁，等到处理完之后再解开锁。</p>
</li>
<li><p>乐观锁：原子类</p>
<p>如AtomicInteger在更新数据时，多个线程可以同时操作同一个原子变量。</p>
</li>
</ul>
<p><strong>两种锁各自的使用场景：</strong></p>
<ul>
<li>悲观锁适合于并发写入多、临界区代码复杂、竞争激烈等场景，此时悲观锁可以避免大量的无用的反复尝试等消耗。</li>
<li>乐观锁适用于读取多，修改少的场景，也适合虽然读写都很多，但是并发不激烈的场景。</li>
</ul>
</li>
</ul>
<h4 id="3-3-synchronized背后的monitor锁"><a href="#3-3-synchronized背后的monitor锁" class="headerlink" title="3.3 synchronized背后的monitor锁"></a>3.3 synchronized背后的monitor锁</h4><p>获取和释放monitor锁的时机：线程在进入synchronized保护的代码块之前，会自动获取锁；并且无论是正常退出，还是抛出异常退出，在退出的时候都会自动释放锁。</p>
<p>查看反汇编命令：javac SynTest.java    javap -verbose SynTest.class</p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           ......</span><br><span class="line"><span class="number">3</span>: monitorenter</span><br><span class="line">           <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">           <span class="number">7</span>: ldc           #<span class="number">3</span>                      <span class="comment">// String lagou</span></span><br><span class="line">           <span class="number">9</span>: invokevirtual #<span class="number">4</span>               <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">          <span class="number">12</span>: aload_1</span><br><span class="line">          <span class="number">13</span>: monitorexit</span><br><span class="line">          <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">          <span class="number">17</span>: astore_2</span><br><span class="line">          <span class="number">18</span>: aload_1</span><br><span class="line">          <span class="number">19</span>: monitorexit</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>

<p>monitorenter可以理解为加锁，monitorexit理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未锁定的对象的该计数器未0。</p>
<ul>
<li><p>monitorenter</p>
<ol>
<li>如果该monitor的计数为0，则线程获得该monitor并将其计数设置为1，该线程就是这个monitor的所有者。</li>
<li>如果线程已经拥有了这个monitor，则它将重新进入，并且累加计数。</li>
<li>如果其他线程已经拥有了这个monitor，那么这个线程就会被阻塞，直到这个monitor的计数器变为0，代表这个monitor已经被释放了，于是当前这个线程就会再次尝试获取这个monitor。</li>
</ol>
</li>
<li><p>monitorexit</p>
<p>作用：将monitor的计数器减1，直到减为0为止。代表这个monitor已经被释放了，已经没有任何线程拥有它了，也就代表着解锁。其他正在等待这个monitor的线程，此时可以再次尝试获取这个monitor的所有权。</p>
</li>
</ul>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synMethod</span><span class="params">()</span>;</span><br><span class="line">      descriptor: ()V</span><br><span class="line">      flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">        Code:</span><br><span class="line">          stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>  被synchronized修饰的方法会有一个ACC_SYNCHRONIZED标志，当某个线程要访问某个方法时，会首先检查方法是否有ACC_SYNCHRONIZED标志，如果有则需要先获得monitor锁，方法执行之后再释放monitor锁。</p>
</li>
</ul>
<h4 id="3-4-synchronized与Lock"><a href="#3-4-synchronized与Lock" class="headerlink" title="3.4 synchronized与Lock"></a>3.4 synchronized与Lock</h4><ul>
<li><p>相同点</p>
<ol>
<li>synchronized和Lock都是用来保护资源线程安全的</li>
<li>都可以保证可见性</li>
<li>synchronized和ReentrantLock(Lock的一个实现类)都拥有可重入的特点</li>
</ol>
</li>
<li><p>不同点</p>
<ol>
<li><p>用法区别</p>
<p>synchronized关键字可以加在方法上，不需要指定锁对象(此时的锁对象为this)；也可以修饰同步代码块并且自定义monitor对象。而Lock锁对象必须显示的开始加锁lock()和解锁unlock()，并且一般会在finally块中确保用unlock()来解锁，以防止发生死锁。</p>
</li>
<li><p>加解锁顺序不同</p>
<p>对于Lock而言如果有多把Lock锁，Lock可以不完全按照加锁的反序解锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">lock2.lock();</span><br><span class="line">...</span><br><span class="line">lock1.unlock();</span><br><span class="line">lock2.unlock();</span><br></pre></td></tr></table></figure>

<p>synchronized解锁的顺序和加锁的顺序必须完全相反，obj2先解锁，obj1后解锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj1)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized锁不够灵活</p>
<p>一旦synchronized锁已经被某个线程获得了，此时其他线程如果还想获得，那么它只能被阻塞，直到持有锁的线程运行完毕或发生异常从而释放这个锁。Lock类在等待锁的过程中，如果使用的时lockInterruptibly方法，如果等待时间太长，可以中断退出，也可以使用tryLock()等方法尝试获取锁，如果获取不到可以执行其他逻辑。</p>
</li>
<li><p>synchronized锁只能同时被一个线程拥有，但Lock锁没有这个限制。</p>
<p>如在读写锁中的读锁，是可以被多个线程同时拥有的，但synchronized不行。</p>
</li>
<li><p>原理区别</p>
<p>synchronized是内置锁，由JVM实现获取锁和解锁，还分为偏向锁、轻量级锁、重量级锁。Lock根据实现不同，原理也不同，如ReentrantLock内部是通过AQS来获取和释放锁的。</p>
</li>
<li><p>是否可以设置公平&#x2F;非公平</p>
<p>ReentrantLock可以根据需求来设置公平或非公平，synchronized则不能设置。</p>
</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li>最好既不使用Lock也不使用synchronized，尽量使用java.util.concurrent包中的机制。</li>
<li>尽量使用synchronized，避免忘记在finally里忘记unlock。</li>
<li>需要Lock的特殊功能时，如尝试获取锁、可中断、超时功能等，才使用Lock。</li>
</ol>
</li>
</ul>
<h4 id="3-5-Lock的常用方法"><a href="#3-5-Lock的常用方法" class="headerlink" title="3.5 Lock的常用方法"></a>3.5 Lock的常用方法</h4><ul>
<li><p>lock()</p>
<p>在线程获取锁时如果锁已被其他线程获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//获取到了被本锁保护的资源，处理任务</span></span><br><span class="line">    <span class="comment">//捕获异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock()</p>
<p>用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回true，否则返回false，代表获取锁失败，可以根据是否能获取到锁来决定后续程序行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock(long time, TimeUnit unit)</p>
<p>和tryLock()类似，tryLock(long time, TimeUnit unit)会有一个超时时间，在拿不到锁时会等待一定的时间，时间期限结束后，还获取不到锁，就会返回false，如果在最开始或等待期间内获取到锁就返回true。</p>
</li>
<li><p>lockInterruptibly()</p>
<p>除非当前线程在获取锁期间被中断，否则会一直尝试获取直到获取到为止。相当于超时时间无限长的tryLock(long time, TimeUnit unit)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              lock.lockInterruptibly();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;操作资源&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unlock()</p>
<p>用于解锁，对ReentrantLock而言，执行unlock()的时候，内部会把锁的”被持有计数器”减1，直到减到0就代表当前这把锁已经完全释放了，如果减1后计数器不为0，说明这把锁之前被”重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。</p>
</li>
</ul>
<h4 id="3-6-公平锁与非公平锁"><a href="#3-6-公平锁与非公平锁" class="headerlink" title="3.6 公平锁与非公平锁"></a>3.6 公平锁与非公平锁</h4><p>公平锁：按照线程请求顺序来分配锁</p>
<p>非公平锁：不完全按照请求的顺序，在一定情况下，可以允许插队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairAndUnfair</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintQueue</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">queueLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);<span class="comment">//false:非公平锁 true:公平锁 默认false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printJob</span><span class="params">(Object document)</span> &#123;</span><br><span class="line">            queueLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">duration</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">10000</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s: PrintQueue: Printing a Job during %d seconds\n&quot;</span>,</span><br><span class="line">                    Thread.currentThread().getName(), (duration / <span class="number">1000</span>));</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                queueLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queueLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">duration</span> <span class="operator">=</span> (<span class="type">long</span>)(Math.random() * <span class="number">10000</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s: PrintQueue: Printing a Job during %d seconds\n&quot;</span>,</span><br><span class="line">                    Thread.currentThread().getName(), (duration / <span class="number">1000</span>));</span><br><span class="line">                Thread.sleep(duration);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                queueLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Job</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Job</span><span class="params">(PrintQueue printQueue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.printQueue = printQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s: Going to print a job\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            printQueue.printJob(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s: The document has been printed\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintQueue</span> <span class="variable">printQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintQueue</span>();</span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Job</span>(printQueue), <span class="string">&quot;Thread &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平情况下，存在抢锁”插队”现象，如Thread 0 在释放锁后又能优先获取到锁，虽然此时在等待队列中已经有Thread 1~Thread 9在排队了。</p>
<p><strong>各自的优缺点</strong></p>
<p><img data-src="/../../../../assets/img/CgpOIF4Jsh6AbVZ-AAB_Y_MH7f4077.png"></p>
<p><strong>源码分析</strong></p>
<p>ReentrantLock中包含一个Sync类，这个类继承自AQS(AbstractQueuedSynchronizer)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure>

<p>Sync有公平锁FairSync和非公平锁NonfairSync两个子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁与非公平获取锁的lock()方法唯一区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors()为false，这个方法就是在判断在等待队列中是否已经有线程在排队了。公平锁，一旦有线程在排队，当前线程就不再尝试获取锁了；对于非公平锁，无论是否有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。</p>
<p>tryLock()，一旦有线程释放了锁，那么正在tryLock的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，即tryLock可以插队。调用的是nonfairTryAcquire()，表明是不公平的，和锁本身是否公平锁无关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-读写锁"><a href="#3-7-读写锁" class="headerlink" title="3.7 读写锁"></a>3.7 读写锁</h4><p>保证多个线程同时读的效率，同时可以保证有写入操作时的线程安全。</p>
<p><strong>读写锁的获取规则</strong></p>
<ol>
<li>如果一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为<strong>读写不能同时操作</strong>。</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或读锁，都必须等待之前的线程释放锁，因为<strong>读写、写写不能同时操作</strong>。</li>
</ol>
<p>要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。即读读共享，其他都互斥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;得到读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;得到写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; read()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; read()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; write()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; write()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Thread</span>-<span class="number">0</span>得到读锁，正在读取</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">1</span>得到读锁，正在读取</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">0</span>释放读锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">1</span>释放读锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">2</span>得到写锁，正在写入</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">2</span>释放写锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">3</span>得到写锁，正在写入</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">3</span>释放写锁</span><br></pre></td></tr></table></figure>

<p>读写锁适用于读多写少的情况</p>
<h4 id="3-8-读锁应该插队么？什么是读写锁的升降级？"><a href="#3-8-读锁应该插队么？什么是读写锁的升降级？" class="headerlink" title="3.8 读锁应该插队么？什么是读写锁的升降级？"></a>3.8 读锁应该插队么？什么是读写锁的升降级？</h4><ul>
<li><p>公平锁</p>
<p>只要等待队列中有线程在等待，即hasQueueedPredecessors()返回true的时候，那么write和reader都会block，即不允许插队。</p>
</li>
<li><p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁：随时可以插队</p>
<p>读锁：</p>
<ol>
<li><p>允许插队</p>
<p><img data-src="/../../../../assets/img/Cgq2xl4O9F2AR8XVAACUtGWSKRc535.png"></p>
<p>有可能导致需要拿到写锁的线程会陷入”饥饿”状态，它将在长时间内得不到执行。</p>
</li>
<li><p>不允许插队</p>
<p>即使是非公平锁，只要<strong>等待队列的头结点是尝试获取写锁的线程，那么读锁依然不能插队</strong>，目的是避免”饥饿”。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadLockJumpQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;得到读锁，正在读取&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放读锁&quot;</span>);</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;得到写锁，正在写入&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放写锁&quot;</span>);</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; read(), <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; read(), <span class="string">&quot;Thread-4&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; write(), <span class="string">&quot;Thread-3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; read(), <span class="string">&quot;Thread-5&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Thread</span>-<span class="number">2</span>得到读锁，正在读取</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">4</span>得到读锁，正在读取</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">2</span>释放读锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">4</span>释放读锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">3</span>得到写锁，正在写入</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">3</span>释放写锁</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">5</span>得到读锁，正在读取</span><br><span class="line"><span class="attribute">Thread</span>-<span class="number">5</span>释放读锁</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>锁的升降级</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">//在获取写锁之前，必须首先释放读锁。</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里需要再次判断数据的有效性,因为在我们释放读锁和获取写锁的空隙之内，可能有其他线程修改了数据。</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在不释放写锁的情况下，直接获取读锁，这就是读写锁的降级。</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放了写锁，但是依然持有读锁</span></span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一处修改数据的代码，后面都是读取，如果一直使用写锁的话，就不能让多个线程同时来读取了，这个时候利用锁的降级，可以提高整体性能。</p>
<p><strong>支持锁的降级，不支持升级</strong></p>
<p>ReentrantReadWriteLock不支持读锁升级到写锁。</p>
<p>不可能有读锁和写锁同时持有的情况，升级写锁的过程中，需要等到所有的读锁都释放才能升级。另一种特殊情况，线程A、B都想升级到写锁，对于A而言，它需要等待其他线程(包括B)释放读锁，而线程B也是如此，则会发生死锁。</p>
<h4 id="3-9-自旋锁"><a href="#3-9-自旋锁" class="headerlink" title="3.9 自旋锁"></a>3.9 自旋锁</h4><p><img data-src="/../../../../assets/img/Cgq2xl4S44OAXtbZAAG7wulxruI786.png"></p>
<p>非自旋锁和自旋锁最大的区别，如果它遇到拿不到锁的情况，它会把线程阻塞，直到被唤醒；而自旋锁会不停地尝试。</p>
<p><strong>自旋锁的好处</strong></p>
<p>自旋锁用循环去不停地尝试获取锁，让线程始终处于Runnable状态，节省了线程切换带来的开销。</p>
<p>自己实现可重入的自旋锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 重入次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (currentThread == owner.get()) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;自旋了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能解锁</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread == owner.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此处无需CAS操作，因为没有竞争，因为只有线程持有者才能解锁</span></span><br><span class="line">                owner.set(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantSpinLock</span> <span class="variable">spinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantSpinLock</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始尝试获取自旋锁&quot;</span>);</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了自旋锁&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放了了自旋锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>开始尝试获取自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>开始尝试获取自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>获取到了自旋锁</span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line"><span class="params">...</span><span class="params">...</span></span><br><span class="line">自旋了！</span><br><span class="line">自旋了！</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>获取到了自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span>释放了了自旋锁</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span>释放了了自旋锁</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong></p>
<p>虽然避免了线程切换的开销，但带来了新的开销，因为它需要不停地去尝试获取锁。</p>
<p><strong>适用场景</strong></p>
<p>自旋锁适用于并发度不是特别高，以及临界区比较短小的情况，这样可以避免线程切换来提高效率。可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不适合自旋锁，因为自旋会一直占用CPU却无法拿到锁，白白消耗资源。</p>
<h4 id="3-10-JVM对锁的优化"><a href="#3-10-JVM对锁的优化" class="headerlink" title="3.10 JVM对锁的优化"></a>3.10 JVM对锁的优化</h4><ul>
<li><p>自适应的自旋锁</p>
<p>自旋的缺点在于如果自旋时间过长，那么性能开销很大，浪费CPU资源。自适应意味着自旋的时间不再固定，而是根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。如：最近尝试自旋获取某一把锁成功了，那么下次可能还会继续使用自旋，并且允许自旋更长时间；但如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。</p>
</li>
<li><p>锁消除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是被synchronized修饰的同步方法，因为它可能会被多个线程同时使用。但在大多数情况下，它只会在一个线程内使用，如果编译器能确定这个StringBuffer只会在一个线程内使用，那么编译器便会做出优化，把synchronized消除，省去加锁和解锁，以便增加整体的效率。</p>
</li>
<li><p>锁粗化</p>
<p>如果释放了锁，紧接着什么都没做，又重新获取锁，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockCoarsening</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把同步区域扩大，即最开始加一次锁，并且在最后直接解锁，减少性能开销。</p>
<p>如果在循环中也这样做，会导致其他线程长时间无法获得锁。锁粗化的功能默认打开，用-XX:-EliminateLocks可以关闭该功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</p>
<p>这三种锁是特指synchronized锁的状态的，通过对象头中的mark word来表明锁的状态。</p>
<ul>
<li><p>偏向锁</p>
<p>这把锁自始至终不存在竞争，那么没必要上锁，只要打个标记就行了。一个对象被初始化后，如果还没有任何线程来获取它的锁，它就是可偏向的，当第一个线程来访问它尝试获取锁的时候，它就记录下来这个线程，如果后面尝试获取锁的线程正是这个偏向锁的拥有者，就可以直接获取锁，开销小。</p>
</li>
<li><p>轻量级锁</p>
<p>synchronized中的代码块是被多个线程交替执行的，也就是不存在实际的竞争，或者只有短时间的竞争，用CAS就可以解决。轻量级锁指当锁原来是偏向锁的时候，被另一线程所访问，说明存在竞争，那么偏向锁升级为轻量级锁，线程会通过自旋的方式尝试获取锁，不会阻塞。</p>
</li>
<li><p>重量级锁</p>
<p>当多个线程直接有实际竞争，并且锁竞争时间比较长的时候，此时偏向锁和轻量级锁都不能满足需求，锁就会膨胀为重量级锁，会让其他申请却拿不到锁的线程进入阻塞状态。</p>
</li>
</ul>
<p><img data-src="/../../../../assets/img/CgpOIF4VUHSAFpAZAAANfyy0aXE323.png"></p>
</li>
</ul>
<h4 id="3-10-HashMap为什么是线程不安全的？"><a href="#3-10-HashMap为什么是线程不安全的？" class="headerlink" title="3.10 HashMap为什么是线程不安全的？"></a>3.10 HashMap为什么是线程不安全的？</h4><ul>
<li><p>扩容期间取出的值不准确</p>
<p>HashMap扩容期间，会新建一个新的空数组，并用旧的项填充到这个新的数组中。如果这个填充的过程中，如果有线程取值，很可能会取到null值。</p>
</li>
<li><p>同时put碰撞导致数据丢失</p>
<p>如果有多个线程同时put，而且恰好两个put的key是一样的，它们发生了碰撞，也就是根据hash值计算出来的bucket位置一样，并且两个线程又同时判断该位置是空的，可以写入，所以这两个线程的两个不同的value便会添加到数组的同一位置，就丢失了一个数据。</p>
</li>
<li><p>可见性问题</p>
<p>线程1给某个key放入了一个新值，那么线程2在获取对应的key的值的时候，它的可见性是无法保证的。</p>
</li>
<li><p>死循环造成CPU100%</p>
<p>在扩容的时候，也就是内部新建新的HashMap的时候，扩容的逻辑会反转散列桶中的节点顺序，当多个线程同时进行扩容的时候，如果两个线程同时反转的话，便可能形成一个循环，并且这种循环是链表的循环，相当于A节点指向B节点，B节点又指回A节点，在下一次想要获取该key所对应的value的时候，便会在遍历链表的时候发生永远无法遍历结束的情况。</p>
</li>
</ul>
<h4 id="3-11-为什么Map桶中超过8个才转为红黑树？"><a href="#3-11-为什么Map桶中超过8个才转为红黑树？" class="headerlink" title="3.11 为什么Map桶中超过8个才转为红黑树？"></a>3.11 为什么Map桶中超过8个才转为红黑树？</h4><p>最开始的Map是空的，因为里面没有任何元素，往里放元素时会计算hash值，计算之后，第1个个value会占用一个桶(也称为槽点)位置，后续经过计算键值key计算hash值得到插入的数组索引i相同，那么会使用链表的形式往后延长，俗称拉链法。当链表长度大于或等于阈值(默认为8)，且数组长度大于或等于MIN_TREEIFY_CAPACITY(默认64)时，就会把链表转为红黑树。当红黑树的节点小于或等于6个以后，又会恢复为链表形态。</p>
<p><img data-src="/../../../../assets/img/CgpOIF4ejCmAPqZMAAGZw5NzqtE067.png"></p>
<ol>
<li><p>链表查找时间复杂度：O(n)	红黑树查找时间复杂度：O(log(n))</p>
</li>
<li><p>单个TreeNode需要占用的空间大约是Node的两倍</p>
<p><strong>时间与空间的平衡</strong></p>
</li>
</ol>
<p>如果hash计算结果离散的好，各个值都均匀分配，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为8时，概率仅为0.00000006，小于千万分之一概率，通常情况下并不会发生链表向红黑树的转换。</p>
<p>链表长度为8转为红黑树的设计，为了防止自定义实现了不好的hash算法导致链表长度过长，从而导致查询效率低。</p>
<h4 id="3-12-Hashtable与ConcurrentHashMap的区别"><a href="#3-12-Hashtable与ConcurrentHashMap的区别" class="headerlink" title="3.12 Hashtable与ConcurrentHashMap的区别"></a>3.12 Hashtable与ConcurrentHashMap的区别</h4><ol>
<li><p>出现版本不同</p>
<p>Hashtable在JDK1.0就存在了，并在JDK1.2实现了Map接口；ConcurrentHashMap在JDK1.5中才出现。</p>
</li>
<li><p>实现线程安全的方式不同</p>
<p>Hashtable通过<strong>synchronized</strong>关键字实现线程安全；ConcurrentHashMap利用了**CAS+synchronized+Node(volatile)**。</p>
</li>
<li><p>性能不同</p>
<p>随着线程数量的增加，Hashtable性能会急剧下降，每一次修改会锁住整个对象，而其他线程在此期间不能操作，还会带来额外的上下文切换；ConcurrentHashMap只会对一部分上锁而不是全部都上锁。</p>
</li>
<li><p>迭代时的修改不同</p>
<p><strong>Hashtable(包括HashMap)不允许在迭代期间修改内容</strong>，否则会抛出ConcurrentModificationException异常，ConcurrentHashMap不会。</p>
</li>
</ol>
<h4 id="3-13-CopyOnWriteArrayList"><a href="#3-13-CopyOnWriteArrayList" class="headerlink" title="3.13 CopyOnWriteArrayList"></a>3.13 CopyOnWriteArrayList</h4><p>ArrayList	LinkedList</p>
<p>线程安全：Vector	Collections.synchronized()</p>
<p><strong>Vector内部使用synchronized来保证线程安全</strong>，并且锁的粒度比较大，都是方法级别的锁，在并发高的时候，很容易发生竞争，并发效率相对较低。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>读操作可以尽可能的快，而写即使慢一些也没关系</li>
<li>读多写少</li>
</ul>
<p><strong>读写规则：</strong></p>
<p>读写锁的思想是：读读共享，其他都互斥，因为读操作不会修改原有的数据，因此并发读不会有安全问题；而写操作发生时，不允许读和写操作加入。CopyOnWriteArrayList读取是完全不用加锁的，并且写入也不会阻塞读取操作，也就是说可以在写入的同时进行读取，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但可以在写入时允许读取发生。</p>
<p> <strong>特点：</strong></p>
<ul>
<li><p>CopyOnWrite</p>
<p>当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行Copy，复制出一个新容器，然后修改新的容器，完成修改之后，再将容器的引用指向新的容器。读写分离的思想，读和写使用不同的容器。</p>
</li>
<li><p>迭代期间允许修改集合内容</p>
<p>ArrayList源码里的ListItr的next()方法中有一个checkForComodification()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modCount是保存修改次数，每次调用add、remove时都会增加，expectedComodification是迭代器的变量，创建迭代器时会初始化并记录当时的modCount，后面迭代期间如果发现modCount和expectedModCount不一致，就会抛出异常。CopyOnWriteArrayList的迭代器在迭代时，迭代器使用的依然是原数组，只不过迭代器的内容可能已经过时了。CopyOnWrite的迭代器一旦被建立，如果往之前的CopyOnWriteArrayList对象中去新增元素，在迭代器中既不会显示出元素的变更情况，同时也不会报错。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>内存占用问题</p>
</li>
<li><p>在元素较多或者复杂的情况下，复制的开销很大</p>
</li>
<li><p>数据一致性问题</p>
<p>由于CopyOnWrite容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。</p>
</li>
</ul>
<p><strong>源码分析：</strong></p>
<ul>
<li><p>数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 可重入锁对象 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">/** CopyOnWriteArrayList底层由数组实现，volatile修饰，保证数组的可见性 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 得到数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化CopyOnWriteArrayList相当于初始化数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>add()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到原数组的长度和元素</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">       <span class="comment">// 复制出一个新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加时，将新元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将volatile Object[] array 的指向替换成新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加的时候首先上锁，并复制一个新数组，增加操作在新数组上完成，然后将array指向到新数组，最后解锁。上面的步骤实现了CopyOnWrite的思想：<strong>写操作是在原来容器的拷贝上进行的，并且在读取数据的时候不会锁住list。如果对容器拷贝操作的过程中有新的读线程进来，那么读到的还是旧的数据，因为那个时候对象的引用还没有被更改。</strong></p>
</li>
<li><p><strong>迭代器 COWIterator 类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>snapshot：数组的快照，即创建迭代器那个时刻的数组情况</p>
<p>cursor：迭代器的游标</p>
<p>迭代器在被构建的时候，会把当时的elements赋值给snapshot，而之后的迭代器所有的操作都基于snapshot数组进行的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，返回的内容是snapshot对象，所以，后续就算原数组被修改，这样snapshot既不会感知到，也不会受影响，<strong>执行迭代操作不需要加锁，也不会因此抛出异常。迭代器返回的结果，和创建迭代器的时候内容一致。</strong></p>
</li>
</ul>
<h3 id="4-阻塞队列"><a href="#4-阻塞队列" class="headerlink" title="4.阻塞队列"></a>4.阻塞队列</h3><h4 id="4-1-什么是阻塞队列？"><a href="#4-1-什么是阻塞队列？" class="headerlink" title="4.1 什么是阻塞队列？"></a>4.1 什么是阻塞队列？</h4><p>BlockingQueue，是一个接口，继承了Queue接口，是队列的一种，是线程安全的。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl4le8SAYKHDAABbO_HZa9c237.png"></p>
<p><strong>主要并发队列关系图</strong></p>
<p><img data-src="/../../../../assets/img/Cgq2xl4le9SAL6enAAGpXZi8Wcg079.jpg"></p>
<p><strong>阻塞队列</strong>典型代表就是BlockingQueue接口的实现类，分别是ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、DelayQueue、PriorityBlockingQueue和LinkedTransferQueue。<strong>非阻塞队列</strong>的典型代表是ConcurrentLinkedQueue，这个类不会让线程阻塞，利用CAS保证线程安全。</p>
<p>Deque为双端队列，它从头和尾都能添加和删除元素；而普通的Queue只能从一端进入，另一端出去。</p>
<p><strong>特点</strong></p>
<p>阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。</p>
<ul>
<li><p>take方法</p>
<p>获取并移除队列的头结点，在队列里有数据时可以正常移除，一旦执行take方法的时候，队列无数据，则阻塞，直到队列有数据。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl4le_eAafhbAABp-t8dt_8312.png"></p>
</li>
<li><p>put方法</p>
<p>put方法插入元素时，如果队列已满，那么就无法继续插入，则阻塞，直到队列有了空闲空间。</p>
<p><img data-src="/../../../../assets/img/CgpOIF4lfAyAC4zxAAB1UtAAltk817.png"></p>
</li>
</ul>
<h5 id="是否有界-容量有多大"><a href="#是否有界-容量有多大" class="headerlink" title="是否有界(容量有多大)"></a>是否有界(容量有多大)</h5><p>无界队列意味着里面可以容纳非常多的元素，如LinkedBlockingQueue的上限是Integer.MAX_VALUE，约为2^31。有些阻塞队列是有界的，如ArrayBlockingQueue如果容量满了，也不会扩容，所以一旦满了，就无法再往里面放数据了。</p>
<h4 id="4-2-阻塞队列常用方法"><a href="#4-2-阻塞队列常用方法" class="headerlink" title="4.2 阻塞队列常用方法"></a>4.2 阻塞队列常用方法</h4><p>第一组：无法正常执行的情况下抛出异常；第二组：在无法正常执行的情况下不抛出异常，但会用返回值提示运行失败；第三组：在遇到特殊情况时让线程阻塞，等到可以运行再继续执行。</p>
<p><img data-src="/../../../../assets/img/CgpOIF4lheGALDjnAAHFyzrSvqU109.png"></p>
<p><strong>带有超时时间的offer和poll</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offer(E e, <span class="type">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>插入不成功时会等待指定的超时时间，时间到了依然没有插入成功，就会返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poll(<span class="type">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>如果移除时，如果队列是空的就会进行等待，超时时间到了，如果队列中依然没有元素可供移除，则会返回null为提示</p>
<h4 id="4-3-几种常见的阻塞队列"><a href="#4-3-几种常见的阻塞队列" class="headerlink" title="4.3 几种常见的阻塞队列"></a>4.3 几种常见的阻塞队列</h4><ul>
<li><p>ArrayBlockingQueue</p>
<p><strong>有界队列</strong>，其内部是用数组存储元素的，利用ReentrantLock实现线程安全，在创建它的时候就需要指定它的容量，之后不可以再扩容了，可以在构造函数中指定是否公平。</p>
<p>非公平：存在插队的可能；公平：等待最长时间的线程会被优先处理</p>
</li>
<li><p>LinkedBlockingQueue</p>
<p>内部用链表实现，不指定容量时默认为Integer.MAX_VALUE，被称为无界队列。</p>
</li>
<li><p>SynchronousQueue</p>
<p><img data-src="/../../../../assets/img/Cgq2xl4lhhSAZIuZAABMMZW2RVk163.png"></p>
<p>容量为0，所以没有地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据也会阻塞，直到有消费者来取。Synchronous的容量不是1而是0，它不需要去持有元素，它所做的就是直接传递。</p>
</li>
<li><p>PriorityBlockingQueue</p>
<p>支持优先级的无界阻塞队列，可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。同时插入的对象必须是可比较大小的，即Comparable的，否则会抛出ClassCastException。</p>
</li>
<li><p>DelayQueue</p>
<p>具有”延迟”的功能，可以设定让队列中的任务延迟多久之后执行，如”30 分钟后未付款自动取消订单”。它是无界队列，放入的元素必须实现Delayed接口，而Delayed接口又继承了Comparable接口，拥有了比较和排序的能力。元素会根据延迟时间的长短放到队列的不同位置，越靠近头队列代表越早过期。</p>
</li>
</ul>
<h4 id="4-4-阻塞队列和非阻塞队列的并发安全原理"><a href="#4-4-阻塞队列和非阻塞队列的并发安全原理" class="headerlink" title="4.4 阻塞队列和非阻塞队列的并发安全原理"></a>4.4 阻塞队列和非阻塞队列的并发安全原理</h4><ul>
<li><p>ArrayBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="type">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="type">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下3个是控制并发用的工具</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<p>这三个变量非常关键，第一个是ReentrantLock，下面两个Condition是由ReentrantLock产生出来的。读操作和写操作都需要先获取到ReentrantLock独占锁才能进行下一步操作。进行读操作时如果队列为空，线程就会进入到读线程专属的noEmpty的Condition的队列中去排队，等待写线程写入新的元素；同理如果队列已满，写操作的线程会进入到写线程专属的notFull队列中去排队，等待读线程将队列元素移除并腾出空间。</p>
<p>put方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedBlockingQueue的内部有两把锁，分别锁住队列的头和尾，比共用一把锁的效率高。</p>
</li>
<li><p>非阻塞队列ConcurrentLinkedQueue</p>
<p>offer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个是以一个大的for循环，p.casNext()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里运用了UNSAFE.compareAndSwapObject方法来完成CAS操作，而compareAndSwapObject是一个native方法，最终会利用CPU的CAS指令保证其不可中断。非阻塞队列ConcurrentLinkedQueue使用CAS非阻塞算法+不停重试，来实现线程安全，适合用在不需要阻塞功能，且并发不是特别剧烈的场景。</p>
</li>
</ul>
<h4 id="4-5-如何选择合适的阻塞队列？"><a href="#4-5-如何选择合适的阻塞队列？" class="headerlink" title="4.5 如何选择合适的阻塞队列？"></a>4.5 如何选择合适的阻塞队列？</h4><ul>
<li><p>线程池对于阻塞队列的选择</p>
<p><img data-src="/../../../../assets/img/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png"></p>
</li>
</ul>
<p>从以下5个角度考虑，来选择合适的阻塞队列。</p>
<ul>
<li><p>功能</p>
<p>是否需要阻塞队列来排序，如优先级排序、优先执行等。</p>
</li>
<li><p>容量</p>
<p>是否需要有存储要求，还是只需要”直接传递”。</p>
</li>
<li><p>能否扩容</p>
<p>业务可能有高峰期、低谷期，如果需要动态扩容，就不能选择ArrayBlockingQueue。</p>
</li>
<li><p>内存结构</p>
<p>如ArrayBlockingQueue的内部结构是”数组”的形式，LinkedBlockingQueue的内部是链表实现的，ArrayBlockingQueue没有链表所需要的”节点”，空间链表利用率更高。</p>
</li>
<li><p>性能</p>
<p>如LinkedBlockingQueue拥有两把锁，操作粒度更细，并发程度高的时候，相对于只有一把锁的ArrayBlockingQueue性能会更好。SynchronousQueue性能往往优于其他实现，因为它只需要”直接传递”，而不需要存储的过程。</p>
</li>
</ul>
<h3 id="5-原子类"><a href="#5-原子类" class="headerlink" title="5.原子类"></a>5.原子类</h3><h4 id="5-1-原子类如何利用CAS保证线程安全？"><a href="#5-1-原子类如何利用CAS保证线程安全？" class="headerlink" title="5.1 原子类如何利用CAS保证线程安全？"></a>5.1 原子类如何利用CAS保证线程安全？</h4><p>原子类的作用和锁有类似之处，都是为了保证并发情况下线程安全。</p>
<ul>
<li>粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。</li>
<li>效率更高：除高度竞争的情况下，原子类的效率通常比使用同步互斥锁的效率更高，因为原子类利用了CAS操作，不会阻塞线程。</li>
</ul>
<p><strong>6类原子类纵览</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>具体类</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Atomic* 基本类型原子类</td>
<td>AtomicInteger、AtomicLong、AtomicBoolean</td>
<td></td>
</tr>
<tr>
<td>Atomic*Array 数组类型原子类</td>
<td>AtomicIntegerArray(整形数组原子类)、AtomicLongArray(长整形数组原子类)、AtomicReferenceArray(引用类型数组原子类)</td>
<td></td>
</tr>
<tr>
<td>Atomic*Reference 引用类型原子类</td>
<td>AtomicReference、AtomicStampedReference(对AtomicReference的升级，在此基础上还加了时间戳，用于解决CAS的ABA问题)、AtomicMarkableReference(和AtomicReference类似，多了一个绑定的布尔值，可以用于表示该对象已删除等场景)</td>
<td>AtomicInteger可以让一个整数保证原子形，AtomicReference可以让一个对象保证原子性。</td>
</tr>
<tr>
<td>Atomic*FieldUpdater升级类型原子类</td>
<td>AtomicIntegerFieldUpdater(原子更新整形的更新器)、AtomicLongFieldUpdater(原子更新长整形的更新器)、AtomicReferenceFieldUpdater(原子更新引用的更新器)</td>
<td>可以把已经声明的变量进行升级，使其拥有CAS操作的能力。</td>
</tr>
<tr>
<td>Adder累加器</td>
<td>LongAdder、DoubleAdder</td>
<td></td>
</tr>
<tr>
<td>Accumulator积累器</td>
<td>LongAccumulator、DoubleAccumulator</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Score math;</span><br><span class="line">    <span class="keyword">static</span> Score computer;</span><br><span class="line">    <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Score&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Score.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            computer.score++;</span><br><span class="line">            scoreUpdater.getAndIncrement(math);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        math = <span class="keyword">new</span> <span class="title class_">Score</span>();</span><br><span class="line">        computer = <span class="keyword">new</span> <span class="title class_">Score</span>();</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdaterDemo</span> <span class="variable">updaterDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(updaterDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(updaterDemo);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通变量的结果：&quot;</span>+ computer.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;升级后的结果：&quot;</span>+ math.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以AtomicInteger为例，分析其如何利用CAS实现原子操作？</strong></p>
<ul>
<li><p>getAndAdd()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 1.8实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Unsafe类</strong></p>
<p>Unsafe类是CAS的核心类。Java无法直接访问底层操作系统，而需要通过native方法实现。在JDK中有一个Unsafe类，提供了硬件级别的原子操作，可以利用它直接操作内存数据。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">   <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           valueOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;<span class="keyword">return</span> value;&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static代码块会在类加载的时候执行，执行时会调用Unsafe的objectFieldOffset方法，从而得到当前这个原子类的value的偏移量(在内存中的偏移地址)，并且赋给valueOffset变量，并且赋值给valueOffset变量，Unsafe根据内存偏移地址获取数据的原值，这样就可以通过Unsafe来实现CAS了。</p>
<p>value是用volatile修饰的，它就是我们原子类存储的值的变量，由于它被volatile修饰，我们就可以保证在多线程之间看到的value是同一份，保证了可见性。</p>
<p>Unsafe的getAndAddInt方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">   <span class="type">int</span> var5;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);<span class="comment">//获取var1中的var2偏移处的值 var1:当前原子类 var2:最开始获取到的offset</span></span><br><span class="line">   &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="comment">//var1:object 当前原子类对象 var2:offset 即偏移量，借助它就可以获取到value的数值 var3:expectedValue 代表&quot;期望值&quot;，传入的是刚才获取到的var5 var5+var4:newValue 是希望修改的数值，等于之前取到的数值var5+var4，var4是希望原子类所改变的数值，如+1或-1。</span></span><br><span class="line">   <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSwapInt方法的作用：判断如果现在原子类里的value的值和之前获取到的var5相等的话，那么就把计算出来的var5+var4给更新上去。一旦CAS操作成功，就会退出这个while循环，但也有可能操作失败。如果操作失败就意味着在获取到var之后，并在CAS操作之前，value的数值已经发生变化了，证明有其他线程修改过这个变量。会再次执行循环体里面的代码，重新获取var5，即获取最新的原子变量的数值，并再次利用CAS尝试更新，直到更新成功。</p>
</li>
</ul>
<h4 id="5-2-AtomicInteger在高并发下性能不好，如何解决？为什么？"><a href="#5-2-AtomicInteger在高并发下性能不好，如何解决？为什么？" class="headerlink" title="5.2 AtomicInteger在高并发下性能不好，如何解决？为什么？"></a>5.2 AtomicInteger在高并发下性能不好，如何解决？为什么？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicLongDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(AtomicLong counter)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.counter = counter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            counter.incrementAndGet();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...&quot;</span>+counter.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            poolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(counter));</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+counter.get());</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/../../../../assets/img/Cgq2xl46RpiAC7t7AAAa3NLU-Uk716.png"></p>
<p>每一个线程是运行在自己的core中的，并且它们都有一个本地内存是自己独用的。在本地内存下方有两个CPU核心共用的共享内存。对于AtomicLong内部的value属性而言，它是被volatile修饰的，需要保证自身可见性。每次它的数值变化的时候，都需要进行flush到共享内存和refresh到本地内存。</p>
<p>flush和refresh操作耗费了很多资源，而且CAS也会经常失败。</p>
<p><strong>LongAdder</strong></p>
<p>LongAdder引入了分段累加的概念，内部一共有两个参数参与计数：</p>
<ol>
<li>base，是一个变量，用在竞争不激烈的情况下，可以直接把来家结果改到base变量上。</li>
<li>Cell[]，是一个数组，一旦竞争激烈，各个线程会分散累加到自己所对应的那个Cell[]数组的某一个对象中，而大家不会共用同一个。</li>
</ol>
<p>竞争激烈的时候，LongAdder会通过计算出每个线程的hash值来给线程分配到不同的Cell上去，每个Cell相当于是一个独立的计数器，Cell之间并不存在竞争，所以自加过程中，大大减少了flush和refresh，以及降低了冲突的概率。空间换时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">   Cell[] as = cells; Cell a;</span><br><span class="line">   <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">   <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">               sum += a.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何选择</strong></p>
<p>如何仅仅是需要用到加和减操作的场景，那么可以直接使用LongAdder。</p>
<p>如果需要利用CAS比如compareAndSet等操作的话，就需要使用AtomicLong来完成。</p>
<h4 id="5-3-原子类与volatile"><a href="#5-3-原子类与volatile" class="headerlink" title="5.3 原子类与volatile"></a>5.3 原子类与volatile</h4><p><img data-src="/../../../../assets/img/Cgq2xl49B9GAHIQWAABs3zG_-08605.png"></p>
<p>线程1和线程2分别在不同的CPU核心，每一个核心都有自己的本地内存，并且在下方也有它们的共享内存。在变量加上volatile关键字，线程1的更改会被flush到共享内存，然后又被refresh到线程2的本地内存，保证了可见性。</p>
<p>但对于value++这种，即使用volatile修饰value也是不能保证线程安全的，无法保证其原子性。此时可以使用原子类。</p>
<p><strong>原子类和volatile的使用场景</strong></p>
<p>通常情况下，volatile可以用来修饰boolean类型的标记位，对于标记位来讲，直接的赋值操作本身就具有原子性，再加上volatile保证了可见性，那么就是线程安全的了。而对于会被多个线程同时操作的计数器counter的场景，即不仅仅是赋值操作，还需要读取当前值，然后在此基础上进行一定的修改，再把它给赋值回去，此时需要使用原子类保证线程安全。</p>
<h4 id="5-4-Adder与Accumlator的区别"><a href="#5-4-Adder与Accumlator的区别" class="headerlink" title="5.4 Adder与Accumlator的区别"></a>5.4 Adder与Accumlator的区别</h4><p>高并发场景下AtomicLong CAS冲突概率大，会导致经常自旋。而LongAdder引入了分段锁的概念，竞争不激烈的时候，所有线程都是通过CAS对同一个Base变量进行修改，但竞争激烈的时候，LongAdder会把不同线程对应到不同的Cell上进行修改，降低了冲突的概率。</p>
<p>LongAccumulator就是个更通用版本的Adder，提供了自定义的函数操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAccumulatorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">accumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">8</span>, <span class="number">16</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(i-&gt;executorService.submit(()-&gt;&#123;</span><br><span class="line">            accumulator.accumulate(i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...&quot;</span>+accumulator.get());</span><br><span class="line">        &#125;));</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(accumulator.getThenReset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LongAccumulator</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);</span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x * y, <span class="number">0</span>);</span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">min</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; Math.min(x, y), <span class="number">0</span>);</span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; Math.max(x, y), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ol>
<li>需要大量的计算，并且当需要并行计算的时候。</li>
<li>计算的执行顺序并不关键。</li>
</ol>
<h3 id="6-ThreadLocal"><a href="#6-ThreadLocal" class="headerlink" title="6.ThreadLocal"></a>6.ThreadLocal</h3><h4 id="6-1-ThreadLocal适用场景"><a href="#6-1-ThreadLocal适用场景" class="headerlink" title="6.1 ThreadLocal适用场景"></a>6.1 ThreadLocal适用场景</h4><ol>
<li><p>场景1</p>
<p><strong>保存每个线程独享的对象</strong>，为每个线程都创建一个副本，这样每个线程都可以修改自己拥有的副本，而不会影响其他线程的副本，确保了线程安全。</p>
<p>这种场景下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量。因为每个线程独享副本，而不是共用的，所以不存在多线程间共享的问题。</p>
<p>这种场景通常用于保存线程不安全的工具类，如SimpleDateFormat。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; formatThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">16</span>, <span class="number">32</span>, <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="type">int</span> seconds)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span> * seconds);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> formatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">1000</span>).forEach(i -&gt; executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalDemo05</span>().date(i);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        &#125;));</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景2</p>
<p><strong>每个线程内需要独立保存信息，以便其他方法更方便的获取该信息的场景</strong>。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息之后，后续方法可以通过ThreadLocal直接获取到，避免了传参，类似于全局变量的概念。</p>
<p>每个线程内需要保存类似于全局变量的信息(列如拦截器中获取的用户信息)，可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享(因为不同线程获取到的用户信息不一样)。</p>
<p>例如，用ThreadLocal保存一些业务内容(用户权限信息)，这些信息在同一个线程内相同，但在不同的线程使用的业务内容是不相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service1</span>().service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">userContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        userContextHolder.holder.set(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service2</span>().service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2拿到用户名：&quot;</span> + user.getUsername());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service3</span>().service3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.holder.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service3拿到用户名：&quot;</span> + user.getUsername());</span><br><span class="line">        userContextHolder.holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-2-ThreadLocal是用来解决共享资源的多线程访问的问题吗？"><a href="#6-2-ThreadLocal是用来解决共享资源的多线程访问的问题吗？" class="headerlink" title="6.2 ThreadLocal是用来解决共享资源的多线程访问的问题吗？"></a>6.2 ThreadLocal是用来解决共享资源的多线程访问的问题吗？</h4><p>不是，虽然ThreadLocal是用于解决多线程情况下的线程安全问题，但其资源并不是共享的，而是每个线程独占的。</p>
<p>如果把放到ThreadLocal中的资源用static修饰，让它变为一个共享资源的话，那么即便使用ThreadLocal，同样有线程安全问题。</p>
<p><strong>ThreadLocal和synchronized是什么关系？</strong></p>
<ul>
<li>ThreadLocal是通过让每个线程独享自己的副本，避免了资源的竞争。</li>
<li>synchronized主要用于临界资源的分配，在同一时刻限制最多只有一个线程能够访问该资源</li>
</ul>
<p>相比于ThreadLocal而言，synchronized的效率会更低一些，但花费的内存也更少。但对于ThreadLocal而言，它还有不同的使用场景。比如避免传参。</p>
<h4 id="6-3-ThreadLocal的结构"><a href="#6-3-ThreadLocal的结构" class="headerlink" title="6.3 ThreadLocal的结构"></a>6.3 ThreadLocal的结构</h4><p><strong>Thread、ThreadLocal及ThreadLocalMap三者之间的关系</strong></p>
<p><img data-src="/../../../../assets/img/Cgq2xl5M5a6ADeCKAABC52ZxZCk238.png"></p>
<p>每个Thread对象中都持有一个ThreadLocalMap类型的成员变量，这个ThreadLocalMap自身类似一个Map，里面会有一个个key-value形式的，key就是ThreadLocal的引用，value就是希望ThreadLocal存储的内容。</p>
<p><strong>get方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取到当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取到当前线程内的ThreadLocalMap对象，每个线程内都有一个ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取ThreadLocalMap中的Entry对象并拿到value，每个线程内都有一个ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程内之前没创建过ThreadLocalMap，就创建</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getMap方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>set方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取到当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程内的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//第一个参数this：当前ThreadLocal的引用，key的类型则是ThreadLocal；第二个参数即为所传入的value</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocalMap类，即Thread.threadLocals</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ThreadLocalMap中会有一个Entry类型的数组，名字叫table。可以理解为一个map，其键值对为：</p>
<ul>
<li>键，当前的ThreadLocal</li>
<li>值，实际需要存储的变量，比如user用户对象或者simpleDateFormat对象</li>
</ul>
<p>HashMap在面对hash冲突的时候，采用的是拉链法，它会先把对象hash到一个对应的格子中，如果有冲突就用链表的形式往下链；但ThreadLocalMap采用的是线性探测法，如果发生冲突，并不会用链表的形式往下链，而是会继续寻找下一个空的格子。</p>
<h4 id="6-4-为何每次用完-ThreadLocal-都要调用-remove-？"><a href="#6-4-为何每次用完-ThreadLocal-都要调用-remove-？" class="headerlink" title="6.4 为何每次用完 ThreadLocal 都要调用 remove()？"></a>6.4 为何每次用完 ThreadLocal 都要调用 remove()？</h4><p>内存泄漏：当某一个对象不再有用的时候，占用的内存却不能被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry是extends WeakReference。弱引用的特点：如果这个对象只被弱引用关联，而没有任何强引用关联，那么这个对象就可以被回收，所以弱引用不会阻止GC。</p>
<p>但是这个Entry包含了一个对value的强引用。value&#x3D;v这行代码就代表了强引用的发生。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png"></p>
<p>Thread Ref → Current Thread → ThreadLocalMap → Entry → Value → 可能泄漏的value实例。</p>
<p>这条链路是随着线程的存在而一直存在，如果线程迟迟不会终止，那么当垃圾回收进行可达性分析的时候，这个value就是可达的，所以不会被回收。但与此同时可能已经完成了业务逻辑处理，不再需要这个value了，此时就发生了内存泄漏。</p>
<p>在执行ThreadLocal的set、remove、rehash等方法时，都会扫描key为null的Entry，如果发现某个Entry的key为null，则代表它所对应的value也没有作用了，所以就会把对应的value设置为null，这样，value对象就可以被正常回收了。但假设ThreadLocal已经不被使用了，那么实际上set、remove、rehash方法也不会被调用。</p>
<p><strong>如何避免内存泄漏</strong></p>
<p>调用 ThreadLocal 的 remove 方法。调用这个方法就可以删除对应的 value 对象，可以避免内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Future"><a href="#7-Future" class="headerlink" title="7.Future"></a>7.Future</h3><h4 id="7-1-Callable和Runnable的不同"><a href="#7-1-Callable和Runnable的不同" class="headerlink" title="7.1 Callable和Runnable的不同"></a>7.1 Callable和Runnable的不同</h4><ul>
<li><p>Runnable的不足</p>
<ol>
<li><p>不能返回一个返回值</p>
</li>
<li><p>不能抛出checked Exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunThrowException</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 普通方法内可以 throw 异常，并在方法签名上声明 throws</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">normalMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  run方法上无法声明 throws 异常，且run方法内无法 throw 出 checked Exception，除非使用try catch进行处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Runnable规定了run()方法的返回类型是void，而且没有声明抛出任何异常。所以，当实现并重写这个方法的时候，既不能改变返回值类型，也不能更改对于异常抛出的描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable接口</p>
<p>call方法已经声明了throws Exception，前面还有一个V泛型的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">     V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Callable和Runnable的不同之处</p>
<ol>
<li>方法名：Callable规定的执行方法是call()，而Runnable规定的执行方法是run()</li>
<li>返回值：Callable的任务执行后有返回值，而Runnable的任务执行后是没有返回值的</li>
<li>抛出异常：call()方法可抛出异常，而run方法是不能抛出检查异常的</li>
<li>和Callable配合使用的Future类，通过Future可以了解任务的执行情况，或者取消任务的执行，还可获取任务的执行结果等。</li>
</ol>
</li>
</ul>
<h4 id="7-2-Future的主要功能"><a href="#7-2-Future的主要功能" class="headerlink" title="7.2 Future的主要功能"></a>7.2 Future的主要功能</h4><p><strong>Future的作用</strong></p>
<p>比如当做一定较耗时的任务时，可以把任务放到子线程去执行，再通过Future去控制子线程执行的过程，最后获取到计算结果。通过异步的思想，提高程序的运行效率。</p>
<p><strong>Callable和Future的关系</strong></p>
<p>Callable接口相比于Runnable可以通过Future类的get方法返回结果。因此，Future类相当于一个存储器，它存储了Callable的call方法的任务结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get() 获取结果</p>
<p>获取任务执行的结果</p>
<ol>
<li>当执行get的时候，任务已经执行完毕了。可以立刻返回，获取到任务执行的结果。</li>
<li>任务还未开始或任务正在执行中，调用get时，都会把当前线程阻塞，直到任务完成再把结果返回回来。</li>
<li>任务执行过程中抛出异常，调用get时，就会抛出ExecutionException，且无论执行call方法时里面抛出的异常类型是什么，在执行get方法时所获得的异常都是ExecutionException。</li>
<li>任务被取消了，如果任务被取消，调用get方法时则会抛出CancellationException。</li>
<li>任务超时，调用带延迟参数的get方法之后，如果call方法在规定时间内仍没有完成任务，get方法则会抛出TimeoutException，代表超时了。</li>
</ol>
<p><img data-src="/../../../../assets/img/Cgq2xl5WX0OAUkXdAADovQH3upQ950.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *一个Future的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneFuture</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt()+Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isDone() 判断是否执行完毕</p>
<p>判断当前线程是否执行完毕，返回true代表已经执行完毕，返回false则代表还没完成。但这里如果返回true，并不代表这个任务是成功执行的，比如说任务执行到一半抛出了异常，仍然会返回true，所以isDone方法在返回true的时候，不代表这个任务是成功执行的，只代表它执行完毕了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetException</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Callable抛出异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(future.isDone());</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">java.util.concurrent.ExecutionException: java.lang.IllegalArgumentException: Callable抛出异常！</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这段代码的运行结果证明了：</p>
<ol>
<li>即便任务抛出异常，isDone方法依然会返回true。</li>
<li>虽然call方法抛出的异常是IllegalArgumentException，但对于get而言，它抛出的异常依然是ExecutionException。</li>
<li>虽然在任务执行一开始就抛出了异常，但真正要等到执行get的时候，才看到了异常。</li>
</ol>
</li>
<li><p>cancel 取消任务的执行</p>
<ol>
<li>任务还未执行，任务会被正常取消，未来也不会被执行，返回true。</li>
<li>任务已经完成或被取消过，返回false。</li>
<li>任务正在执行，会根据传入的参数mayInterruptIfRunning，如果传入的参数是true，执行任务的线程会收到一个中断的信号。如果传入的是false，就代表不中断正在运行的任务，同时返回false。</li>
</ol>
<p>true：明确知道这个任务能够处理中断</p>
<p>false：明确知道这个任务不能处理中断；不知道这个任务是否支持取消(是否能够响应中断)；如果这个任务一旦开始运行，就希望它完全的执行完毕。</p>
</li>
<li><p>isCancelled() 判断是否被取消</p>
</li>
</ul>
<p><strong>用FutureTask创建Future</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(task);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task运行结果：&quot;</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;正在计算！&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-Future注意点"><a href="#7-3-Future注意点" class="headerlink" title="7.3 Future注意点"></a>7.3 Future注意点</h4><ol>
<li><p>当for循环批量获取Future的结果时容易block，get方法调用时应该使用timeout限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SlowTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;速度慢的任务&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FastTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;速度快的任务&quot;</span> + Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MICROSECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Future future;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">                future = executorService.submit(<span class="keyword">new</span> <span class="title class_">SlowTask</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future = executorService.submit(<span class="keyword">new</span> <span class="title class_">FastTask</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> futures.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String)future.get();</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">速度慢的任务pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">速度慢的任务pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">速度快的任务pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">速度快的任务pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/../../../../assets/img/CgpOIF5Y0OGAKVKjAACCEFYDuCw593.png"></p>
<p>第三个任务量比较小，可以很快返回结果，紧接着第四个任务也会返回结果。但由于前两个任务速度很慢，所以get方法执行时，会卡在第一个任务上。所以，即使第三、四个任务很早就得到结果了，但在此使用for循环的方式去获取结果，依然无法及时获取第三、四个任务的结果。直到5秒后，第一个任务出结果了，我们才能获取到，紧接着获取剩下任务的结果。</p>
<p>此时可以使用Future的带超时参数的get(long timeout, TimeUnit unit)方法，如果在限定时间内没能返回结果，即抛出TimeoutException。</p>
</li>
<li><p>Future的生命周期不可后退</p>
<p>Future的生命周期不可后退，一旦完成了任务，它就永久停在了”已完成”的状态，不能重头再来，即不能让一个已经完成计算的Future再次重新执行任务。</p>
</li>
</ol>
<p><strong>Future产生新的线程了吗</strong></p>
<p>Callable和Future本身并不能产生新的线程，它们需要借助其它的比如Thread类或者线程池才能执行任务。例如：在把Callable提交到线程池后，真正执行Callable的其实还是线程池中的线程，而线程池中的线程是由ThreadFactory产生的。</p>
<h4 id="7-4-CountDownLatch、Completable"><a href="#7-4-CountDownLatch、Completable" class="headerlink" title="7.4 CountDownLatch、Completable"></a>7.4 CountDownLatch、Completable</h4><p><img data-src="/../../../../assets/img/Cgq2xl5c0xaASO8FAAFKHNM1bu8607.png"></p>
<ul>
<li><p>线程池实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolDemo</span> <span class="variable">threadPoolDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolDemo</span>();</span><br><span class="line">        System.out.println(threadPoolDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; <span class="title function_">getPrices</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">123</span>, prices));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">456</span>, prices));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">789</span>, prices));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.productId = productId;</span><br><span class="line">            <span class="built_in">this</span>.prices = prices;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price= (<span class="type">int</span>) (Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatchDemo</span> <span class="variable">countDownLatchDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatchDemo</span>();</span><br><span class="line">        System.out.println(countDownLatchDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; <span class="title function_">getPrices</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">123</span>, prices, countDownLatch));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">456</span>, prices, countDownLatch));</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">789</span>, prices, countDownLatch));</span><br><span class="line">        countDownLatch.await(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices,</span></span><br><span class="line"><span class="params">                CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.productId = productId;</span><br><span class="line">            <span class="built_in">this</span>.prices = prices;</span><br><span class="line">            <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price = (<span class="type">int</span>) (Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行countDownLatch.await(3, TimeUnit.SECONDS)等待时，如果三个任务都非常快速得执行完毕了，那么都已经执行了countDown方法，相当于把计数减1。如果有一个线程没有执行countDown方法，来不及在3秒内执行完毕，那么这个带超时参数的await方法也会在3秒以后，及时的放弃这一次等待，于是就把prices返回了。</p>
</li>
<li><p>CompletableFuture</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        Integer productId;</span><br><span class="line">        Set&lt;Integer&gt; prices;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Integer productId, Set&lt;Integer&gt; prices)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.productId = productId;</span><br><span class="line">            <span class="built_in">this</span>.prices = prices;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>)(Math.random() * <span class="number">4000</span>));</span><br><span class="line">                price = (<span class="type">int</span>)(Math.random() * <span class="number">4000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            prices.add(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; <span class="title function_">getPrices</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; prices = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;());</span><br><span class="line">        CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">123</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">456</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; task3 = CompletableFuture.runAsync(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="number">789</span>, prices));</span><br><span class="line">        CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task2, task3);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            allTasks.get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CompletableFutureDemo</span> <span class="variable">completableFutureDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompletableFutureDemo</span>();</span><br><span class="line">        System.out.println(completableFutureDemo.getPrices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompletableFuture的runAsync()方法，这个方法会异步的去执行任务。</p>
</li>
</ul>
<h3 id="8-线程协作"><a href="#8-线程协作" class="headerlink" title="8.线程协作"></a>8.线程协作</h3><h4 id="8-1-信号量"><a href="#8-1-信号量" class="headerlink" title="8.1 信号量"></a>8.1 信号量</h4><p>  控制需要限制并发访问量的资源。</p>
<p>  <strong>使用流程</strong></p>
<ol>
<li><p>初始化一个信号量，并传入许可证的数量。public Semaphore(int permits, boolean fair)，传入两个参数，第一个参数是许可证的数量，另一个参数是是否公平，如果为true，代表是公平的策略，会把之前已经在等待的线程放入到队列中，当有新的许可证时，会按照顺序发放；如果为false，则代表非公平策略，也就有可能插队。</p>
</li>
<li><p>在调用慢服务之前，线程调用acquire()或者acquireUninterruptibly()获取许可证。如果此时信号量没有剩余的许可证，那么线程会等在acquire()的这一行代码中，不会进一步执行下面调用服务的方法。</p>
<p>acquire()和acquireUninterruptibly()的区别：是否能够中断。acquire()支持中断，即在获取信号量期间，假如这个线程被中断了，那么它就会跳出acquire()，不再继续尝试获取了，而acquireUninterruptibly()方法是不会中断的。</p>
</li>
<li><p>任务执行完毕之后，调用release()释放许可证。</p>
</li>
</ol>
<p><strong>其他的主要方法</strong></p>
<ol>
<li><p>public boolean tryAcquire()</p>
<p>尝试获取许可证，获取不到不会阻塞，可以去做其他事。</p>
</li>
<li><p>public boolean tryAcquire(long timeout, TimeUnit unit)</p>
<p>超时时间到，依然获取不到许可证，认为获取失败，返回false。</p>
</li>
<li><p>availablePermits()</p>
<p>查询可用许可证的数量，返回一个整形的结果。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;StopWatch&gt; stopWatchThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">StopWatch</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到许可证，开始执行任务！&quot;</span>);</span><br><span class="line">            <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> stopWatchThreadLocal.get();</span><br><span class="line">            stopWatch.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                stopWatch.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;慢服务执行完毕，耗时：&quot;</span> + stopWatch.getTotalTimeMillis() + <span class="string">&quot;---&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName() + <span class="string">&quot;释放了许可证！&quot;</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                stopWatchThreadLocal.remove();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊用法：一次获取或释放多个许可证</p>
<p>semphore.acquire(2)		semaphore.release(3)</p>
<p><strong>注意点</strong></p>
<ul>
<li>获取和释放的许可证数量尽量保持一致</li>
<li>在初始化时可以设置公平性，true会让它更公平，false则会让总的吞吐量更高</li>
<li>信号量是支持跨线程、跨线程池的，并且并不是哪个线程获得的许可证，就必须由这个线程去释放，对于获取和释放许可证的线程是没有要求的。</li>
</ul>
<h4 id="8-2-CountDownLatch-是如何安排线程执行顺序的？"><a href="#8-2-CountDownLatch-是如何安排线程执行顺序的？" class="headerlink" title="8.2 CountDownLatch 是如何安排线程执行顺序的？"></a>8.2 CountDownLatch 是如何安排线程执行顺序的？</h4><p><img data-src="/../../../../assets/img/Cgq2xl5h8oSAKLBQAABld2EcD7Q385.png"></p>
<p><strong>主要方法</strong></p>
<ol>
<li><p>构造函数</p>
<p>public CountDownLatch(int count){</p>
<p>}</p>
<p>count是需要倒数的值</p>
</li>
<li><p>await()</p>
<p>调用await()方法的线程开始等待，直到倒数结束，也就是count值为0的时候才会继续执行。</p>
</li>
<li><p>await(long timeout, TimeUnit unit)</p>
<p>和await()类似，但这里可以设置超时时间，如果超时就不等待了。</p>
</li>
<li><p>countDown()</p>
<p>把数值倒数1，也就是将count值减1，直到减为0时，之前等待的线程会被唤起。</p>
</li>
</ol>
<p><strong>用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">downLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">downLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(finalI + <span class="string">&quot;号运动员准备完毕，等待裁判员的发令枪&quot;</span>);</span><br><span class="line">                        downLatch2.await();</span><br><span class="line">                        Thread.sleep((<span class="type">long</span>)(Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        System.out.println(finalI + <span class="string">&quot;号运动员完成了比赛&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        downLatch1.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5秒准备时间已过，发令枪响，比赛开始！&quot;</span>);</span><br><span class="line">        downLatch2.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;等待5个运动员都跑完....&quot;</span>);</span><br><span class="line">        downLatch1.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有人都跑完了，比赛结束&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<ul>
<li>CountDownLatch是不能够重用的，比如已经完成了倒数，不可以在下一次继续去重新倒数。可以考虑使用CyclicBarrier或创建一个新的CountDownLatch实例。</li>
</ul>
<h4 id="8-3-CyclicBarrier和CountdownLatch"><a href="#8-3-CyclicBarrier和CountdownLatch" class="headerlink" title="8.3 CyclicBarrier和CountdownLatch"></a>8.3 CyclicBarrier和CountdownLatch</h4><p>CyclicBarrier可以构造出一个集结点，当某一个线程执行await()的时候，它就会到这个集结点开始等待，等待这个栅栏被撤销。直到预定数量的线程都到了这个集结点之后，这个栅栏就会撤销，之前等待的线程就在此刻统一出发，继续去执行剩下的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id, CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;同学&quot;</span> + id + <span class="string">&quot;现在从大门出发，前往自行车驿站&quot;</span>);</span><br><span class="line">                Thread.sleep((<span class="type">long</span>)(Math.random() * <span class="number">10000</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;同学&quot;</span> + id + <span class="string">&quot;到了自行车驿站，开始等待其他人到达&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;同学&quot;</span> + id + <span class="string">&quot;开始骑车&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="comment">// 当线程达到集结点，执行下一次动作之前，会执行一次这个动作</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;凑齐3人了，GO！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(i + <span class="number">1</span>, cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行动作barrierAction</strong></p>
<p>public CyclicBarrier(int parties, Runnable barrierAction): 当parties线程到达集结点时，继续往下执行前，会执行这一次这个动作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">同学1现在从大门出发，前往自行车驿站</span><br><span class="line">同学5现在从大门出发，前往自行车驿站</span><br><span class="line">同学6现在从大门出发，前往自行车驿站</span><br><span class="line">同学4现在从大门出发，前往自行车驿站</span><br><span class="line">同学3现在从大门出发，前往自行车驿站</span><br><span class="line">同学2现在从大门出发，前往自行车驿站</span><br><span class="line">同学5到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学2到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学6到了自行车驿站，开始等待其他人到达</span><br><span class="line">凑齐3人了，GO！</span><br><span class="line">同学6开始骑车</span><br><span class="line">同学5开始骑车</span><br><span class="line">同学2开始骑车</span><br><span class="line">同学3到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学4到了自行车驿站，开始等待其他人到达</span><br><span class="line">同学1到了自行车驿站，开始等待其他人到达</span><br><span class="line">凑齐3人了，GO！</span><br><span class="line">同学1开始骑车</span><br><span class="line">同学3开始骑车</span><br><span class="line">同学4开始骑车</span><br></pre></td></tr></table></figure>

<p><strong>CyclicBarrier和CountDownLatch的异同</strong></p>
<p>相同点：都能阻塞一个或一组线程，直到某个预设条件达成，再统一出发。</p>
<p>不同点：</p>
<ul>
<li><p>作用对象不同：</p>
<p>CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说CountDownLatch作用于事件，但CyclicBarrier作用于线程；CountDownLatch是在调用了countDown方法之后把数字减1，而CyclicBarrier是在某线程开始等待后把计数减1。</p>
</li>
<li><p>可重用性不同：</p>
<p>CountDownLatch在倒数0并且触发门闩打开后，就不能再次使用了，除非新建一个新的实例；而CyclicBarrier可以重复使用。CyclicBarrier还可以随时调用reset方法进行重置，如果重置时有线程已经调用了await方法并开始等待，那么这些线程则会抛出BrokenBarrierException异常。</p>
</li>
<li><p>执行动作不同：</p>
<p>CyclicBarrier有执行动作barrierAction，而CountDownLatch没这个功能。</p>
</li>
</ul>
<h4 id="8-4-Condition、object都wait-何notify-的关系"><a href="#8-4-Condition、object都wait-何notify-的关系" class="headerlink" title="8.4 Condition、object都wait()何notify()的关系"></a>8.4 Condition、object都wait()何notify()的关系</h4><p>假设线程1需要等待某些条件满足后，才能继续运行，如等待某个时间点到达或者等待某些任务处理完毕。此时，就可以执行Condition的await方法，一旦执行了该方法，这个线程就会进入WATTING状态。通常还有另外一个线程2，它去达成对应的条件，直到这个条件达成之后，那么线程2调用signal方法或signalAll方法，代表”<strong>条件达成，之前等待这个条件的线程现在可以苏醒了</strong>“。这个时候，JVM就会找到等待该Condition的线程，并予以唤醒，线程1在此时就会被唤醒，线程状态又会回到Runnable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:条件不满足，开始await&quot;</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;条件满足了，开始执行后续的任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:需要5秒钟的准备时间&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:准备工作完成，唤醒其他的线程&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ConditionDemo</span> <span class="variable">conditionDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConditionDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionDemo.task2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        conditionDemo.task1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:条件不满足，开始await</span><br><span class="line">Thread-<span class="number">0</span>:需要<span class="number">5</span>秒钟的准备时间</span><br><span class="line">Thread-<span class="number">0</span>:准备工作完成，唤醒其他的线程</span><br><span class="line">main条件满足了，开始执行后续的任务</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<ul>
<li><p>线程2解锁后，线程1才能获得锁并继续执行</p>
<p>调用signal之后，还需要等待子线程完全退出这个锁，即执行unlock之后，这个主线程才有可能去获取到这把锁，并且当获取锁成功之后才能继续执行后面的任务。</p>
</li>
<li><p>signalAll()和signal()区别</p>
<p>signalAll()会唤醒所有正在等待的线程，而signal()只会唤醒一个线程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Condition实现简易版阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForCondition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockingQueueForCondition</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = maxSize;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == max) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(object);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">item</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用wait/notify来实现简易版阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBlockingQueueForWaitNotify</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockingQueueForWaitNotify</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object object)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == maxSize) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(object);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">item</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Condition把Object的wait&#x2F;notify&#x2F;notifyAll转化为了一种相应的对象，其实现的效果基本一样，但是把更复杂的用法，变成了更直观可控的对象方法，是一种升级。await方法会自动释放持有的Lock锁，否则会抛出异常，和Object的wait一样，不需要自己手动释放锁。另外，调用await的时候必须持有锁，否则会抛出异常，这一点和Object的wait一样。</p>
<h3 id="9-Java内存模型"><a href="#9-Java内存模型" class="headerlink" title="9.Java内存模型"></a>9.Java内存模型</h3><h4 id="9-1-什么是Java内存模型？"><a href="#9-1-什么是Java内存模型？" class="headerlink" title="9.1 什么是Java内存模型？"></a>9.1 什么是Java内存模型？</h4><p><strong>JVM内存结构</strong></p>
<ul>
<li><p>堆</p>
<p>堆是存放类实例和数组的，通常是内存中最大的一块。比如new Object()就会产生一个实例；而数组也是保存在堆上，因为在Java中，数组也是对象。</p>
</li>
<li><p>虚拟机栈</p>
<p>保存局部变量和部分结果，并在方法调用和返回中起作用。</p>
</li>
<li><p>方法区</p>
<p>它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括用于类初始化以及接口初始化的特殊方法。</p>
</li>
<li><p>本地方法栈</p>
<p>与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。</p>
</li>
<li><p>程序计数器</p>
<p>最小的一块内存区域，它的作用通常是保存当前正在执行的JVM指令地址。</p>
</li>
<li><p>运行时常量池</p>
<p>是方法区的一部分，包含多种常量，范围从编译时已知的数字到必须在运行时解析的方法和字段引用。</p>
</li>
</ul>
<p><strong>为什么需要JMM(Java Memory Model, Java内存模型)</strong></p>
<p>程序最终执行的效果依赖于具体的处理器，而不同的处理器的规则又不一样，需要一个标准，让多线程运行结果可以预期，这个标准就是JMM。</p>
<p><strong>JMM是什么</strong></p>
<ul>
<li><p>JMM是规范</p>
<p>JMM是和多线程相关的一组规范，需要各个JVM的实现来遵守JMM规范。因此JMM与处理器、缓存、并发、编译器有关，它解决了CPU多级缓存、处理器优化、质量重排序等导致的结果不可预期的问题。</p>
</li>
<li><p>JMM是工具类和关键字的原理</p>
<p>如volatile、synchronized、Lock等原理都涉及JMM。重排序、原子性、内存可见性。</p>
</li>
</ul>
<h4 id="9-2-什么是指令重排序？为什么要进行重排序？"><a href="#9-2-什么是指令重排序？为什么要进行重排序？" class="headerlink" title="9.2 什么是指令重排序？为什么要进行重排序？"></a>9.2 什么是指令重排序？为什么要进行重排序？</h4><p>假设我们写了一个Java程序，实际上语句的运行顺序可能可写的代码顺序不一致。编译器、JVM或者CPU都有可能出于优化等目的，对于实际指令执行的顺序进行调整。</p>
<p><strong>重排序的好处：提高处理速度</strong></p>
<p><img data-src="/../../../../assets/img/CgpOIF5vI8yAE1n_AACnC3UQ3xM235.png"></p>
<p><img data-src="/../../../../assets/img/Cgq2xl5vI8yAfRpUAACP4YXZ3sg831.png"></p>
<p><strong>重排序的3种情况</strong></p>
<ol>
<li><p>编译器优化</p>
<p>编译器(包括JVM、JIT编译器等)；重排序并不意味着可以任意排序，它需要保证重排序后，不改变单线程内的语义。</p>
</li>
<li><p>CPU重排序</p>
<p>CPU同样会有优化行为，即使之前的编译器不发生冲排，CPU也可能进行重排。</p>
</li>
<li><p>内存的”重排序”</p>
<p>内存系统不存在真正的重排序，但是内存会带来看上去和重排序一样的效果。由于内存有缓存的存在，在JMM里表现为主内存和本地内存，而主内存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</p>
</li>
</ol>
<h4 id="9-3-Java中的原子操作有哪些注意事项？"><a href="#9-3-Java中的原子操作有哪些注意事项？" class="headerlink" title="9.3 Java中的原子操作有哪些注意事项？"></a>9.3 Java中的原子操作有哪些注意事项？</h4><p>原子操作指一系列操作要么全部发生，要么全部不发生，不会出现执行一半的情况。</p>
<p><strong>Java中的原子操作有哪些</strong></p>
<ul>
<li>除了long和double之外的基本类型(int、byte、boolean、short、char、float)的读&#x2F;写操作，都天然的具备原子性</li>
<li>所有引用reference的读&#x2F;写操作</li>
<li>加了volatile后，所有变量的读&#x2F;写操作(包含long&#x2F;double)</li>
<li>java.concurrent.Atomic包中的一部分类的一部分方法，比如AtomicInteger的incrementAndGet</li>
</ul>
<p><strong>long和double的原子性</strong></p>
<p>long和double的值需要占用64位的内存空间，而对于64位值的写入，可以分为两个32位的操作进行。因此，本来是一个整体的赋值操作，就可能被拆分为低32位和高32位两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。</p>
<p>JVM的开发者可以自由选择是否把64位的long和double的读写操作作为原子操作去实现，并且规范推荐JVM将其实现为原子操作。</p>
<p><strong>原子操作 + 原子操作 !&#x3D; 原子操作</strong></p>
<h4 id="9-4-什么是内存可见性"><a href="#9-4-什么是内存可见性" class="headerlink" title="9.4 什么是内存可见性"></a>9.4 什么是内存可见性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内存可见性问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisibilityProblem</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">30</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b + <span class="string">&quot;;a=&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">VisibilityProblem</span> <span class="variable">visibilityProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisibilityProblem</span>();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    visibilityProblem.change();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    visibilityProblem.print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第1种情况：假设第1个线程，也就是执行change的线程先运行，并且运行完毕了，然后，第2个线程开始运行，打印出b&#x3D;30;a&#x3D;30</li>
<li>第2种情况：与第1种情况相反。因为线程先start，并不代表它真的先执行，所以第2种情况是第2个线程先打印b&#x3D;20;a&#x3D;10，然后第1个线程再去进行change</li>
<li>第3种情况：它们几乎同时运行，所以会出现交叉的情况。如第1个线程的change执行到一半，已经把a的值改为30了，而b的值还未来得及修改，此时第2个线程就开始打印，即打印结果为b&#x3D;20;a&#x3D;30</li>
<li>第4种情况：<strong>发生可见性问题</strong>，a的值已经被第1个线程修改了，但是其他线程却看不到，由于a的最新值没能及时同步过来，打印出b&#x3D;30;a&#x3D;10</li>
</ul>
<p><strong>volatile关键字解决可见性问题</strong></p>
<p><strong>synchronized不仅保证了原子性，还保证了可见性</strong></p>
<p>synchronized不仅保证了临界区内最多同时只有一个线程执行操作，同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。</p>
<h4 id="9-5-主内存与工作内存的关系"><a href="#9-5-主内存与工作内存的关系" class="headerlink" title="9.5 主内存与工作内存的关系"></a>9.5 主内存与工作内存的关系</h4><p><strong>CPU有多级缓存，导致读的数据过期</strong></p>
<p>为了提高CPU的整体运行效率，减少空闲时间，在CPU和内存之间会有cache层(缓存层)。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中L1缓存的速度仅次于寄存器的速度。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl54fTKALhevAAB_l3axT_o532.png"></p>
<p>线程间对于共享变量的可见性问题，并不是由多核引起的，而是由多级缓存引起的。每个核心在获取在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的L1缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。</p>
<p>假设core1修改了变量a的值，并写入到了core1的L1缓存里，但是还没来得及继续往下同步，由于core1有它自己的L1缓存，core4是无法直接获取core1的L1缓存的值，那么此时对于core4而言，变量a的值就不是core1修改后的最新的值，core4读取到的可能是一个过期的值，从而引起多线程时的可见性问题发生。</p>
<p><strong>JMM的抽象：主内存和工作内存</strong></p>
<p><img data-src="/../../../../assets/img/Ciqah154fUGAS19LAAGap07f1AU762.png"></p>
<p>每个线程都只能直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是JMM控制的。</p>
<p><strong>主内存和工作内存的关系</strong></p>
<ol>
<li>所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容内容是主内存中该变量的拷贝。</li>
<li>线程不能直接读&#x2F;写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改。</li>
<li>主内存是由多个线程所共享的，但线程之间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存主内存来完成。</li>
</ol>
<h4 id="9-6-什么是happens-before规则？"><a href="#9-6-什么是happens-before规则？" class="headerlink" title="9.6 什么是happens-before规则？"></a>9.6 什么是happens-before规则？</h4><p>Happens-before关系是用来描述可见性相关问题的：如果第一个操作happens-before第二个操作，那么可以认为第一个操作对于第二个操作一定是可见的。</p>
<p><strong>Happens-before的规则</strong></p>
<ol>
<li><p>单线程规则</p>
<p>在一个单独的线程中，按照程序代码的顺序，先执行的操作happens-before后执行的操作。</p>
<p><img data-src="/../../../../assets/img/Ciqah157Dw6AfJVGAABiifLhJkU236.png"></p>
<p>但只要重排序后的结果依然符合happens-before关系，也就是能保持可见性的话，并不会限制重排序的发生。</p>
</li>
<li><p>锁操作规则(synchronized和Lock接口)</p>
<p>如果操作A是解锁，而操作B是对同一个锁的加锁，那么hb(A,B)。</p>
<p><img data-src="/../../../../assets/img/Ciqah157Dw6Aeo7EAAA0bxPJeKw538.png"></p>
</li>
<li><p>volatile变量规则</p>
<p>对于一个volatile变量的写操作happens-before后面对该变量的读操作。</p>
</li>
<li><p>线程启动规则</p>
<p>Thread对象的start方法happens-before此线程run方法中的每一个操作。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl57Dw6AdKyOAADBt-00qXo349.png"></p>
</li>
<li><p>线程join规则</p>
<p>join可以让线程之间等待，假设线程A通过调用threadB.start()启动了一个新线程B，然后调用threadB.join()，那么线程A将一直等待到线程B的run方法结束(不考虑中断等特殊情况)，然会join方法才返回。在join方法返回后，线程A中的所有后续操作都可以看到线程B的run方法执行的所有操作的结果，也就是线程B的run方法里面的操作hanppens-before线程A的join之后的语句。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl57Dw6ADE7rAADRJKFrbWE816.png"></p>
</li>
<li><p>中断规则</p>
<p>对线程interrupt方法的调用happens-before检测该线程的中断事件。</p>
</li>
<li><p>并发工具类的规则</p>
<ul>
<li>线程安全的并发容器(如ConcurrentHashMap)在get某个值时一定能看到在此之前发生的put等存入操作的结果。</li>
<li>信号量(Semaphore)会释放许可证，也会获取许可证。释放许可证的操作happens-before获取许可证的操作。</li>
<li>Future：当Future的get方法得到结果的时候，一定可以看到之前任务中所有的操作。</li>
<li>线程池：提交任务的操作happens-before任务的执行。</li>
</ul>
</li>
</ol>
<h4 id="9-7-volatile的作用是什么？与synchronized有什么异同？"><a href="#9-7-volatile的作用是什么？与synchronized有什么异同？" class="headerlink" title="9.7 volatile的作用是什么？与synchronized有什么异同？"></a>9.7 volatile的作用是什么？与synchronized有什么异同？</h4><p>volatile是Java中的一个关键字，是一种同步机制。当某个变量是共享变量，且这个变量被volatile修饰，那么在修改了这个变量的值之后，再读取该变量的值时，可以保证获取到的是修改后的最新的值。</p>
<p>相比于synchronized或者Lock，volatile更加轻量，因为使用volatile不会发生上下文切换等开销很大的情况，不会让线程阻塞。</p>
<p><strong>volatile不适用于a++</strong></p>
<p>volatile不适合运用于需要保证原子性的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a++ 不适合使用volatile</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DontVolatile</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">realA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">DontVolatile</span> <span class="variable">dontVolatile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DontVolatile</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dontVolatile);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dontVolatile);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(dontVolatile.a);</span><br><span class="line">        System.out.println(dontVolatile.realA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            a++;</span><br><span class="line">            realA.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1926</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场合1：布尔标记位</strong></p>
<p>第一个例子的操作是a++，这是个复合操作，不具备原子性，而下面这个例子只是把flag设置为true，这样的赋值操作本身就是具备原子性的，所以适合使用volatile。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以使用volatile的场景 布尔标记位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YesVolatile1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">realA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">YesVolatile1</span> <span class="variable">yesVolatile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YesVolatile1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(yesVolatile1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(yesVolatile1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(yesVolatile1.flag);</span><br><span class="line">        System.out.println(yesVolatile1.realA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            realA.incrementAndGet();</span><br><span class="line">            setDone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场合2：作为触发器，保证其他变量的可见性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">. . .</span><br><span class="line"><span class="comment">// In thread A</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>;</span><br><span class="line">. . .</span><br><span class="line"><span class="comment">// In thread B</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) </span><br><span class="line">  sleep();</span><br><span class="line"><span class="comment">// use configOptions</span></span><br></pre></td></tr></table></figure>

<p>happens-before具有传递性，根据happens-before的单线程规则，线程A中configOptions的初始化happens-before对iniialized变量的写入，而线程B中对initialized的读取happens-before对configOptions变量的使用，同时根据happens-before关系的volatile规则，线程A中对initialized的写入为true的操作happens-before线程B中随后对initialized变量的读取。</p>
<p><strong>volatile的作用</strong></p>
<ol>
<li><p>保证可见性</p>
<p>对于一个volatile变量的写操作happen-before后面对该变量的读操作，即如果变量被volatile修饰，那么每次修改之后，接下来在读取这个变量的时候一定能读到该变量的最新值。</p>
</li>
<li><p>禁止重排序</p>
<p>as-if-serial：不管怎么重排序，单线程的执行结果不变。多线程情况下的重排序可能会导致严重的线程安全问题。使用volatile关键字可以在一定程度上禁止这种重排序。</p>
</li>
</ol>
<p><strong>volatile和synchronized的关系</strong></p>
<p>相似性：volatile可以看作是一个轻量版的synchronized，如果一个共享变量如果自始至终只被各个线程赋值和读取，而没有其他操作的话，那么就可以用volatile来代替synchronized或者代替原子变量。</p>
<p>不可代替：volatile是不能代替synchronized的，volatile并没有提供原子性和互斥性的。</p>
<p>性能方面：volatile的读写操作都是无锁的，比synchronized性能更好。</p>
<h4 id="9-8-单例模式的双重检查锁模式为什么必须加volatile？"><a href="#9-8-单例模式的双重检查锁模式为什么必须加volatile？" class="headerlink" title="9.8 单例模式的双重检查锁模式为什么必须加volatile？"></a>9.8 单例模式的双重检查锁模式为什么必须加volatile？</h4><p>单例模式：保证一个类只有一个实例，并且提供一个可以全局访问的入口。</p>
<p><strong>为什么需要使用单例模式？</strong></p>
<ol>
<li><p>为了节省内存、节省计算。</p>
</li>
<li><p>保证结果正确。</p>
</li>
<li><p>方便管理。</p>
<p>有一个私有的Singleton类型的singleton对象；同时构造方法也是私有的，为了防止他人调用构造函数来生成实例；还有一个public的getInstance方法，可通过这个方法获取到单例。</p>
</li>
</ol>
<p><strong>双重检查锁模式的写法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile 双重检查锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行了两次if(singleton&#x3D;&#x3D;null)检查，即”双重检查锁”。假设有两个线程同时到达synchronized语句块，那么实例化代码只会由其中先抢到锁的线程执行一次，而后抢到锁的线程会在第二个if判断中发现singleton不为null，所以跳过创建实例的语句。再后面的其他线程再来调用getInstance方法时，只需判断第一次的if(singleton&#x3D;&#x3D;null)，然后跳过整个if块，直接return实例化后的对象。</p>
<p><strong>为什么需要双重检查？</strong></p>
<p>如果有两个线程同时调用getInstance方法，由于singleton是空的，因此两个线程可以通过第一重if的检查，然后由于锁的存在，会有一个线程先进入同步语句，并进入第二重检查，而另外一个线程就在外面等待。不过当第一个线程执行完new Singleton()语句后，就会退出synchronized保护的区域，这时如果没有第二重if(singleton&#x3D;&#x3D;null)判断的话，那么第二个线程也会创建一个实例，破环了单例。</p>
<p>如果去掉第一个检查，那么所有线程都会串行执行，效率低下。</p>
<p><strong>双重检查模式中为什么需要使用volatile关键字？</strong></p>
<p>singleton &#x3D; new Singleton() 并非是一个原子操作，在JVM中至少做了以下3件事。</p>
<p><img data-src="/../../../../assets/img/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png"></p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数，来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步singleton就不是null了)</li>
</ol>
<p>因为存在指令排序的优化，所以第2，3步的顺序是不能保证的，最终的执行顺序可能是1-2-3，也有可能是1-3-2。</p>
<p>如果是1-3-2：</p>
<p><img data-src="/../../../../assets/img/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png"></p>
<p>使用volatile之后，相当于是表明了该字段的更新可能是在其他线程中发生的，在JDK5及后续版本所使用的JMM中，在使用了volatile后，会在一定程度禁止相关语句的重排序。</p>
<h3 id="10-CAS"><a href="#10-CAS" class="headerlink" title="10.CAS"></a>10.CAS</h3><h4 id="10-1-什么是CAS"><a href="#10-1-什么是CAS" class="headerlink" title="10.1 什么是CAS?"></a>10.1 什么是CAS?</h4><p>CAS(Compare And Swap)，是一种思想，为了保证并发安全，可以使用互斥锁，而CAS的特点就是避免使用互斥锁，当多个线程同时使用CAS更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并<strong>不会被阻塞</strong>，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。</p>
<p><strong>CAS的思路</strong></p>
<p>CAS相关的指令是具备原子性的，”<strong>比较和交换</strong>“操作在执行期间不会被打断。</p>
<p>CAS有3个操作数：内存值V，预期值A、要修改的值B。当预期值A和当前的内存值V相同时，才将内存值修改为B。</p>
<p>CAS会提前假定当前内存值V应该等于值A，而值A往往是之前读取到当时的内存值V，如果发现当前的内存值V恰好是值A的话，那CAS就会把内存值V改成B。如果执行CAS时发现此时的内存值V不等于值A，则说明在刚才计算B的期间内，内存值已经被其他线程修改过了，那么本次CAS就不应该再修改了。</p>
<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟CAS操作 等价代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimulatedCAS</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">compareAngSwap</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line">            value = newValue;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SimulatedCAS</span> <span class="variable">simulatedCAS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimulatedCAS</span>();</span><br><span class="line">        simulatedCAS.value = <span class="number">100</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(simulatedCAS);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(simulatedCAS);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(simulatedCAS.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        compareAngSwap(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-CAS的应用"><a href="#10-2-CAS的应用" class="headerlink" title="10.2 CAS的应用"></a>10.2 CAS的应用</h4><p><strong>并发容器</strong></p>
<ol>
<li><p>ConcurrentHashMap</p>
<p>putVal方法部分代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">......</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>casTabAt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>U是Unsafe类型的，Unsafe类包含compareAndSwapInt、compareAndSwapLong、compareAndSwapObject等和CAS密切相关的native层的方法，其底层正是利用CPU对CAS指令的支持实现的。</p>
</li>
<li><p>ConcurrentLinkedQueue</p>
<p>非阻塞并发队列ConcurrentLinkedQueue的offer方法里也有CAS的身影，offer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    casTail(t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>数据库</strong></p>
<p>在更新数据时，可以利用version字段在数据库中实现乐观锁和CAS操作，而在获取和修改数据时都不需要加悲观锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">	name <span class="operator">=</span> ‘小王’, version <span class="operator">=</span> <span class="number">2</span>        </span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">	id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> version <span class="operator">=</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p>先去比较version是不是最开始获取到的1，如果和初始值相同才去进行name字段的修改，同时也要把version的值加1。</p>
<p><strong>原子类</strong></p>
<p>在原子类中，如AtomicInteger，也使用了CAS。如AtomicInteger的getAndAdd方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>var1</th>
<th>o</th>
<th>object</th>
<th>将要修改的对象，传入的是this，也就是atomicInteger这个对象本身</th>
</tr>
</thead>
<tbody><tr>
<td>var2</td>
<td>offset</td>
<td>offset</td>
<td>偏移量，借助它就可以获取到oldvalue的数值</td>
</tr>
<tr>
<td>var5</td>
<td>v</td>
<td>expectedValue</td>
<td>代表”期望值”</td>
</tr>
<tr>
<td>var5+var4</td>
<td>v+delta</td>
<td>newValue</td>
<td>希望修改为的新值，var4就是希望原子类所改变的数值，比如可以传入+1，也可以传入-1</td>
</tr>
</tbody></table>
<p>Unsafe的getAndAddInt方法是通过<strong>循环+CAS</strong>的方式来实现的，在此过程中，它会通过compareAndSwapInt方法来尝试更新value的值，如果更新失败就重新获取，然后再次更新，直到更新成功。</p>
<h4 id="10-3-CAS有什么缺点？"><a href="#10-3-CAS有什么缺点？" class="headerlink" title="10.3 CAS有什么缺点？"></a>10.3 CAS有什么缺点？</h4><p><strong>ABA问题</strong></p>
<p>CAS检查的并不是值有没有发生过变化，而是去比较这当前值和预期值是不是相等，如果变量的值从旧值A变成了新值B再变回旧值A，由于最开始是值A和现在的值A是相等的，所以CAS会认为变量的值在此期间没有发生过变化。所以，<strong>CAS并不能检测在此期间值是不是被修改过，它只能检查出现在的值和最初的值是不是一样</strong>。</p>
<p>在变量自身之外，再添加一个<strong>版本号</strong>，A-&gt;B-&gt;A，1A-&gt;2B-&gt;3A，可以通过版本号来判断值是否变化过。</p>
<p>atomic包中提供了<strong>AtomicStampedReference</strong>这个类，它是专门用来解决ABA问题，解决思路正是利用版本号，AtomicStampedReference会维护一种类似&lt;Object,int&gt;的数据结构，其中的int就是用于计数的，也就是版本号。</p>
<p><strong>自旋时间过长</strong></p>
<p>由于单次CAS不一定能执行成功，所以<strong>CAS往往是配合着循环来实现的</strong>，有的时候甚至是死循环，不停重试，直到竞争不激烈的时候，才能修改成功。</p>
<p>如果是<strong>高并发场景</strong>，有可能导致CAS一直操作不成功，循环的时间会越来越长。CPU资源一直在被消耗，会对性能产生很大的影响，高并发情况下，通常CAS的效率是不高的。</p>
<p><strong>范围不能灵活控制</strong></p>
<p>通常执行CAS的时候，是针对某一个，而不是多个共享变量的，多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。</p>
<p>有一个解决方案就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用atomic包中的AtomicReference来把这个新对象整体进行CAS操作。</p>
<p>相比之下，如使用synchronized关键字时，如果想把更加的代码加锁，<strong>只需把更多的代码放到同步代码块里面</strong>就可以了。</p>
<h3 id="11-死锁问题"><a href="#11-死锁问题" class="headerlink" title="11.死锁问题"></a>11.死锁问题</h3><h4 id="11-1-写一个必然死锁的例子"><a href="#11-1-写一个必然死锁的例子" class="headerlink" title="11.1 写一个必然死锁的例子"></a>11.1 写一个必然死锁的例子</h4><p><strong>什么是死锁？</strong></p>
<p><strong>发生在并发中</strong>，两个或多个线程(或进程)被无限期的阻塞，相互等待对方手中资源。</p>
<p><strong>例子</strong></p>
<p>两个线程：</p>
<p><img data-src="/../../../../assets/img/Cgq2xl6NrzGAMfz3AABHRjw_QSE080.png"></p>
<p>多个线程：</p>
<p><img data-src="/../../../../assets/img/Cgq2xl6NrzGAeQrqAAA0YIeU1Qg392.png"></p>
<p><strong>死锁的影响</strong></p>
<p>数据库中：</p>
<p>在执行一个事务的时候可能需要获取多把锁，并一直持有这些锁直到事务完成。在某个事务中持有的锁可能在其他事务中也需要，因此在两个事务之间有可能会发生死锁的情况。当数据库检测到这一组事务发生了死锁，根据策略的不同，可能会选择放弃一个事务，被放弃的事务就会释放掉它所持有的锁，从而使其它事务继续进行。此时程序可以重新执行被强行终止的事务。</p>
<p>JVM中：</p>
<p>JVM并不会自动进行处理，发生几率不高但危害大，在巨量的次数面前，整个系统发生问题的几率也会被放大。</p>
<p><strong>发生死锁的例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必然死锁的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MustDeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;的flag为&quot;</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;获取到了两把锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName()+<span class="string">&quot;获取到了两把锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MustDeadLock</span> <span class="variable">mustDeadLock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MustDeadLock</span>();</span><br><span class="line">        <span class="type">MustDeadLock</span> <span class="variable">mustDeadLock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MustDeadLock</span>();</span><br><span class="line">        mustDeadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        mustDeadLock2.flag = <span class="number">2</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mustDeadLock1,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mustDeadLock2,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">线程thread1的flag为<span class="number">1</span></span><br><span class="line">线程thread2的flag为<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当第1个线程运行的时候，它会发现自己的flag是1，所以它会尝试先获得object1这把锁，然后休眠500毫秒。</li>
<li>在线程1启动并休眠的期间，线程2同样会启动。由于线程2的flag是2，所以线程2首先会去获取object2这把锁，然后休眠500毫秒。</li>
<li>当线程1的500毫秒休眠时间结束，它会尝试去获取object2这把锁，此时object2这把锁正在被线程2持有，所以线程1无法获取到object2。</li>
<li>紧接着线程2也会苏醒过来，它将尝试获取object1这把锁，此时object1已被线程1持有。</li>
</ul>
<p>线程1卡在获取object2这把锁的位置，而线程2卡在获取object1这把锁的位置。</p>
<h4 id="11-2-发生死锁的4个必要条件"><a href="#11-2-发生死锁的4个必要条件" class="headerlink" title="11.2 发生死锁的4个必要条件"></a>11.2 发生死锁的4个必要条件</h4><ul>
<li><p><strong>互斥条件</strong></p>
<p>每个资源每次只能被一个线程(或进程)使用。</p>
</li>
<li><p><strong>请求与保持条件</strong></p>
<p>当一个线程因请求资源而阻塞时，则需对已获得的资源保持不放。</p>
</li>
<li><p><strong>不剥夺条件</strong></p>
<p>线程已获得的资源，在未使用完之前，不会被强行剥夺。</p>
</li>
<li><p><strong>循环等待条件</strong></p>
<p>只有若干个线程之间形成一种头尾相接的循环等待资源关系时，才有可能形成死锁。</p>
</li>
</ul>
<h4 id="11-3-如何定位死锁？"><a href="#11-3-如何定位死锁？" class="headerlink" title="11.3 如何定位死锁？"></a>11.3 如何定位死锁？</h4><ul>
<li><p>命令：<strong>jstack</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">D:\IDEAProbject\JavaStudyDemo\Multithreading&gt;jps</span><br><span class="line">3044 Launcher</span><br><span class="line">4084 MustDeadLock</span><br><span class="line">11816 Jps</span><br><span class="line"></span><br><span class="line">D:\IDEAProbject\JavaStudyDemo\Multithreading&gt;jstack 4084</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001c601e68 (object 0x0000000776319ce0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread1&quot;</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001c6047a8 (object 0x0000000776319cf0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">        at com.example.MustDeadLock.run(MustDeadLock.java:34)</span><br><span class="line">        - waiting to lock &lt;0x0000000776319ce0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x0000000776319cf0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">        at com.example.MustDeadLock.run(MustDeadLock.java:22)</span><br><span class="line">        - waiting to lock &lt;0x0000000776319cf0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x0000000776319ce0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码：<strong>ThreadMXBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必然死锁的例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MustDeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;的flag为&quot;</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取到了两把锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获取到了两把锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MustDeadLock</span> <span class="variable">mustDeadLock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MustDeadLock</span>();</span><br><span class="line">        <span class="type">MustDeadLock</span> <span class="variable">mustDeadLock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MustDeadLock</span>();</span><br><span class="line">        mustDeadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        mustDeadLock2.flag = <span class="number">2</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mustDeadLock1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mustDeadLock2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">        <span class="type">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();</span><br><span class="line">        <span class="keyword">if</span> (deadlockedThreads != <span class="literal">null</span> &amp;&amp; deadlockedThreads.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deadlockedThreads.length; i++) &#123;</span><br><span class="line">                <span class="type">ThreadInfo</span> <span class="variable">threadInfo</span> <span class="operator">=</span> threadMXBean.getThreadInfo(deadlockedThreads[i]);</span><br><span class="line">                System.out.println(threadInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程thread1的flag为<span class="number">1</span></span><br><span class="line">线程thread2的flag为<span class="number">2</span></span><br><span class="line"><span class="string">&quot;thread2&quot;</span> Id=<span class="number">21</span> BLOCKED on java.lang.Object@27d6c5e0 owned by <span class="string">&quot;thread1&quot;</span> Id=<span class="number">20</span></span><br><span class="line"><span class="string">&quot;thread1&quot;</span> Id=<span class="number">20</span> BLOCKED on java.lang.Object@4f3f5b24 owned by <span class="string">&quot;thread2&quot;</span> Id=<span class="number">21</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-4-解决死锁问题的策略"><a href="#11-4-解决死锁问题的策略" class="headerlink" title="11.4 解决死锁问题的策略"></a>11.4 解决死锁问题的策略</h4><ul>
<li><p><strong>避免策略</strong></p>
<p>优化代码逻辑，从根本上消除发生死锁的可能性，如调整锁的获取顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整锁的获取顺序来避免死锁问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferMoney</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">        <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> balance)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Account</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(a, b, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(b, a, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(Account from, Account to, <span class="type">int</span> account)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromHash</span> <span class="operator">=</span> System.identityHashCode(from);</span><br><span class="line">        <span class="type">int</span> <span class="variable">toHash</span> <span class="operator">=</span> System.identityHashCode(to);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="comment">// 先获取两把锁，然后开始转账</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;余额不足，转账失败！&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    from.balance -= account;</span><br><span class="line">                    to.balance += account;</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功转账&quot;</span> + account + <span class="string">&quot;元！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toHash &gt; fromHash) &#123;</span><br><span class="line">            <span class="comment">// 先获取两把锁，然后开始转账</span></span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;余额不足，转账失败！&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    from.balance -= account;</span><br><span class="line">                    to.balance += account;</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功转账&quot;</span> + account + <span class="string">&quot;元！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TransferMoney</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransferMoney</span>();</span><br><span class="line">        <span class="type">TransferMoney</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransferMoney</span>();</span><br><span class="line">        r1.flag = <span class="number">1</span>;</span><br><span class="line">        r2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;a的余额&quot;</span> + a.balance);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的余额&quot;</span> + b.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务实际上不在乎获取锁的顺序，调整获取锁的顺序，使先获取的账户是”转入”或”转出”无关，而是使<strong>用HashCode的值来决定顺序</strong>，从而保证线程安全。但依然有极小的概率会发生HashCode相同的情况，在实际生产中，需要排序的往往是一个实体类，而一个实体类一般都会具有主键ID，<strong>主键ID具有唯一、不重复的特点</strong>，直接使用主键ID排序，按照主键ID的大小来决定获取锁的顺序，以确保避免死锁。</p>
</li>
<li><p><strong>检测与恢复策略</strong></p>
<p>先允许系统发生死锁，然后再解除。例如系统可以在每次调用锁的时候，都记录下来调用信息，形成一个”锁的调用链图”，然后隔一段时间就用死锁检测算法来检测一下，搜索这个图中是否存在环路，一旦发生死锁，就可以用死锁恢复机制，解开死锁，进行恢复。</p>
<ol>
<li><p>线程终止</p>
<p>系统逐个去终止已经陷入死锁的线程，线程被终止，同时释放资源，死锁就会被解开。有各种各样的算法和策略，根据实际业务进行调整。</p>
<ul>
<li><p>优先级</p>
<p>先终止优先级低的线程。</p>
</li>
<li><p>已占用资源、还需要的资源</p>
<p>如果某线程已经占有了一大堆资源，只需要最后一点点资源就可以顺利完成任务，那么系统会优先终止别的线程来优先促成该线程的完成。</p>
</li>
<li><p>已经运行时间</p>
<p>如果某线程已经运行很多天了，很快就要完成任务了，可以让那些刚刚开始运行的线程终止，并在之后把它们重新启动，这样成本更低。</p>
</li>
</ul>
</li>
<li><p>资源抢占</p>
<p>不需要把整个线程终止，而是只需要把它已经获得的资源进行剥夺，如让线程回退几步、释放资源，这样就不需要终止掉整个线程，成本更低。但如果算法不好的话，我们抢占的那个线程可能一直是同一个线程，就会造成饥饿线程，即这个线程一直被剥夺它已经得到的资源，那么它就长期得不到运行。</p>
</li>
</ol>
</li>
<li><p>鸵鸟策略</p>
<p>如果系统发生死锁的概率极低，并且一旦发生其后果不是特别严重，可以先选择忽略它，直到发生死锁后，再人工修复。</p>
</li>
</ul>
<h3 id="12-final关键字"><a href="#12-final关键字" class="headerlink" title="12.final关键字"></a>12.final关键字</h3><h4 id="12-1-final的三种用法"><a href="#12-1-final的三种用法" class="headerlink" title="12.1 final的三种用法"></a>12.1 final的三种用法</h4><p><strong>final修饰变量</strong></p>
<p>final修饰的变量，<strong>一旦被赋值就不能被修改了</strong>。</p>
<p>目的：1.设计角度    2.线程安全</p>
<p>赋值时机：</p>
<ul>
<li><p>成员变量，类中的非static修饰的属性</p>
<ol>
<li><p>在变量的等号右边直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalFieldAssignment1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造函数中赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalFieldAssignment2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> finalVar;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalFieldAssignment2</span><span class="params">()</span> &#123;</span><br><span class="line">        finalVar = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的构造代码块中赋值(不常用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalFieldAssignment3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> finalVar;</span><br><span class="line">    &#123;</span><br><span class="line">        finalVar = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>静态变量，类中的被static修饰的属性</p>
<ol>
<li><p>在声明变量的等号右边直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldAssignment1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个静态的static初始代码块中赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticFieldAssignment2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>static的final变量不能在构造函数中进行赋值</strong></p>
</li>
<li><p>局部变量，方法中的变量</p>
<p>使用前赋值即可</p>
</li>
</ul>
<p>final修饰参数，意味着在方法内部无法对参数进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalPara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withFinal</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//可以读取final参数的值</span></span><br><span class="line"><span class="comment">//        a = 9; //编译错误，不允许修改final参数的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final修饰方法</strong></p>
<ol>
<li>提高效率，早期的Java版本，会把final修饰的方法转为内嵌调用，消除方法调用的开销。</li>
<li><strong>final修饰的方法不可以被重写</strong>。</li>
</ol>
<p>final的private方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateFinalMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">privateEat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass2</span> <span class="keyword">extends</span> <span class="title class_">PrivateFinalMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">privateEat</span><span class="params">()</span> &#123;<span class="comment">//编译通过，但这并不是真正的重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的所有private方法都是隐式的指定为自动被final修饰的，由于这个方法是private类型的，所以对于子类而言，根本获取不到父类这个方法，更别说重写了。所以其实子类并没有真正意义上的去重写父类的privateEat方法，只是方法名碰巧一样而已。</p>
<p><strong>final修饰类</strong></p>
<p><strong>final修饰的类不可被继承</strong></p>
<p>类是final的，不代表里面的属性就会自动加上final。</p>
<p>final的类里面，所有的方法，不论是public、private还是其他权限修饰符修饰的，都会自动的、隐式的被指定为是final的。</p>
<h4 id="12-2-为什么加了final却依然无法拥有”不变性”？"><a href="#12-2-为什么加了final却依然无法拥有”不变性”？" class="headerlink" title="12.2 为什么加了final却依然无法拥有”不变性”？"></a>12.2 为什么加了final却依然无法拥有”不变性”？</h4><p>如果对象在被创建之后，其状态就不能修改了，那么它就具备”不变性”。</p>
<p><strong>final修饰对象时，只是引用不可变。</strong>当用final去修饰一个指向对象类型(而不是指向8种基本数据类型)的变量的时候，那么final起到的作用只是保证则个变量的引用不可变，而对象本身的内容依然是可变化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123; </span><br><span class="line">       <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">       t.p = <span class="number">30</span>; </span><br><span class="line">       System.out.println(t.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">//  注意，数组 arr 是 final 的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           arr[i] = arr[i]*<span class="number">10</span>;</span><br><span class="line">           System.out.println(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>final修饰一个指向对象的变量的时候，对象本身的内容依然是可以变化的。</p>
<p><strong>final和不可变的关系</strong></p>
<p>final可以确保变量的引用保持不变，但是不变性意味着对象一旦创建完毕就不能改变其状态，<strong>它强调的是对象内容本身，而不是引用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; lessons = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        lessons.add(<span class="string">&quot;第01讲：为何说只有 1 种实现线程的方法？&quot;</span>);</span><br><span class="line">        lessons.add(<span class="string">&quot;第02讲：如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？&quot;</span>);</span><br><span class="line">        lessons.add(<span class="string">&quot;第03讲：线程是如何在 6 种状态之间转换的？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLesson</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lessons.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含对象类型的成员变量的类的对象，具备不可变性的例子：对于ImmutableDemo类而言，它只有这么一个成员变量，而这个成员变量一旦构造完毕后又不能改变。</p>
<h4 id="12-3-为什么String被设计为是不可变的？"><a href="#12-3-为什么String被设计为是不可变的？" class="headerlink" title="12.3 为什么String被设计为是不可变的？"></a>12.3 为什么String被设计为是不可变的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;la&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">lagou</span> <span class="operator">=</span> <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line">lagou = lagou.subString(<span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>只不是建了一个新的字符串而已，并把引用重新指向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private final的char数组value，存储着字符串的每一位字符，value一旦被赋值，引用就不能修改了；并且在String的源码中，除构造函数之外，并没有任何其他方法会修改value数组里面的内容，而value的权限是private，外部的类也访问不到，所以value是不可变的。String类是被final修饰的，所以这个String类是不会被继承的。</p>
<p><strong>String不变的好处</strong></p>
<ol>
<li><p>字符串常量池</p>
</li>
<li><p>用作HashMap的key</p>
<p>对于key来说，最重要的就是不可变，这样才能利用它去检索存储在HashMap里面的value。由于HashMap的工作原理是Hash，也就是散列，所以需要对象始终拥有相同的Hash值才能正常运行。</p>
</li>
<li><p>缓存HashCode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the String */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;</span><br></pre></td></tr></table></figure>

<p>在String类中有一个hash属性，保存的是String对象的HashCode。因为String是不可变的，所以对象一旦被创建之后，HashCode的值也就不可能变化了，就可以把HashCode缓存起来。以后每次想用到HashCode的时候，不需要重新计算，直接返回缓存过的hash的值就可以了，所以使得字符串非常适合用作HashMap的key。</p>
</li>
<li><p>线程安全</p>
<p>线程安全，具备不变性的对象一定是线程安全的，避免了很多不必要的同步操作。</p>
</li>
</ol>
<h3 id="13-AQS"><a href="#13-AQS" class="headerlink" title="13.AQS"></a>13.AQS</h3><h4 id="13-1-为什么需要AQS"><a href="#13-1-为什么需要AQS" class="headerlink" title="13.1 为什么需要AQS?"></a>13.1 为什么需要AQS?</h4><p><img data-src="/../../../../assets/img/02021203223.png"></p>
<p>AQS在ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、ThreadPoolExcutor中都有运用(JDK1.8)，AQS是这些类的底层原理。</p>
<p>AQS是一个用于构建锁、同步器等线程协作工具类的框架，有了AQS之后，可以让更上层的开发极大的减少工作量，避免重复造轮子，同时也避免了上层因处理不当而导致的线程安全问题，因为AQS把这些事情都做好了。总之，有了AQS之后，构建线程协作工具类就容易多了。</p>
<h4 id="13-2-AQS内部原理"><a href="#13-2-AQS内部原理" class="headerlink" title="13.2 AQS内部原理"></a>13.2 AQS内部原理</h4><p><strong>状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>state的含义并不是一成不变的，它会根据具体实现类的作用不同而表示不同的含义。</p>
<p>比如在信号量里，state表示的是剩余许可证的数量。当某一个线程衢州一个许可证之后，state会减1。</p>
<p>在CountDownLatch工具类里，state表示的是需要”倒数”的数量。每次调用CountDown方法时，state就会减1，直到减为0就代表这个”门闩”被放开。</p>
<p>在ReentrantLock中表示的是锁的占有情况。最开始是0，表示没有任何线程占有锁，如果state变成1，就代表这个锁已经被某一个线程所持有了。因为ReentrantLock是可重入的，同一个线程可以再次拥有这把锁就叫重入。如果这个锁被同一个线程多次获取，那么state就会逐渐的往上加，state的值表示重入的次数。在释放的时候也是逐步递减。</p>
<p>compareAndSetState：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用了Unsafe里面的CAS操作，利用CPU指令的原子性保证了这个操作的原子性。</p>
<p>setState：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于基本类型的变量进行直接赋值时，如果加了volatile就可以保证它的线程安全。</p>
<p><strong>FIFO队列</strong></p>
<p>先进先出队列，主要的作用是存储等待的线程。当多个线程去竞争同一把锁的时候，就需要用排队机制把那些没拿到锁的线程串在一起；而当前面的线程释放锁之后，这个管理器就会挑选一个合适的线程来尝试抢刚刚释放的那把锁。</p>
<p>队列内部是双向链表的形式：</p>
<p><img data-src="/../../../../assets/img/Ciqc1F6pW3CAHYjKAACSEPDrUoc078.png"></p>
<p>在队列中，分别用head和tail来表示头节点和尾节点，两者在初始化的时候指向一个空节点。头节点可以理解为”当前持有锁的线程”，而在头节点之后的线程被阻塞了，它们会等待被唤醒，唤醒也是由AQS负责操作的。</p>
<p><strong>获取&#x2F;释放方法</strong></p>
<ul>
<li><p>获取方法</p>
<p>获取操作通常会依赖state变量的值，获取方法在不同类中代表不同的含义，但往往和state值相关，也经常会让线程进入阻塞状态。</p>
<p>如ReentrantLock中的lock方法，执行时如果发现state不等于0且当前线程不是持有锁的线程，那么就代表这个锁已经被其他线程所持有了，这个时候，当然获取不到锁，于是就让该线程进入阻塞状态。</p>
<p>Semaphore中的acquire，作用是获取许可证。如果state是正数，那么代表还有剩余的许可证，数量足够就可以获取成功；但如果state是0，则代表已经没有更多的空余许可证了，会进入阻塞状态。</p>
<p>CountDownLatch获取方法就是await方法，作用是”等待，直到倒数结束”。执行await的时候会判断state的值，如果state不等于0，线程就进入阻塞状态，直到其他线程执行倒数方法把state减为0，此时就代表这个门闩放开了，所以之前阻塞的线程就会被唤醒。</p>
</li>
<li><p>释放方法</p>
<p>释放方法通常是不会阻塞线程的。</p>
<p>比如在Semaphore信号量，释放就是release方法，release()方法的作用是去释放一个许可证，会让state加1；而在CountDownLatch里面，释放就是countDown方法，作用是倒数一个数，让state减1。</p>
</li>
</ul>
<h4 id="13-3-AQS在CountDownLatch中应用原理"><a href="#13-3-AQS在CountDownLatch中应用原理" class="headerlink" title="13.3 AQS在CountDownLatch中应用原理"></a>13.3 AQS在CountDownLatch中应用原理</h4><p><strong>AQS用法</strong></p>
<ol>
<li>新建一个自己的线程协作工具类，在内部写一个Sync类，该类继承AbstractQueueSynchronizer，即AQS。</li>
<li>在Sync类中，根据是否是独占来重写对应的方法。独占，则重写tryAcquire和tryRelease等方法；非独占，则重写tryAcquireShared和tryReleaseShared等方法。</li>
<li>在自己的线程协作工具类中，实现获取&#x2F;释放的相关方法，并在里面调用AQS对应的方法，独占调用acquire或release等方法；非独占调用acquireShared或releaseShared或acquireSharedInterruptibly。</li>
</ol>
<p><strong>AQS在CountDownLatch的应用</strong></p>
<p>在CountDownLatch里面有一个子类Sync，这个类正是继承自AQS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatch</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch.</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">   <span class="comment">//省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CountDown构造函数将传入的count最终传递到AQS内部的state变量，给state赋值，state就代表还需要倒数的次数。</p>
<p>getCount：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终获取到的就是Sync中state的值。</p>
<p>countDown：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync中的tryReleaseShared()，doReleaseShared()对之前阻塞的线程进行唤醒。</p>
<p>await：</p>
<p>该方法时CountDownLatch的”获取”方法，调用await会把线程阻塞，直到倒数为0才能继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync中的tryAcquireShared()，doAcquireSharedInterruptibly()会让线程进入阻塞状态。</p>
<p><strong>总结</strong></p>
<p>当线程调用CountDownLatch的await方法时，便会尝试获取”共享锁”，不过一开始通常获取不到锁，于是线程被阻塞。”共享锁”可以获取到的条件是”锁计数器”的值为0，而”锁计数器”的初始值为count，当每次调用CountDownLatch对象的countDown方法时，也可以把”锁计数器”-1。直到”锁计数器”为0，于是之前等待的线程就会继续运行了，并且此时如果再有线程想调用await方法时也会立刻放行，不会再去做任何阻塞操作了。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>请作者喝瓶肥宅快乐水</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/img/vxpay.jpg" alt="ImOkkkk 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/img/alipay.jpg" alt="ImOkkkk 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/docker/" rel="prev" title="Docker+Kubernetes">
      <i class="fa fa-chevron-left"></i> Docker+Kubernetes
    </a></div>
      <div class="post-nav-item">
    <a href="/jvmAndgc/" rel="next" title="JVM&垃圾回收">
      JVM&垃圾回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-text">1.多线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">1.1 实现多线程的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%AF%94%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="nav-text">1.2 实现Runnable接口比继承Thread类实现线程更好？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">1.3 如何正确停止线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-sleep%E6%9C%9F%E9%97%B4%E8%83%BD%E5%90%A6%E6%84%9F%E5%8F%97%E5%88%B0%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-text">1.4 sleep期间能否感受到中断？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8volatile%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%81%9C%E6%AD%A2%E6%96%B9%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="nav-text">1.5 为什么用volatile标记位的停止方法是错误的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A86%E7%A7%8D%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%EF%BC%9F"><span class="nav-text">1.6 线程是如何在6种状态之间转换的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%BF%85%E9%A1%BB%E5%9C%A8synchronized%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">1.7 为什么wait必须在synchronized保护的同步代码中使用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-%E4%B8%BA%E4%BB%80%E4%B9%88wait-notify-notifyAll%E6%96%B9%E6%B3%95%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8Object%E7%B1%BB%E4%B8%AD%EF%BC%8C%E8%80%8Csleep%E5%AE%9A%E4%B9%89%E5%9C%A8Thread%E7%B1%BB%E4%B8%AD%EF%BC%9F"><span class="nav-text">1.8 为什么wait&#x2F;notify&#x2F;notifyAll方法被定义在Object类中，而sleep定义在Thread类中？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-wait-notify%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-text">1.9 wait&#x2F;notify和sleep方法的异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">2.线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-text">2.1 3种典型的线程安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E6%B3%A8%E6%84%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">2.2 需要额外注意线程安全的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%B8%A6%E6%9D%A5%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-text">2.3 为什么多线程会带来性能问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">2.4 使用线程池的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">2.5 线程池各参数的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-text">2.6 线程池有哪几种拒绝策略？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-%E6%9C%89%E5%93%AA6%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJava8%E7%9A%84ForkJoinPool"><span class="nav-text">2.7 有哪6种常见的线程池？什么是Java8的ForkJoinPool?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">2.8 线程池常用的阻塞队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BA%94%E8%AF%A5%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">2.9 为什么不应该自动创建线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-%E5%90%88%E9%80%82%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-text">2.10 合适的线程数是多少？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-11-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">2.11 如何正确关闭线程？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E2%80%9D%E9%94%81%E2%80%9D"><span class="nav-text">3.各种各样的”锁”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E9%94%81%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-text">3.1 你知道哪几种锁？分别有什么特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-text">3.2 悲观锁与乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-synchronized%E8%83%8C%E5%90%8E%E7%9A%84monitor%E9%94%81"><span class="nav-text">3.3 synchronized背后的monitor锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-synchronized%E4%B8%8ELock"><span class="nav-text">3.4 synchronized与Lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-Lock%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">3.5 Lock的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-text">3.6 公平锁与非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-text">3.7 读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-%E8%AF%BB%E9%94%81%E5%BA%94%E8%AF%A5%E6%8F%92%E9%98%9F%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8D%87%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="nav-text">3.8 读锁应该插队么？什么是读写锁的升降级？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-text">3.9 自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-JVM%E5%AF%B9%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text">3.10 JVM对锁的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-10-HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">3.10 HashMap为什么是线程不安全的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-11-%E4%B8%BA%E4%BB%80%E4%B9%88Map%E6%A1%B6%E4%B8%AD%E8%B6%85%E8%BF%878%E4%B8%AA%E6%89%8D%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-text">3.11 为什么Map桶中超过8个才转为红黑树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-12-Hashtable%E4%B8%8EConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.12 Hashtable与ConcurrentHashMap的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-13-CopyOnWriteArrayList"><span class="nav-text">3.13 CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">4.阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">4.1 什么是阻塞队列？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E7%95%8C-%E5%AE%B9%E9%87%8F%E6%9C%89%E5%A4%9A%E5%A4%A7"><span class="nav-text">是否有界(容量有多大)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">4.2 阻塞队列常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-text">4.3 几种常见的阻塞队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86"><span class="nav-text">4.4 阻塞队列和非阻塞队列的并发安全原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">4.5 如何选择合适的阻塞队列？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">5.原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8CAS%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">5.1 原子类如何利用CAS保证线程安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-AtomicInteger%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A5%BD%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5.2 AtomicInteger在高并发下性能不好，如何解决？为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B8%8Evolatile"><span class="nav-text">5.3 原子类与volatile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-Adder%E4%B8%8EAccumlator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.4 Adder与Accumlator的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ThreadLocal"><span class="nav-text">6.ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-ThreadLocal%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.1 ThreadLocal适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-ThreadLocal%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-text">6.2 ThreadLocal是用来解决共享资源的多线程访问的问题吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-ThreadLocal%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">6.3 ThreadLocal的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-%E4%B8%BA%E4%BD%95%E6%AF%8F%E6%AC%A1%E7%94%A8%E5%AE%8C-ThreadLocal-%E9%83%BD%E8%A6%81%E8%B0%83%E7%94%A8-remove-%EF%BC%9F"><span class="nav-text">6.4 为何每次用完 ThreadLocal 都要调用 remove()？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Future"><span class="nav-text">7.Future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-Callable%E5%92%8CRunnable%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-text">7.1 Callable和Runnable的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-Future%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-text">7.2 Future的主要功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-Future%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">7.3 Future注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-CountDownLatch%E3%80%81Completable"><span class="nav-text">7.4 CountDownLatch、Completable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C"><span class="nav-text">8.线程协作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">8.1 信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-CountDownLatch-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%89%E6%8E%92%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="nav-text">8.2 CountDownLatch 是如何安排线程执行顺序的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-CyclicBarrier%E5%92%8CCountdownLatch"><span class="nav-text">8.3 CyclicBarrier和CountdownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-Condition%E3%80%81object%E9%83%BDwait-%E4%BD%95notify-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">8.4 Condition、object都wait()何notify()的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">9.Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-text">9.1 什么是Java内存模型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-text">9.2 什么是指令重排序？为什么要进行重排序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="nav-text">9.3 Java中的原子操作有哪些注意事项？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">9.4 什么是内存可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-5-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">9.5 主内存与工作内存的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-6-%E4%BB%80%E4%B9%88%E6%98%AFhappens-before%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-text">9.6 什么是happens-before规则？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-volatile%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8Esynchronized%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-text">9.7 volatile的作用是什么？与synchronized有什么异同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-8-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E5%8A%A0volatile%EF%BC%9F"><span class="nav-text">9.8 单例模式的双重检查锁模式为什么必须加volatile？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-CAS"><span class="nav-text">10.CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="nav-text">10.1 什么是CAS?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-CAS%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">10.2 CAS的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-CAS%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">10.3 CAS有什么缺点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-text">11.死锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-1-%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%85%E7%84%B6%E6%AD%BB%E9%94%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">11.1 写一个必然死锁的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-text">11.2 发生死锁的4个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">11.3 如何定位死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%AD%96%E7%95%A5"><span class="nav-text">11.4 解决死锁问题的策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">12.final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-1-final%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="nav-text">12.1 final的三种用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E4%BA%86final%E5%8D%B4%E4%BE%9D%E7%84%B6%E6%97%A0%E6%B3%95%E6%8B%A5%E6%9C%89%E2%80%9D%E4%B8%8D%E5%8F%98%E6%80%A7%E2%80%9D%EF%BC%9F"><span class="nav-text">12.2 为什么加了final却依然无法拥有”不变性”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-%E4%B8%BA%E4%BB%80%E4%B9%88String%E8%A2%AB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="nav-text">12.3 为什么String被设计为是不可变的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-AQS"><span class="nav-text">13.AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AQS"><span class="nav-text">13.1 为什么需要AQS?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-2-AQS%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="nav-text">13.2 AQS内部原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-3-AQS%E5%9C%A8CountDownLatch%E4%B8%AD%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86"><span class="nav-text">13.3 AQS在CountDownLatch中应用原理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ImOkkkk"
      src="/../assets/img/head.jpg">
  <p class="site-author-name" itemprop="name">ImOkkkk</p>
  <div class="site-description" itemprop="description">Java开发, 后端开发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vNjA2MjE3MjIyNC8=" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;6062172224&#x2F;"><i class="fab fa-weibo fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvbnltdWE=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tonymua"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx3eTA4YUBmb3htYWlsLmNvbQ==" title="E-Mail → mailto:lwy08a@foxmail.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <a href="https://beian.miit.gov.cn/" target="_blank">皖ICP备19022525号-1</a>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImOkkkk</span>
</div><script color="0,137,108" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imokkkk.github.io/multithreading/',]
      });
      });
  </script>

</body>
</html>
