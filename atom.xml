<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ImOkkkk BLOG</title>
  <icon>https://www.gravatar.com/avatar/5503d12b09e32d800cc45af49aa8ef7c</icon>
  <subtitle>When they go low,we go high.</subtitle>
  <link href="https://imokkkk.github.io/atom.xml" rel="self"/>
  
  <link href="https://imokkkk.github.io/"/>
  <updated>2023-02-03T08:12:27.098Z</updated>
  <id>https://imokkkk.github.io/</id>
  
  <author>
    <name>ImOkkkk</name>
    <email>547717253@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络与网络编程</title>
    <link href="https://imokkkk.github.io/65346/"/>
    <id>https://imokkkk.github.io/65346/</id>
    <published>2024-02-24T01:58:27.040Z</published>
    <updated>2023-02-03T08:12:27.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1.软件结构"></a>1.软件结构</h3><h4 id="1-1-C-S结构"><a href="#1-1-C-S结构" class="headerlink" title="1.1 C&#x2F;S结构"></a>1.1 C&#x2F;S结构</h4><p>全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。<br><img data-src="/../../../../assets/img/1_cs.jpg"></p><h4 id="1-2-B-S结构"><a href="#1-2-B-S结构" class="headerlink" title="1.2 B&#x2F;S结构"></a>1.2 B&#x2F;S结构</h4><p>全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><span id="more"></span><p><img data-src="/../../../../assets/img/2_bs.jpg"><br>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h3 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2.网络通信协议"></a>2.网络通信协议</h3><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li><strong>TCP&#x2F;IP协议：</strong> 传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<br><img data-src="/../../../../assets/img/3_tcp_ip.jpg"><br>上图中，TCP&#x2F;IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP&#x2F;IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li><li><strong>OSI七层模型:</strong><br>  应用层负责对软件提供接口时程序能使用网络服务<br>  表示层应用程序和网络之间的翻译官<br>  会话层负责在网络中的两节点之间建立和维持通信<br>  传输层建立端到端之间的连接，数据的分段和重组<br>  网络层将网络地址翻译成对应的mac地址，指导数据包的转发<br>  数据链路层将网络层接收到的数据包封装为特定的数据帧，使其在不可靠的物理链路上进行可靠的数据传递<br>  物理层建立、维护、断开物理连接。（由底层网络定义协议）</li></ul><h3 id="3-UDP与TCP协议"><a href="#3-UDP与TCP协议" class="headerlink" title="3.UDP与TCP协议"></a>3.UDP与TCP协议</h3><h4 id="3-1-UDP协议"><a href="#3-1-UDP协议" class="headerlink" title="3.1 UDP协议"></a>3.1 UDP协议</h4><p>​UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。<br><img data-src="/../../../../assets/img/106209.png"></p><h4 id="3-2-TCP协议"><a href="#3-2-TCP协议" class="headerlink" title="3.2 TCP协议"></a>3.2 TCP协议</h4><p>​TCP协议是<strong>面向连接</strong>的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。每次连接的创建都需要经过“三次握手”。</p><ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认 </li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 </li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示<br><img data-src="/../../../../assets/img/403168.png"><br>由于TCP协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。</li></ul><h3 id="4-相关面试题"><a href="#4-相关面试题" class="headerlink" title="4.相关面试题"></a>4.相关面试题</h3><ol><li>TCP断开连接的四次挥手<br>第一次挥手：客户端发送一个FIN包（seq&#x3D;x），进入FIN_WAIT（结束等待）状态<br>第二次挥手：服务器收到FIN包，发回一个ACK包(ack&#x3D;x+1)，进入CLOSE_WAIT（关闭等待）状态<br>第三次挥手：服务器关闭客户端的连接，并发送一个FIN包(seq&#x3D;y)，进入LAST_ACK（最后确认）状态<br>第四次挥手：客户端发回ACK(ack&#x3D;y+1)包确认，发送完毕后，连接断开<br><img data-src="/../../../../assets/img/70830403.png"></li><li>需要三次握手的原因<br><strong>为了防止失效的连接请求报文突然又传送到服务器产生错误</strong>。假如不三次握手，客户端发送连接确认给服务端就立即建立连接，如果有个连接请求阻塞了很久才到服务端，而此时本来已经关闭了连接的又重新建立了连接，然而等了很久都没有数据发送，这就会白白浪费资源</li><li>Http协议与Https协议</li></ol><ul><li>Http协议即<strong>超文本传输协议</strong>，是一种<strong>基于TCP的应用层协议</strong>，还是一种<strong>无状态协议</strong>。用于服务器和客户端的<strong>数据传输</strong>，客户端和服务器使用<strong>URL</strong>来建立连接和传输数据。客户端发送Http请求给服务器，服务器根据请求返回Html、文本或多媒体文件给客户端</li><li>Https协议是一种安全的Http协议。Http协议是一种明文传输的协议，存在被窃听，信息篡改等安全隐患，在Http协议的基础上加入了SSL或TLS协议，实现了数据的加密传输。因为加上了加密的协议，所以Https的响应速度会比Http慢很多。并不是所有情况下都需要使用Https协议，对于隐私的，重要的信息最好用Https协议，不重要的或者可以公开的信息就没有必要用Https协议</li></ul><ol start="4"><li>Http请求报文和响应报文</li></ol><ul><li>请求报文包括请求行，请求头，空行和请求体（GET请求没有请求体）</li><li>响应报文包括状态行，响应头，空行和响应体</li></ul><ol start="5"><li>Http请求常见状态码</li></ol><ul><li>200 OK，请求成功</li><li>404 Not Found，对应的URL上不存在资源</li><li>405 Method Not Allowed，请求不被允许，即请求方式错误</li><li>500 Internal Server Error，服务器内部错误，发现严重BUG，要及时修复</li></ul><ol start="6"><li>GET请求与POST请求的区别</li></ol><ul><li>GET请求一般用于<strong>获取</strong>服务器上的资源，是<strong>幂等</strong>的。POST请求一般用于对服务器上资源进行<strong>更新</strong>，<strong>非幂等</strong>的（幂等即每次请求返回结果一样）</li><li>GET请求没有请求体，<strong>请求参数跟是在URL后面</strong>的，所以使用GET请求时请求参数用户是可以直接看到的。POST请求有请求体，<strong>请求参数放在请求体</strong>，对用户是不可见的。相对来说POST请求比GET请求更安全</li><li>GET请求的参数<strong>长度有限制</strong>，这是因为URL长度有限导致的。POST请求的参数长度可以认为是<strong>无限制</strong>的</li></ul><ol start="7"><li>TCP 和 UDP的区别</li></ol><ul><li>TCP是一种<strong>面向连接的可靠</strong>传输协议，UDP是<strong>面向无连接的不可靠</strong>传输协议</li><li>TCP支持报文传输，还支持<strong>字节流</strong>的传输。而UDP协议只支持传输报文</li><li>TCP<strong>数据报格式比较复杂</strong>，传输过程数据不容易丢失和出错，而UDP<strong>数据报格式较为简单</strong>，容易丢失</li><li>TCP传输在接收端会进行重排，所以是<strong>有序</strong>的，UDP则<strong>不保证有序</strong></li><li>TCP<strong>速度慢</strong>，UDP<strong>速度快</strong></li><li>TCP有<strong>流量控制和拥塞控制</strong>，而UDP没有</li></ul><ol start="8"><li>应用层协议有哪些</li></ol><ul><li>DNS协议，域名解析系统。基于TCP和UDP的协议，通过DNS可以将域名转换成IP地址</li><li>SMTP协议，电子邮件协议。基于TCP的协议，通过SMTP协议可以发送电子邮件，SMTP通信的过程建立连接、邮件传送、连接释放</li><li>Telnet协议，远程终端协议。基于TCP的协议，通过Telnet协议可以对远程的终端进行控制</li><li>Http协议，超文本传输协议。基于TCP的协议，通过Http协议实现客户端和服务端的数据传输</li><li>FTP协议，文件传输协议。基于TCP的协议，通过FTP协议达到相互传输文件的效果</li></ul><ol start="9"><li>OSI参考模型与TCP&#x2F;IP参考模型<br>(1) OSI参考模型由7层组成：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>(2) TCP&#x2F;IP参考模型由4层组成：主机-网络层、网际层、传输层、应用层<br>(3) 对应关系中，OSI参考模型的物理层、数据链路层对应TCP&#x2F;IP的主机-网络层，网络层对应网际层，传输层对应传输层，会话层、表示层、应用层对应应用层</li><li>cookie 和 session的区别<br>(1) cookie由于把信息保存在客户端中。session把信息保存在服务器中<br>(2) cookie性能更高一点，速度较快，用户的信息存在各自的浏览器中，可以分担服务器的一部分存储工作。session速度较慢，所有用户的信息都存在服务器中，在高并发时必然影响服务器性能<br>(3) cookie有限制大小，在4K以内。session没有限制<br>(4) cookie对用户是透明的，安全性低，不重要的或者可以公开的信息保存在cookie。session对用户是不可见的，安全性高，重要信息应该保存在session</li><li>forward 和 redirect的区别<br>(1) forward为转发，进行forward操作后，请求URL不发生变化，并且会把请求的数据携带到下一个请求中。redirect是重定向，进行redirect操作后，请求URL是发生变化的<br>(2) forward是服务器内部请求转发，不可以请求到其它站点，redirect是服务器通知客户端重新请求，可以请求到其它站点<br>(3) forward速度快，redirect速度慢</li><li>DNS劫持和DNS污染<br>(1) DNS劫持：指用户访问一个域名时，DNS服务器故意将此地址指向一个错误的IP地址的行为。比如进入一个网站显示的却是另外一个网站的内容<br>(2) DNS污染：指用户访问一个域名时，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如国内不能访问Google、YouTube等</li></ol><h3 id="5-TCP通信程序"><a href="#5-TCP通信程序" class="headerlink" title="5.TCP通信程序"></a>5.TCP通信程序</h3><h4 id="5-1-简单的TCP网络程序"><a href="#5-1-简单的TCP网络程序" class="headerlink" title="5.1 简单的TCP网络程序"></a>5.1 简单的TCP网络程序</h4><p><strong>TCP通信分析图解</strong></p><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。<blockquote><p>到此，客户端向服务端发送数据成功。<br><img data-src="/../../../../assets/img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg"><br>自此，服务端向客户端回写数据。</p></blockquote></li><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。<br><strong>服务端实现：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>客户端实现：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-文件上传"><a href="#5-2-文件上传" class="headerlink" title="5.2 文件上传"></a>5.2 文件上传</h4><p><strong>文件上传分析图解</strong></p><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。<br><img data-src="/../../../../assets/img/6_upload2.jpg"><br><strong>服务端实现:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;back ........&quot;</span>);</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>客户端实现：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUpload_Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="type">byte</span>[] b  = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="type">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] back = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-软件结构&quot;&gt;&lt;a href=&quot;#1-软件结构&quot; class=&quot;headerlink&quot; title=&quot;1.软件结构&quot;&gt;&lt;/a&gt;1.软件结构&lt;/h3&gt;&lt;h4 id=&quot;1-1-C-S结构&quot;&gt;&lt;a href=&quot;#1-1-C-S结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 C&amp;#x2F;S结构&quot;&gt;&lt;/a&gt;1.1 C&amp;#x2F;S结构&lt;/h4&gt;&lt;p&gt;全称为Client&amp;#x2F;Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。&lt;br&gt;&lt;img data-src=&quot;/../../../../assets/img/1_cs.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-2-B-S结构&quot;&gt;&lt;a href=&quot;#1-2-B-S结构&quot; class=&quot;headerlink&quot; title=&quot;1.2 B&amp;#x2F;S结构&quot;&gt;&lt;/a&gt;1.2 B&amp;#x2F;S结构&lt;/h4&gt;&lt;p&gt;全称为Browser&amp;#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://imokkkk.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="javase" scheme="https://imokkkk.github.io/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>零拷贝</title>
    <link href="https://imokkkk.github.io/zerocopy/"/>
    <id>https://imokkkk.github.io/zerocopy/</id>
    <published>2024-02-24T01:58:27.040Z</published>
    <updated>2023-03-31T09:30:18.415Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h3><p>计算机操作时，CPU<strong>不需要先将数据从某处内存复制到另一个特定的区域</strong>，这种技术通常用于通过网络传输文件时<strong>节省CPU周期和内存带宽</strong>。</p><ol><li>零拷贝技术可以<strong>减少数据拷贝和共享总线操作的次数</strong>，从而提高数据传输的效率；</li><li>零拷贝技术减少了<strong>用户进程地址空间和内核地址空间</strong>之间因为上下文切换而带来的开销。</li></ol><p>并不是不需要拷贝，而是减少不必要的拷贝。</p><p>应用：Kafka、Netty、RocketMQ等。</p><span id="more"></span><h3 id="Linux的I-O机制与DMA"><a href="#Linux的I-O机制与DMA" class="headerlink" title="Linux的I&#x2F;O机制与DMA"></a>Linux的I&#x2F;O机制与DMA</h3><p>操作系统内存空间分为用户态和内核态，用户的应用程序无法直接操作硬件，需要通过内核空间进行操作转换，才能真正操作硬件。因此，<strong>应用程序需要与网卡、磁盘等硬件进行数据交互时，就需要在用户态和内核态之间来回复制数据。早期，这些操作由CPU负责，压力很大。</strong></p><p><strong>DMA(直接内存存取)控制器，接管了数据读写请求，减少CPU的负担。</strong></p><p>此时，IO读取，涉及两个过程：</p><ol><li>DMA等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li><li>用户进程，将内核缓冲区的数据copy到用户空间。</li></ol><h3 id="传统数据传送机制"><a href="#传统数据传送机制" class="headerlink" title="传统数据传送机制"></a>传统数据传送机制</h3><p>如：读取文件，再用socket发送出去，共2次DMA copy，2次CPU copy，4次上下文切换。</p><ol><li>用户进程调用read()，上下文从用户态转向内核态；</li><li>将磁盘文件，DMA copy到操作系统内核缓冲区；</li><li>将内核缓冲区的数据，CPU copy到应用程序的buffer，上下文从内核态转向用户态；</li><li>用户进程调用write()，上下文从用户态转向内核态；</li><li>将应用程序buffer中的数据，CPU copy到socket网络发送缓冲区(也属于操作系统内核缓冲区)；</li><li>将socket buffer中的数据，DMA copy到网卡，进行网络传输，上下文从内核态切换回用户态。</li></ol><p>read()、write()换属于系统调用，每次调用涉及2次上下文切换。</p><p><img data-src="https://pic-go-image.oss-cn-beijing.aliyuncs.com/pic/image-20230331153118197.png" alt="image-20230331153118197"></p><h3 id="Linux支持的零拷贝"><a href="#Linux支持的零拷贝" class="headerlink" title="Linux支持的零拷贝"></a>Linux支持的零拷贝</h3><h4 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a>mmap内存映射</h4><p><strong>直接将磁盘文件数据映射到内核缓冲区，这个映射的过程是基于 DMA 拷贝的，同时用户缓冲区是跟内核缓冲区共享一块映射数据的，建立共享映射之后，就不需要从内核缓冲区拷贝到用户缓冲区了。</strong>使用mmap代替read()，减少一次CPU拷贝，共2次DMA copy，1次CPU copy，4次上下文切换；</p><ol><li>用户进程调用mmap()，用户态转向内核态；</li><li>磁盘中的数据与应用程序buffer映射，基于DMA copy，内核态转向用户态；</li><li>用户进程调用write()，上下文从用户态转向内核态；</li><li>将应用程序buffer中的数据，CPU copy到socket网络发送缓冲区；</li><li>将socket buffer中的数据，DMA copy到网卡，进行网络传输，上下文从内核态转向用户态。</li></ol><p><img data-src="https://pic-go-image.oss-cn-beijing.aliyuncs.com/pic/image-20230331154214104.png" alt="image-20230331154214104"></p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>Linux从2.1支持sendfile</p><p>调用sendfile()时，DMA将磁盘数据复制到操作系统内核缓冲区，然后直接将内核buffer中的<strong>数据长度和描述符</strong>直接拷贝到socket buffer。如果设备支持，无需CPU拷贝。共1(或0)次CPU拷贝，2次DMA拷贝，2次上下文切换。</p><ol><li>用户进程调用sendfile()，上下文从用户态转向内核态；</li><li>将磁盘文件中的数据，DMA copy到操作系统内核缓冲区；</li><li>将内核buffer中数据的长度和描述符，CPUcopy到socket buffer；(设备支持的话，此次CPU copy可以省略)</li><li>将socket buffer中的数据，DMA copy到网卡，进行网络传输，从内核态转向用户态。</li></ol><p><img data-src="https://pic-go-image.oss-cn-beijing.aliyuncs.com/pic/image-20230331155825079.png" alt="image-20230331155825079"></p><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>Linux从2.6.17支持splice</p><p>数据从磁盘读取到操作系统内核缓冲区后，直接将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。</p><p><strong>从磁盘读取到内核 buffer 后，在内核空间直接与 socket buffer 建立 pipe管道</strong>。</p><p>与sendfile()的区别：</p><ol><li>send file 0 CPU copy需要硬件支持，splice()不需要</li></ol><p><img data-src="https://pic-go-image.oss-cn-beijing.aliyuncs.com/pic/image-20230331160122231.png" alt="image-20230331160122231"></p><h3 id="Java支持的零拷贝"><a href="#Java支持的零拷贝" class="headerlink" title="Java支持的零拷贝"></a>Java支持的零拷贝</h3><p>Java支持内存映射mmap、sendfile。</p><h4 id="NIO提供的内存映射MappedByteBuffer"><a href="#NIO提供的内存映射MappedByteBuffer" class="headerlink" title="NIO提供的内存映射MappedByteBuffer"></a>NIO提供的内存映射MappedByteBuffer</h4><p>NIO中的FileChanel.map()采用了内存映射方式，底层就是调用Linux mmap()实现的。</p><p>适合读取大文件，同时也能对文件内容进行更改。</p><h4 id="NIO-提供的-sendfile"><a href="#NIO-提供的-sendfile" class="headerlink" title="NIO 提供的 sendfile"></a>NIO 提供的 sendfile</h4><p>Java NIO 中提供的 FileChannel 拥有 transferTo 和 transferFrom 两个方法，可直接把FileChannel 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel。该接口常被用于高效的网络 &#x2F;文件的数据传输和大文件拷贝。</p><h4 id="Kafka中的零拷贝"><a href="#Kafka中的零拷贝" class="headerlink" title="Kafka中的零拷贝"></a>Kafka中的零拷贝</h4><ol><li>Producer生产的数据持久化到broker，broker采用mmap文件映射，实现顺序的快速写入；</li><li>Consumer从broker读取数据，broker采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</li></ol><h4 id="Netty中的零拷贝"><a href="#Netty中的零拷贝" class="headerlink" title="Netty中的零拷贝"></a>Netty中的零拷贝</h4><ol><li><p>网络通信上，Netty接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果采用传统的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中，相对于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝；</p></li><li><p>缓存操作上，Netty提供了CompositeByteBuf类，可以将多个ByteBuffer合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝；</p><p>通过 wrap 操作，我们可以将 byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 NettyByteBuf 对象，进而避免了拷贝操作。<br>ByteBuf支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</p></li><li><p>文件传输上，Netty通过FileRegion包装的FileChannel.tranferTo实现文件传输，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是零拷贝？&quot;&gt;&lt;a href=&quot;#什么是零拷贝？&quot; class=&quot;headerlink&quot; title=&quot;什么是零拷贝？&quot;&gt;&lt;/a&gt;什么是零拷贝？&lt;/h3&gt;&lt;p&gt;计算机操作时，CPU&lt;strong&gt;不需要先将数据从某处内存复制到另一个特定的区域&lt;/strong&gt;，这种技术通常用于通过网络传输文件时&lt;strong&gt;节省CPU周期和内存带宽&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;零拷贝技术可以&lt;strong&gt;减少数据拷贝和共享总线操作的次数&lt;/strong&gt;，从而提高数据传输的效率；&lt;/li&gt;
&lt;li&gt;零拷贝技术减少了&lt;strong&gt;用户进程地址空间和内核地址空间&lt;/strong&gt;之间因为上下文切换而带来的开销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并不是不需要拷贝，而是减少不必要的拷贝。&lt;/p&gt;
&lt;p&gt;应用：Kafka、Netty、RocketMQ等。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://imokkkk.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Netty" scheme="https://imokkkk.github.io/tags/Netty/"/>
    
    <category term="Kafka" scheme="https://imokkkk.github.io/tags/Kafka/"/>
    
    <category term="NIO" scheme="https://imokkkk.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(五)部署项目到阿里云服务器</title>
    <link href="https://imokkkk.github.io/deployment/"/>
    <id>https://imokkkk.github.io/deployment/</id>
    <published>2024-02-24T01:58:27.025Z</published>
    <updated>2020-05-28T02:18:40.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul><li>可以正常运行提供服务的项目</li><li>一台云服务器</li></ul><h3 id="2-项目打包"><a href="#2-项目打包" class="headerlink" title="2.项目打包"></a>2.项目打包</h3><p>首先将我们在IDEA下的项目进行打包，这边基于的是maven项目的打包。<br>点击菜单栏 File → Project Structure → Artifacts 添加一个jar</p><span id="more"></span><p><img data-src="/../../../../assets/img/212549.jpg"></p><p>之后，对添加的jar进行配置<br><img data-src="/../../../../assets/img/212555.jpg"></p><p>点击右侧竖排菜单栏的maven project 然后点开Lifecycle，先clean再package，注意在打包之前，要将项目的启动端口号改为80，8080端口是本机端口，不适用于服务器。</p><p><img data-src="/../../../../assets/img/213308.jpg"></p><p>当下方控制器显示BUILD SUCCESS时说明打包成功<br><img data-src="/../../../../assets/img/213558.jpg"></p><p>这时候我们可以在项目的文件目录下看到多了个target目录，点开目录移动到最下方我们可以看到项目jar包,我们可以从电脑磁盘中将放置该项目的文件夹打开并找到该项目文件。<br><img data-src="/../../../../assets/img/213739.jpg"><br><img data-src="/../../../../assets/img/213759.jpg"></p><h3 id="3-导入服务器"><a href="#3-导入服务器" class="headerlink" title="3.导入服务器"></a>3.导入服务器</h3><p>使用FTP工具负责构建完成的项目jar包到云服务器<br><img data-src="/../../../../assets/img/214254.jpg"></p><h3 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h3><h4 id="4-1-配置Java运行环境"><a href="#4-1-配置Java运行环境" class="headerlink" title="4.1 配置Java运行环境"></a>4.1 配置Java运行环境</h4><ol><li><p>查看yum库中的Java安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y list java*</span><br></pre></td></tr></table></figure><p>以yum库中java-1.8.0为例, “*”表示将java-1.8.0的所有相关Java程序都安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功<br>输入  <code>java -version</code>  <code>javac</code><br><img data-src="/../../../../assets/img/214925.jpg"></p></li></ol><h4 id="4-2-启动项目"><a href="#4-2-启动项目" class="headerlink" title="4.2 启动项目"></a>4.2 启动项目</h4><p>查询一下80端口是否已开放，开放了80端口后我们就可以启动我们的项目了，通过输入指令：<br>Java -jar [jar包的完整文件名(.jar别忘了加)] 如下图所示。这样我们的项目就开始启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar WeChat-1.0-SNAPSHOT.jar </span><br></pre></td></tr></table></figure><p><img data-src="/../../../../assets/img/214926.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以正常运行提供服务的项目&lt;/li&gt;
&lt;li&gt;一台云服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-项目打包&quot;&gt;&lt;a href=&quot;#2-项目打包&quot; class=&quot;headerlink&quot; title=&quot;2.项目打包&quot;&gt;&lt;/a&gt;2.项目打包&lt;/h3&gt;&lt;p&gt;首先将我们在IDEA下的项目进行打包，这边基于的是maven项目的打包。&lt;br&gt;点击菜单栏 File → Project Structure → Artifacts 添加一个jar&lt;/p&gt;</summary>
    
    
    
    <category term="项目" scheme="https://imokkkk.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目部署" scheme="https://imokkkk.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="Spring Boot" scheme="https://imokkkk.github.io/tags/Spring-Boot/"/>
    
    <category term="微信公众号" scheme="https://imokkkk.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(四)处理语音消息</title>
    <link href="https://imokkkk.github.io/35386/"/>
    <id>https://imokkkk.github.io/35386/</id>
    <published>2024-02-24T01:58:27.025Z</published>
    <updated>2020-04-29T02:44:38.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-语音识别接口"><a href="#1-语音识别接口" class="headerlink" title="1.语音识别接口"></a>1.语音识别接口</h3><p>为了实现微信公众号与用户的多样化交互, 本章进行处理用户语音消息的开发.</p><p>开发者进入微信公众平台 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span> —接口权限—对话服务—接受消息—打开接收语音识别结果接口权限</p><span id="more"></span><p><img data-src="/../../../../assets/img/162311.jpg"></p><p><img data-src="/../../../../assets/img/162403.jpg"></p><h3 id="2-获取语音识别结果"><a href="#2-获取语音识别结果" class="headerlink" title="2.获取语音识别结果"></a>2.获取语音识别结果</h3><p>请注意，开通语音识别后，用户每次发送语音给公众号时，微信会在推送的语音消息XML数据包中，增加一个<strong>Recognition</strong>字段（注：<code>由于客户端缓存，开发者开启或者关闭语音识别功能，对新关注者立刻生效，对已关注用户需要24小时生效。开发者可以重新关注此帐号进行测试</code>）。</p><p>开启语音识别后的语音XML数据包如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt; ![CDATA[toUser] ]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt; ![CDATA[fromUser] ]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1357290913<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt; ![CDATA[voice] ]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span>&lt; ![CDATA[media_id] ]&gt;<span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Format</span>&gt;</span>&lt; ![CDATA[Format] ]&gt;<span class="tag">&lt;/<span class="name">Format</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Recognition</span>&gt;</span>&lt; ![CDATA[腾讯微信团队] ]&gt;<span class="tag">&lt;/<span class="name">Recognition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>语音消息参数说明</strong></p><p><img data-src="/../../../../assets/img/161521.jpg"></p><p>开通语音识别功能以后，用户每次发送语音给微信公众号，微信会在推送语音消息XML数据包中添加一个<code>Recongnition</code>字段，该字段为语音识别出的文本内容.</p><h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><p><strong>实体类VoiceMessage</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoiceMessage</span> <span class="keyword">extends</span> <span class="title class_">BaseMessage</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Recognition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MessageUtil</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">voiceMessageToXml</span><span class="params">(VoiceMessage voiceMessage)</span> &#123;</span><br><span class="line">    xstream.alias(<span class="string">&quot;xml&quot;</span>, voiceMessage.getClass());</span><br><span class="line">    <span class="keyword">return</span> xstream.toXML(voiceMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MsgService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(MsgService.class);</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">respMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fromUserName</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;FromUserName&quot;</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">toUserName</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;ToUserName&quot;</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msgType</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;MsgType&quot;</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;Content&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">recognition</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;Recognition&quot;</span>);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;FromUserName is:&quot;</span> + fromUserName + <span class="string">&quot;, ToUserName is:&quot;</span> + toUserName + <span class="string">&quot;, MsgType is:&quot;</span> + msgType);</span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_VOICE))&#123;</span><br><span class="line">                System.out.println(recognition);</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">&quot;环境信息&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> IoTPopApiUtil.IoTpop();</span><br><span class="line">                    <span class="type">Map</span> <span class="variable">ioTpop</span> <span class="operator">=</span> JSON.parseObject(JSONObject.toJSONString(map), Map.class);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> ioTpop.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> data.toString();</span><br><span class="line">                    <span class="type">int</span> index=str.indexOf(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">                    String result=str.substring(index);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="type">JSONArray</span> <span class="variable">array</span> <span class="operator">=</span> JSONArray.parseArray(jsonStr);</span><br><span class="line">                    List&lt;Pi&gt; pi = JSONObject.parseArray(array.toJSONString(),Pi.class);</span><br><span class="line">                    String returnText=<span class="string">&quot;当前温度:&quot;</span>+pi.get(<span class="number">3</span>).getValue()+<span class="string">&quot;°C&quot;</span>+<span class="string">&quot;\n&quot;</span></span><br><span class="line">                            +<span class="string">&quot;当前湿度:&quot;</span>+pi.get(<span class="number">2</span>).getValue()+<span class="string">&quot;%&quot;</span>+<span class="string">&quot;\n&quot;</span></span><br><span class="line">                            +<span class="string">&quot;当前光照强度:&quot;</span>+pi.get(<span class="number">4</span>).getValue()+<span class="string">&quot;Lux&quot;</span>+<span class="string">&quot;\n&quot;</span></span><br><span class="line">                            +<span class="string">&quot;当前气压:&quot;</span>+pi.get(<span class="number">1</span>).getValue()+<span class="string">&quot;hPa&quot;</span>+<span class="string">&quot;\n&quot;</span></span><br><span class="line">                            +<span class="string">&quot;当前海拔:&quot;</span>+pi.get(<span class="number">0</span>).getValue()+<span class="string">&quot;m&quot;</span>+<span class="string">&quot;\n&quot;</span></span><br><span class="line">                            +<span class="string">&quot;降雨情况:&quot;</span>+(pi.get(<span class="number">5</span>).getValue()==<span class="number">1</span>?<span class="string">&quot;降雨&quot;</span>:<span class="string">&quot;未降雨&quot;</span>);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    <span class="type">TextMessage</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>();</span><br><span class="line">                    text.setContent(returnText);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">&quot;天气&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    <span class="type">NewsMessage</span> <span class="variable">newmsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewsMessage</span>();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">                    article.setTitle(<span class="string">&quot;天气预报&quot;</span>);</span><br><span class="line">                    article.setDescription(<span class="string">&quot;点击了解未来天气详情...&quot;</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">&quot;https://xxxx.oss-cn-beijing.aliyuncs.com/ep.png&quot;</span>);</span><br><span class="line">                    article.setUrl(<span class="string">&quot;https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=accu&amp;key=4bdfe35a67bb4b53bee844f6ce7a4b5c&quot;</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;error......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p><img data-src="/../../../../assets/img/163205.jpg"></p><p><img data-src="/../../../../assets/img/163500.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-语音识别接口&quot;&gt;&lt;a href=&quot;#1-语音识别接口&quot; class=&quot;headerlink&quot; title=&quot;1.语音识别接口&quot;&gt;&lt;/a&gt;1.语音识别接口&lt;/h3&gt;&lt;p&gt;为了实现微信公众号与用户的多样化交互, 本章进行处理用户语音消息的开发.&lt;/p&gt;
&lt;p&gt;开发者进入微信公众平台 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==&quot;&gt;https://mp.weixin.qq.com/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; —接口权限—对话服务—接受消息—打开接收语音识别结果接口权限&lt;/p&gt;</summary>
    
    
    
    
    <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>扩展EnvironmentPostProcessor从数据库加载配置项&amp;spring.factories</title>
    <link href="https://imokkkk.github.io/EnvironmentPostProcessor/"/>
    <id>https://imokkkk.github.io/EnvironmentPostProcessor/</id>
    <published>2024-02-24T01:58:27.025Z</published>
    <updated>2023-01-18T05:46:15.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用未接入配置中心时，一些配置项(如oss存储配置信息、邮件服务配置信息等)需要从其它数据源获取，下面以从数据库获取配置信息为例。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>既然需要通过从数据库中读取配置信息，那么先了解一下@Value的工作原理：</p><span id="more"></span><ol><li><p>SpringBoot应用启动</p><p><code>org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String...)</code> &#x3D;&gt; </p><p><code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code> &#x3D;&gt; </p></li><li><p>刷新Spring容器</p><p><code>org.springframework.boot.SpringApplication#refreshContext</code> &#x3D;&gt; </p><p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p></li><li><p>实例化Bean</p><p><code>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.config.ConfigurableListableBeanFactory#preInstantiateSingletons</code>（实例化非懒加载的单例Bean) &#x3D;&gt;</p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#createBean</code> &#x3D;&gt;</p><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p></li><li><p>属性填充</p><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</code> &#x3D;&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">//实例化后</span></span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//@Bean(autowire = Autowire.BY_NAME)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">   </span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">//依赖注入入口</span></span><br><span class="line"><span class="comment">//@Autowired @Value：AutowiredAnnotationBeanPostProcessor @Resource：CommonAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()会覆盖@Autowired</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.annotation.InjectionMetadata#inject</code> &#x3D;&gt; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="built_in">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="literal">null</span> ? checkedElements : <span class="built_in">this</span>.injectedElements);</span><br><span class="line"><span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"><span class="comment">//遍历每个注入点进行依赖注入</span></span><br><span class="line"><span class="comment">//Autowired：AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject</span></span><br><span class="line"><span class="comment">//AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement.inject</span></span><br><span class="line"><span class="comment">//Resource：InjectionMetadata.InjectedElement.inject</span></span><br><span class="line">element.inject(target, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#resolveFieldValue</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></p></li><li><p>处理@Value</p><p><code>org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#findValue</code> </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#resolveEmbeddedValue</code> &#x3D;&gt; </p><p><img data-src="/../assets/img/image-20221116112008529.png"></p><p><code>org.springframework.context.support.PropertySourcesPlaceholderConfigurer#processProperties(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.core.env.ConfigurablePropertyResolver)</code> (<strong>把所有的配置文件都变成了一个个propertysource对象，同时把environment对象也包装成了一个propertysource对象，并且一个个propertysource对象存储在了MutablePropertySources中。</strong>)</p></li></ol><p>大致上来看，@Value解析，分为以下几步：</p><ol><li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#findAutowiringMetadata</code> &#x3D;&gt; </p><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata</code></p><p>收集标注了@Value等注解的字段；</p></li><li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>开始注入值；</p></li><li><p>注入过程中，从DefaultListableBeanFactory中遍历所有的embeddedValueResolver，这些embeddedValueResolvers是StringValueResolver，调用其resolveStringValue方法；</p></li><li><p>其中有一个PropertySourcesPlaceholderConfigurer类构造的StringValueResolver，调用它的resolveStringValue，最终从一个PropertySourcesPropertyResolver的propertySources中遍历所有的propertySource，其中就有Environment的propertySources，匹配到值后返回。</p></li></ol><h3 id="EnvironmentPostProcessor"><a href="#EnvironmentPostProcessor" class="headerlink" title="EnvironmentPostProcessor"></a>EnvironmentPostProcessor</h3><p>从上面可以得出结论，在容器refresh之前，从数据库读取信息封装为MapPropertySource塞入Environment#Property即可。</p><p>主要实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseEnvironmentPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableEnvironment environment, SpringApplication application)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">&quot;databasePropertySources&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 命令行参数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">commandLineArgs</span> <span class="operator">=</span> environment.getPropertySources().contains(<span class="string">&quot;commandLineArgs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (commandLineArgs) &#123;</span><br><span class="line">      environment</span><br><span class="line">          .getPropertySources()</span><br><span class="line">          .addBefore(<span class="string">&quot;commandLineArgs&quot;</span>, loadConfigurationFromDatabase(environment));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (environment.getProperty(<span class="string">&quot;spring.datasource.url&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        environment.getPropertySources().addFirst(loadConfigurationFromDatabase(environment));</span><br><span class="line">        <span class="comment">// 设置激活的Profile</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">activeProfile</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>, <span class="string">&quot;prd&quot;</span>);</span><br><span class="line">        environment.addActiveProfile(activeProfile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> PropertySource <span class="title function_">loadConfigurationFromDatabase</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.datasource.url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.datasource.username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.datasource.password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClassName</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.datasource.druid.driver-class-name&quot;</span>);</span><br><span class="line">    Map&lt;String, ?&gt; configs =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DatabasePropertySourceLoader</span>(url, username, password, driverClassName).load();</span><br><span class="line">    <span class="type">PropertySource</span> <span class="variable">propertySource</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(<span class="string">&quot;databasePropertySources&quot;</span>, (Map&lt;String, Object&gt;) configs);</span><br><span class="line">    <span class="keyword">return</span> propertySource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring.factories</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line"><span class="string">cn.imokkkk.env.DatabaseEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h4><p>Spring Factories是一种类似于Java SPI的机制，在resources&#x2F;META-INF&#x2F;spring.factories文件中配置接口的实现类名称(接口名称&#x3D;实现类)，然后在程序中读取该配置文件并实例化，是spring-boot-starter-xxx的实现基础。</p><p>为了实现从数据库读取配置信息的需求，显然需要在容器refresh之前完成从数据库读取并添加到<strong>环境变量</strong>中。</p><p><strong>调用链路</strong></p><ol><li><p>从spring.factories加载ApplicationListener对应的监听器，并启动</p><p><code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code> &#x3D;&gt; </p><p><code>org.springframework.boot.SpringApplication#getRunListenersorg.springframework.boot.SpringApplication#run(java.lang.String...)</code> &#x3D;&gt; <code>org.springframework.boot.SpringApplication#getSpringFactoriesInstances(java.lang.Class&lt;T&gt;, java.lang.Class&lt;?&gt;[], java.lang.Object...)</code> &#x3D;&gt; <code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames</code></p></li><li><p>发布ApplicationEnvironmentPreparedEvent</p><p><code>org.springframework.boot.SpringApplication#prepareEnvironment</code> &#x3D;&gt; </p><p><code>org.springframework.boot.context.event.EventPublishingRunListener#environmentPrepared</code></p></li><li><p>监听到事件并执行</p><p><code>org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener</code> &#x3D;&gt;</p><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener#onApplicationEvent</code> &#x3D;&gt; </p><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener#onApplicationEnvironmentPreparedEvent</code> &#x3D;&gt; </p><p><code>cn.imokkkk.env.DatabaseEnvironmentPostProcessor#postProcessEnvironment</code></p></li></ol><blockquote><p>sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;CREATE TABLE `app_config`  (</span><br><span class="line"> `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `config_key` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line"> `config_value` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line"> `remark` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line"> `is_halt` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">&gt;) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用未接入配置中心时，一些配置项(如oss存储配置信息、邮件服务配置信息等)需要从其它数据源获取，下面以从数据库获取配置信息为例。&lt;/p&gt;
&lt;h3 id=&quot;Value&quot;&gt;&lt;a href=&quot;#Value&quot; class=&quot;headerlink&quot; title=&quot;@Value&quot;&gt;&lt;/a&gt;@Value&lt;/h3&gt;&lt;p&gt;既然需要通过从数据库中读取配置信息，那么先了解一下@Value的工作原理：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
    <category term="源码" scheme="https://imokkkk.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Spring" scheme="https://imokkkk.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://imokkkk.github.io/ThreadPool/"/>
    <id>https://imokkkk.github.io/ThreadPool/</id>
    <published>2024-02-24T01:58:27.025Z</published>
    <updated>2020-11-03T12:25:05.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p><img data-src="/../../../../assets/img/11183270.jpg"></p><span id="more"></span><p><strong>原理：</strong><br>当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。<br><strong>优点：</strong></p><ol><li>降低资源消耗；</li><li>提高响应速度；</li><li>提高线程的可管理性。<br><strong>缺点：</strong>TODO<br><img data-src="/../../../../assets/img/184834.jpg"></li></ol><h5 id="1-1-四种常用ExecutorService特性"><a href="#1-1-四种常用ExecutorService特性" class="headerlink" title="1.1 四种常用ExecutorService特性"></a>1.1 四种常用ExecutorService特性</h5><table><thead><tr><th>类型</th><th>核心线程数</th><th>最大线程数</th><th>KeepAlive时间(存活时间)</th><th align="center">任务队列</th><th>拒绝策略</th></tr></thead><tbody><tr><td>newCachedThreadPool(可缓存线程池)</td><td>0</td><td>Integer.MAX_VALUE</td><td>60s</td><td align="center">SynchronousQueue</td><td>线程池无限大，当执行第二个任务已经完成，会复用执行第一个任务的线程。</td></tr><tr><td>newFixedThreadPool(定长线程池)</td><td>指定大小</td><td>指定大小(与核心线程数相同)</td><td>0</td><td align="center">LinkedBlockingQueue</td><td>线程池大小固定，没有可用的线程的时候，任务会放在队列等待，队列的长度无限制。</td></tr><tr><td>newSingleThreadExexutor</td><td>1</td><td>1</td><td>0</td><td align="center">LinkedBlockingQueue</td><td>单线程化的线程池，适用于业务逻辑上只允许1个线程进行处理的场景，保证所有任务按照指定顺序FIFO(先进先出)，LIFO(后进先出)，优先级执行。</td></tr><tr><td>newScheduledThreadPool</td><td>指定大小</td><td>Integer.MAX_VALUE</td><td>0</td><td align="center">DelayedWordQueue</td><td>定长线程池，支持定时及周期性任务执行。</td></tr></tbody></table><h5 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h5><p>《阿里巴巴 Java 开发手册》中规定线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。线程池的好处是<strong>减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</strong>。如果不使用线程池，有可能<strong>造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</strong>。而且线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。这样的处理方式能够<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="type">int</span> corePoolSize,</span><br><span class="line">                              <span class="type">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="type">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) </span><br></pre></td></tr></table></figure><p><strong>参数：</strong><br><strong>corePoolSize：</strong>核心线程数，指定了线程池中的线程池数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中；</p><p><strong>maximumPoolSize：</strong>指定了线程池中的最大线程数量，这个参数会根据使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量。</p><p>核心和最大线程数大小仅在构建时设置，但也可以使用 <code>setCorePoolSize()</code> 和 <code>setMaximumPoolSize()</code> 进行动态更改。<br><strong>keepAliveTime：</strong>当线程池中的空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁。如果线程池在以后会变得更加活跃，则应构建线程或者使用<code>setKeepAliveTime(long, TimeUnit)</code>方法。</p><p><strong>unit：</strong>keepAliveTime的单位</p><p><strong>workQueue：</strong>阻塞队列(用来保存等待被执行的任务)</p><ol><li>ArrayBlockingQueue：基于数组结构的<strong>有界任务队列</strong>，按照FIFO排序任务。若有新的任务需要执行时，线程会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程数量达到maximumPoolSize，则执行拒绝策略。这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界任务队列的初始容量比较大或者没有达到超负荷状态，线程数将会一直维持在corePoolSize以下，反之，则会以maximumPoolSize为最大线程数上限。</li><li><strong>没有预定义容量</strong>的LinkedBlockingQueue：基于链表结构的<strong>无界任务队列</strong>，按照FIFO排序任务。使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，当线程数达到corePoolSize后就不会再增加了。使用无界任务队列将导致新任务在队列中等待，从而导致maximumPoolSize的值没有任何作用。当使用这种任务队列模式时，一定要注意任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。这种队列方式可以用于平滑瞬时大量请求。</li><li>SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于ArrayBlockingQueue。<strong>直接握手队列</strong>：它将任务交给线程而不需要保留，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此构建新的线程，如果达到maximumPoolSize设置的最大值，则根据设置的handler执行拒绝策略。在这种情况下，需要对程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量避免执行拒绝策略。应注意，当任务持续以平均提交速度大于平均处理速度时，会导致线程数量会无限增长问题。</li><li>PriorityBlockingQueue：具有优先级的无界任务队列。<strong>优先任务队列</strong>：特殊的无界任务队列，无论添加了多少个任务，线程数量都不会超过corePoolSize。其它队列一般是按照FIFO(先进先出)的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</li></ol><p><strong>threadFactory：</strong>线程工程，用于创建线程。如果未另行指定，则使用Executors.<strong>defaultThreadFactory</strong>默认工厂，使其全部位于同一个ThreadGroup中，并具有相同的NORM_PRIORITY优先级和非守护进程状态。通过不同的ThreadFactory可以更改线程的名称，线程组，优先级，守护进程状态等。privilegedThreadFactory：继承自defaultThreadFactory，主要添加了访问权限校验。</p><p><strong>handler：</strong>拒绝策略，创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但如果出现任务队列已满且线程池创建的线程数达到maximumPoolSize时，这时就需要指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p><ol><li>AbortPolicy：默认策略，丢掉任务直接抛出RejectedExecutionException异常，阻止系统正常工作。</li><li>CallerRunsPolicy：如果线程池的线程池的线程数量达到上限，该策略会把拒绝的任务放在调用者线程当中运行，如果执行程序已关闭，则会丢弃该任务。</li><li>DiscardPolicy：该策略会默默丢弃无法处理的任务，不会抛出任何异常，使用此策略，业务场景中需允许任务的丢失。</li><li>DiscardOldestPolicy：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的。即每次移除队头元素后再尝试入队。</li></ol><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">8</span>, <span class="number">16</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">testTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">testTask</span> <span class="variable">testTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">testTask</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(testTask);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;h4 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;/../../../../assets/img/11183270.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="多线程" scheme="https://imokkkk.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="并发编程" scheme="https://imokkkk.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="多线程" scheme="https://imokkkk.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://imokkkk.github.io/computernetwork/"/>
    <id>https://imokkkk.github.io/computernetwork/</id>
    <published>2024-02-24T01:58:27.025Z</published>
    <updated>2021-07-10T14:10:32.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#1-TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="1.TCP 为什么握手是 3 次、挥手是 4 次？"></a>1.TCP 为什么握手是 3 次、挥手是 4 次？</h3><ul><li>如果一个Host主动向另一个Host发起连接，称为SYN，请求同步；</li><li>如果一个Host主动断开请求，称为FIN，请求完成；</li><li>如果一个Host给另一个Host发送数据，称为PSH，数据推送。</li></ul><span id="more"></span><img data-src="../assets/img/image-20210620162355901.png" alt="image-20210620162355901" style="zoom:67%;" /><img data-src="../assets/img/image-20210620162420844.png" alt="image-20210620162420844" style="zoom:67%;" /><p>TCP是一个双工协议，建立连接的时候，连接双方都需要向对方发送SYN和ACK。握手阶段没有繁琐的工作，因此一方向另一方发起同步(SYN)之后，另一方可以将自己的ACK和SYN打包作为一条消息回复，因此是3次握手。</p><p>挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应(ACK)，表示收到了挥手请求。最后等所有工作结束，再发送请求中断连接(FIN)，因此是4次挥手。</p><h3 id="2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"><a href="#2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？" class="headerlink" title="2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"></a>2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？</h3><p>TCP拆包：将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程中需要保证数据经过网络传输，又能恢复到原始的顺序。TCP利用发送字节数(Sequence Number)和接收字节数(Acknowledgement Number)的唯一性来确定封包之间的顺序关系(无论是Seq还是ACK，都是针对对方而言的。是对方发送的数据和对方接受的数据)。粘包是为了防止数据量过小，导致大量的传输，而将多个TCP段合并成一个发送。</p><p><img data-src="/../assets/img/image-20210620150902311.png"></p><h3 id="3-滑动窗口和流速控制"><a href="#3-滑动窗口和流速控制" class="headerlink" title="3.滑动窗口和流速控制"></a>3.滑动窗口和流速控制</h3><p>深绿色：已经收到了ACK的段浅绿色：发送了，但是没有收到ACK的段白色：没有发送的段紫色：暂时不能发送的段。</p><ol><li><p>有两个封包到达，标记为绿色。</p><p><img data-src="/../assets/img/image-20210620161423153.png"></p></li><li><p>滑动窗口可以向右滑动</p><p><img data-src="/../assets/img/image-20210620161910667.png"></p></li></ol><p><strong>重传</strong></p><ol><li><p>如果部分数据没能收到ACK，如段4迟迟没有收到ACK。</p><p><img data-src="/../assets/img/image-20210620162206747.png"></p></li><li><p>此时滑动窗口只能右移一个位置</p><p><img data-src="/../assets/img/image-20210620162314291.png"></p><p>如果段4重传成功(接收到ACK)，那么窗口就会继续右移。如果段4发送失败，还是没能收到ACK，那么接收方也会抛弃段5、6、7。这样从段4开始之后的数据都需要重发。</p></li></ol><p><strong>快速重传</strong></p><p>例如段1、2、4到了，但是3没到。接收方可以发送多次3的ACK(不发段4的ACK)。如果发送方收到多个3的ACK，就会重发段3。这和超时重发不同，是一种催促机制，接收方希望催促发送方尽快补全某个TCP段。</p><p>实际操作中，每个TCP段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中滑动窗口的大小单位是字节数。</p><p><strong>总结</strong></p><p>滑动窗口是TCP协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出的顺序，但是窗口中的分组会一次性发送。窗口中序号最大的分组如果收到ACK，窗口就会发生滑动；如果有分组为收到ACK，则会滑动到该窗口。</p><p>在多次传输中，网络的平均延迟往往是相对固定的，这样TCP协议可以通过<strong>发送方和接收方协商窗口大小控制流速</strong>。</p><h3 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h3><p><strong>UDP</strong></p><p>UDP，目标是在传输层提供直接发送报文的能力。Datagram是数据传输的最小单位，UDP协议不会帮助拆分数据，它的目标只有一个，就是能发送报文。</p><p>UDP的可靠性仅仅就是通过Checksum保证。如果一个数据封包Datagram发生了数据损坏，UDP可以通过Checksum纠错或者修复。</p><p><strong>UDP与TCP的区别</strong></p><ol><li><p>目的差异</p><p>TCP：提供可靠的网络传输。</p><p>UDP：提供报文交换能力基础上尽可能的简化协议。</p></li><li><p>可靠性差异</p><p>TCP：可靠，收到的数据会进行排序。</p><p>UDP：不可靠，只管发送数据包。</p></li><li><p>连接vs无连接</p><p>TCP：面向连接，会有握手的过程，传输数据必须先建立连接。</p><p>UDP：无连接协议，数据随时都可以发送，只提供发送封包的能力。</p></li><li><p>流控技术</p><p>TCP在发送缓冲区中存储数据，并在接收缓冲区中接收数据，如果接收缓冲区已满，接收方无法处理更多数据，并将其丢弃。UDP没有提供类似的能力。</p></li><li><p>传输速度</p><p>UDP协议简化，封包小，没有连接、可靠性检查等，因此单纯从速度上讲，UDP更快。</p></li><li><p>理论上，任何一个用TCP协议构造的成熟应用层协议，都可以UDP重构。想要把网络优化到极致，就会用UDP作为底层技术，然后在UDP基础上解决可靠性。</p><p>TCP场景：</p><ul><li>远程控制(SSH)</li><li>File Transfer Protocol(FTP)</li><li>邮件(SMTP、IMAP等)</li><li>点对点文件传输(微信等)</li></ul><p>UDP场景</p><ul><li>网络游戏</li><li>音视频传输</li><li>DNS</li><li>ping</li><li>直播</li></ul><p>模糊地带</p><ul><li>HTTP(目前以TCP为主)</li><li>文件传输</li></ul></li></ol><p>TCP最核心的价值就是提供封装好的一套解决可靠性的优秀方案。UDP最核心的价值是灵活、轻量、传输速度快。场景不同选择不同。</p><h3 id="5-IPv4"><a href="#5-IPv4" class="headerlink" title="5.IPv4"></a>5.IPv4</h3><p>IP协议自身不能不能保证可靠性(数据无损的到达目的地)。</p><p>IP协议接收IP协议上方的Host-To-Host协议传来的数据，然后进行拆分，这个能力叫做分片。然后IP协议为每个片段增加一个IP头，组成一个IP封包。之后，IP协议调用底层的局域网(数据链路层)传送数据。最后IP协议通过寻址和路由最终将封包送达目的地。</p><p>延迟：指1bit数据从网络的一个终端传送到另一个终端需要的时间。<br>吞吐量：单位时间内可以传输的平均数据量。如bit&#x2F;s(bps)。<br>丢包率：指发出去的封包没有到达目的地的比例。</p><p><strong>IPv4地址</strong><br>4个8喂排列而成，总共可以编址43亿个地址。<br>如103.16.3.1</p><p><img data-src="/../assets/img/23223038.png"></p><p><strong>寻址与路由的区别</strong></p><p>寻址就是通过地址找设备，比如根据地址找到一个公寓。在 IPv4 协议中，寻址找到的是一个设备所在的位置。路由的本质是路径的选择，就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</p><p>所以，要做路由，就必须理解地址，也就是借助寻址的能力。找到最终的设备又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址相辅相成。</p><h3 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h3><p><strong>相似点</strong></p><p>工作原理与IPv4类似，分成切片、增加封包头、路由(寻址)几个阶段。</p><p><strong>不同点</strong></p><ul><li><p>IPv6地址</p><p>IPv4的地址是4个8位，总共32位，如103.28.7.35，每一个是8位，用0-255的数字表示；IPv6的地址是8个16位，总共128位，如0123:4567:89ab:cdef:0123:4567:89ab:cdef，通常用16进制表示。</p></li><li><p>IPv6的寻址</p><ul><li><p>全局单播</p><p>将消息从一个设备传到另一个设备，和IPv4的发送&#x2F;接收数据大同小异。IPv6地址太多，因此不需要子网掩码，而是直接将IPv6的地址分区即可。</p></li><li><p>本地单播</p><p>在局域网中，实现设备到设备的通信。本地单播必须以fe80开头，类似IPv4中以127开头。</p></li><li><p>分组多播</p><p>将消息发送给多个接收者。</p></li><li><p>任意播</p><p>将消息发送给多个接收方，并选择一条最优的路径。</p></li></ul></li></ul><p><strong>IPv6和IPv4的兼容</strong></p><ul><li><p>一个IPv6的客户端想访问IPv4的服务器</p><p><img data-src="/../assets/img/gfgfdg225213.png"></p><ol><li>客户端通过DNS64服务器查询AAAA记录。(DNS64：一种解决IPv4和IPv6兼容问题的DNS服务，会把IPv4和IPv6地址同时返回)</li><li>DNS64服务器返回含IPv4地址的AAAA记录。</li><li>客户端将对应的IPv4地址请求发送给一个NAT64路由器。</li><li>NAT64路由器将IPv6地址转换为IPv4地址，从而访问IPv4网络，并收集结果。</li><li>消息返回客户端。</li></ol></li><li><p>两个IPv6网络被IPv4隔离</p><p><img data-src="/../assets/img/iij225838.png"></p><p>隧道的本质就是在两个IPv6的网络出口网关处，实现一段地址转换的程序。</p></li></ul><p><strong>Tunnel是什么？</strong></p><p>Tunnel就是隧道，两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个IPv6网络被IPv4分隔开，那么两个IPv6网络的出口处(和IPv4的网关处)就可以用程序(或硬件)实现一个隧道，方便两个网络中设备的通信。</p><h3 id="7-BIO、NIO和AIO有什么区别？"><a href="#7-BIO、NIO和AIO有什么区别？" class="headerlink" title="7.BIO、NIO和AIO有什么区别？"></a>7.BIO、NIO和AIO有什么区别？</h3><p>BIO接口设计会直接导致当前线程阻塞。NIO的设计不会触发当前线程的阻塞。AIO为I&#x2F;O提供了异步的能力，也就是将I&#x2F;o的响应程序放到一个独立的时间线上去执行。但是通常AIO的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且将异步计算同步回主线的能力。</p><p>通常情况下，这3种API都会伴随I&#x2F;O多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将I&#x2F;O消息发送给指定的线程。另外，还可以使用DMA、内存映射等方式优化I&#x2F;O。</p><h3 id="8-怎样实现RPC框架？"><a href="#8-怎样实现RPC框架？" class="headerlink" title="8.怎样实现RPC框架？"></a>8.怎样实现RPC框架？</h3><ol><li><p>调用约定和命名</p><p>远程调用一个函数，命名空间+类名+方法名IP、端口</p></li><li><p>注册和发现</p><p>调用的时候，需要根据字符串(命名)去获取IP和端口(机器和服务)</p><ul><li><p>Redis hash</p><p>注册：上线一个服务时，用Redis的hash对象存储它和它对应的IP地址+端口列表。</p><p>发现：根据RPC服务的名称(命名空间+类名+方法名)查找到提供服务的IP + 端口清单并指定某个 IP + 端口(提供服务)</p><p>不足：所有RPC调用着都去Redis查询，压力较大，增加缓存，缓存和注册表之间数据不一致。</p></li><li><p>Zookeeper提供订阅，让RPC调用者订阅到服务地址的变更，及时更新自己的缓存。</p></li></ul></li><li><p>多路复用</p><p>提升吞吐量：1.顺序传输  2.切片传输。</p></li><li><p>负载均衡</p><p>负载均衡可以看作发现模块的一个子组件，请求到达RPC的网关(或某个路由程序)后，发现组件会提供服务对应的所有实例(IP+端口)，然后负载均衡算法会指定其中一个响应请求。</p></li><li><p>可用性和容灾</p><ul><li>当一个服务实例崩溃的时候，发现模块及时从注册表中删除这个服务实例。</li><li>注册表和RPC调用者之间存在不一致现象，而且注册表的更新本身也可能滞后。如确认一个服务有没有崩溃，可能需要一个心跳程序持续请求这个服务，调用到一个不存在或崩溃的服务，需要自己重新发现组件申请新的服务实例(地址+端口)。</li><li>临时访问量剧增，需要扩容的场景，上线更多的容器，并且去注册。</li></ul></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？"><a href="#1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？" class="headerlink" title="1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？"></a>1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？</h4><p>TCP连接上限受限于机器的内存，假设一个TCP连接需要占用的最小内存是8k(发送、接收缓存各4k，当然还要考虑socket描述符等)，那么最大连接数为：8 * 1024 * 1024 &#x2F; 8 &#x3D; 1048576个，即约为100w个TCP长连接。<br>但是如果单机建立太多的连接，会报<code>Cant assign requested address</code>的异常，这是因为客户端连接服务端时，操作系统要为每个客户端分配一个端口号，端口号会更快用尽。</p><h4 id="2-127-0-0-1，localhost，0-0-0-0-有什么不同？"><a href="#2-127-0-0-1，localhost，0-0-0-0-有什么不同？" class="headerlink" title="2.127.0.0.1，localhost，0.0.0.0 有什么不同？"></a>2.127.0.0.1，localhost，0.0.0.0 有什么不同？</h4><p>127.0.0.1：本地回环地址，发送到loopback上的数据会被转发到本地应用。</p><p>localhost：指代本地计算机，用于访问绑定在loopback上的服务。localhost是一个主机名，不仅可以指向IPv4的本地回环地址，也可以指向IPv6的本地回环地址[::1]。</p><p>0.0.0.0：一个特殊的目的IP地址，称作不可路由IP地址，它的用途会被特殊规定。通常情况下，当把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的IP地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到0.0.0.0就可以保证服务在多个IP地址上都可以用。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-TCP-为什么握手是-3-次、挥手是-4-次？&quot;&gt;&lt;a href=&quot;#1-TCP-为什么握手是-3-次、挥手是-4-次？&quot; class=&quot;headerlink&quot; title=&quot;1.TCP 为什么握手是 3 次、挥手是 4 次？&quot;&gt;&lt;/a&gt;1.TCP 为什么握手是 3 次、挥手是 4 次？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果一个Host主动向另一个Host发起连接，称为SYN，请求同步；&lt;/li&gt;
&lt;li&gt;如果一个Host主动断开请求，称为FIN，请求完成；&lt;/li&gt;
&lt;li&gt;如果一个Host给另一个Host发送数据，称为PSH，数据推送。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://imokkkk.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://imokkkk.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://imokkkk.github.io/tags/HTTP/"/>
    
    <category term="TCP" scheme="https://imokkkk.github.io/tags/TCP/"/>
    
    <category term="UDP" scheme="https://imokkkk.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://imokkkk.github.io/fenkufenbiaon/"/>
    <id>https://imokkkk.github.io/fenkufenbiaon/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2022-12-14T08:54:26.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p><strong>什么情况下需要分库分表？</strong></p><p>MySQL单表容量大于1000万(BTREE索引树在3-5层之间)。</p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>根据业务耦合性，将业务关联度低的不同表存储在不同的数据库。类似于”微服务”。</p><span id="more"></span><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>把一个表的多个字段拆分成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。</p><p><strong>优点</strong></p><ol><li>同时解决了业务层面的耦合；</li><li>一定程度提升IO、数据库连接数、单机硬件的资源瓶颈。</li></ol><p><strong>缺点</strong></p><ol><li>无法使用sql join，需要编码进行聚合操作，开发复杂度增加；</li><li>分布式事务处理复杂；</li><li>依然存在单表数据量大的问题。</li></ol><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h4><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p><strong>优点</strong></p><ol><li>解决单表数据量过大的问题；</li><li>业务编码改造相对较小。</li></ol><p><strong>缺点</strong></p><ol><li>跨分片的事务一致性难以保证；</li><li>跨库的join关联查询性能差。</li></ol><h3 id="数据分片规则"><a href="#数据分片规则" class="headerlink" title="数据分片规则"></a>数据分片规则</h3><h4 id="Hash取模"><a href="#Hash取模" class="headerlink" title="Hash取模"></a>Hash取模</h4><p>按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系，从而将哈希值不同的数据分布到不同的节点上。</p><p>如选择id作为数据分片的key，n台实例，则取<code>id的hash值 % n </code>得到的结果就是数据所在实例。</p><p><strong>优点</strong></p><ol><li>实现简单</li></ol><p><strong>缺点</strong></p><ol><li>加入或者删除一个节点的时候，需要迁移大量的数据；</li><li>很难解决数据不均衡的问题；</li><li>如果查询条件中不带用于分片的key，那么需要查询所有分库，再在内存中合并数据，效率低，复杂度高&#x2F;</li></ol><h4 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h4><p>按照关键值划分成不同的区间，每个物理节点负责一个或者多个区间。</p><p>如id 0-10000数据位于实例1，10000-20000位于实例2…。</p><p><strong>优点</strong></p><ol><li>单表&#x2F;库大小可控；</li><li>易于水平扩展，假如&#x2F;删除实例时，无需对其它实例的数据迁移；</li><li>易于范围查询。</li></ol><p><strong>缺点</strong></p><ol><li>热点数据(如按时间字段分片)；</li><li>元数据(每个实例存储哪些数据区间)相对复杂一些。</li></ol><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。</p><p><strong>特点</strong></p><ol><li>一致性 hash 方式在增删的时候只会影响到 hash 环上相邻的节点，不会发生大规模的数据迁移；</li><li>一致性 hash 方式在增加节点时，只能分摊一个节点的压力；删除节点时，改节点的压力只能转移到下一个节点，所以实际工程中一般引入虚拟节点，即节点个数远大于物理节点个数，一个物理节点负责多个虚拟节点的真实存储。<strong>操作数据时，先通过hash环找到对应的虚拟节点，再通过虚拟节点与物理节点的映射关系找到对应的物理节点。</strong></li></ol><p><strong>优点</strong></p><ol><li>一致性 hash 方式在节点增删的时候只会影响到 hash 环上相邻的节点，不会发生大规模的数据迁移；</li><li>可以根据物理节点的性能来调整每一个物理节点对于虚拟节点的数量，充分、合理利用资源。</li></ol><p><strong>缺点</strong></p><ol><li>需要维护的元数据增加(虚拟节点与物理节点的映射关系)</li></ol><h3 id="分库分表引入的问题"><a href="#分库分表引入的问题" class="headerlink" title="分库分表引入的问题"></a>分库分表引入的问题</h3><ol><li><p>分布式事务</p></li><li><p>跨节点join关联查询</p><ol><li>字段冗余：空间换时间，避免join查询。如订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”user表”；</li><li>数据组装：分为多次子查询请求，最后在内存中组装结果。</li></ol></li><li><p>跨节点分页、排序、函数问题</p><p>当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；如果排序字段非分片字段，需要在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序。</p></li><li><p>全局主键</p><p>雪花算法(时钟回拨问题)，百度<a href="https://github.com/baidu/uid-generator"><strong>uid-generator</strong></a>，美团**<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01laXR1YW4tRGlhbnBpbmcvTGVhZg==">Leaf<i class="fa fa-external-link-alt"></i></span>**、</p></li></ol><h2 id="ShardingShere"><a href="#ShardingShere" class="headerlink" title="ShardingShere"></a>ShardingShere</h2><p>ShardingSphere 是一款分布式的数据库生态系统， 可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强。</p><p><strong>常用功能</strong></p><ul><li>数据分片<ul><li>分库 &amp; 分表</li><li>读写分离</li><li>分片策略定制</li><li>无中心化分布式主键</li></ul></li><li>分布式事务<ul><li>LOCAL 事务</li><li>XA 强一致性事务</li><li>BASE柔性事务</li></ul></li><li>数据库治理<ul><li>数据脱敏、加密</li><li>流量治理</li><li>数据迁移</li></ul></li></ul><h3 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h3><h3 id="ShardingSphere-Proxy"><a href="#ShardingSphere-Proxy" class="headerlink" title="ShardingSphere-Proxy"></a>ShardingSphere-Proxy</h3><h3 id="结果归并"><a href="#结果归并" class="headerlink" title="结果归并"></a>结果归并</h3><p>将各个数据节点获取的多数据结果集，组合、处理成一个结果集并返回给请求。</p><p>遍历、排序、分组、分页、聚合。</p><ol><li><p>遍历归并</p><p>将多个数据结果集合并为一个单向链表；</p></li><li><p>排序归并</p><p>每个数据结果集自身有序，所以需要对多个有序的数组进行排序；ShardingSphere在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（<strong>通过实现Java的Comparable接口完成</strong>），并将其放入<code>优先级队列</code>。</p></li><li><p>分组归并</p><p>流式分组归并：要求SQL的排序项与分组项的字段及排序类型(ASC或DESC)必须保持一致；</p><p>内存归并</p></li><li><p>聚合归并</p><p>装饰者模式</p></li><li><p>分页归并</p><p>ShardingSphere通过<code>装饰者模式</code>来增加对数据结果集进行分页的能力。</p></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="ShardingSphere读写分离"><a href="#ShardingSphere读写分离" class="headerlink" title="ShardingSphere读写分离"></a>ShardingSphere读写分离</h3><h4 id="Docker部署主从MySQL"><a href="#Docker部署主从MySQL" class="headerlink" title="Docker部署主从MySQL"></a>Docker部署主从MySQL</h4><p>参考：<a href="https://imokkkk.github.io/dockermysqlmasterslave/">https://imokkkk.github.io/dockermysqlmasterslave/</a></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须搭配druid，不能使用druid-spring-boot-starter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master0,slave0</span></span><br><span class="line">      <span class="attr">master0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">slave0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3307/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">ms:</span></span><br><span class="line">          <span class="attr">masterDataSourceName:</span> <span class="string">master0</span></span><br><span class="line">          <span class="attr">slaveDataSourceNames:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">slave0</span></span><br><span class="line">          <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>效果</p><p>增删改操作主库，查询操作从库：</p><p><img data-src="/../assets/img/image-20221201105517286.png"></p></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1yZWFkLXdyaXRlLXNwbGl0dGluZw==">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-read-write-splitting<i class="fa fa-external-link-alt"></i></span></p><h3 id="ShardingSphere读写分离-单库分表"><a href="#ShardingSphere读写分离-单库分表" class="headerlink" title="ShardingSphere读写分离+单库分表"></a>ShardingSphere读写分离+单库分表</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>依赖</p><p>同上</p></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">slave0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3307/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave0</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">url:</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds0.url$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">surl</span></span><br><span class="line">              <span class="comment">#对url表surl字段hash取模(分表的个数)</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">url$-&gt;&#123;Math.abs(surl.hashCode())%2&#125;</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">ds0:</span></span><br><span class="line">          <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">slave-data-source-names:</span> <span class="string">slave0</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>效果</p><p>批量插入3条数据：2条数据新增到主库的url0表，1条数据新增到url1表。</p><p><img data-src="/../assets/img/image-20221208152127526.png"></p></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1yZWFkLXdyaXRlLXNwbGl0dGluZy10YWJsZQ==">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-read-write-splitting-table<i class="fa fa-external-link-alt"></i></span></p><h3 id="ShardingSphere分库-分表"><a href="#ShardingSphere分库-分表" class="headerlink" title="ShardingSphere分库+分表"></a>ShardingSphere分库+分表</h3><ol><li><p>依赖</p><p>同上</p></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">ds0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen1?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds0,</span> <span class="string">ds1</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment">#分库策略</span></span><br><span class="line">      <span class="attr">default-database-strategy:</span></span><br><span class="line">        <span class="attr">inline:</span></span><br><span class="line">          <span class="attr">sharding-column:</span> <span class="string">sid</span></span><br><span class="line">          <span class="attr">algorithm-expression:</span> <span class="string">ds$-&gt;&#123;Math.abs(sid.hashCode())%2&#125;</span></span><br><span class="line">      <span class="comment">#分表策略</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">url:</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds$-&gt;&#123;0..1&#125;.url$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">surl</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">url$-&gt;&#123;Math.abs(surl.hashCode())%2&#125;</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>效果</p><p>批量插入3条数据：</p><ul><li>1条数据新增到ds1的url1表；</li><li>1条数据新增到ds1的url0表；</li><li>1条数据新增到ds0的url0表。</li></ul><p><img data-src="/../assets/img/image-20221214165028079.png"></p></li></ol></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1zcGxpdHRpbmctZGF0YWJhc2UtdGFibGU=">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-splitting-database-table<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h1&gt;&lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么情况下需要分库分表？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL单表容量大于1000万(BTREE索引树在3-5层之间)。&lt;/p&gt;
&lt;h3 id=&quot;垂直切分&quot;&gt;&lt;a href=&quot;#垂直切分&quot; class=&quot;headerlink&quot; title=&quot;垂直切分&quot;&gt;&lt;/a&gt;垂直切分&lt;/h3&gt;&lt;h4 id=&quot;垂直分库&quot;&gt;&lt;a href=&quot;#垂直分库&quot; class=&quot;headerlink&quot; title=&quot;垂直分库&quot;&gt;&lt;/a&gt;垂直分库&lt;/h4&gt;&lt;p&gt;根据业务耦合性，将业务关联度低的不同表存储在不同的数据库。类似于”微服务”。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://imokkkk.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="MySQL" scheme="https://imokkkk.github.io/tags/MySQL/"/>
    
    <category term="分库分表" scheme="https://imokkkk.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    <category term="ShardingSphere" scheme="https://imokkkk.github.io/tags/ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>四种常见的排序算法</title>
    <link href="https://imokkkk.github.io/23116/"/>
    <id>https://imokkkk.github.io/23116/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2020-04-29T02:44:38.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p><strong>思想:</strong> 每一趟将待排序序列中最大元素移到最后，剩下的为新的待排序序列, 重复上述步骤直到排完所有元素。这只是冒泡排序的一种, 当然也可以从后往前排</p><p><strong>平均时间复杂度:</strong> O(n^2)     </p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d.selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p><strong>思想:</strong> 每一趟从待排序序列选择一个最小的元素放在已排好序列的末尾, 剩下的为待排序序列, 重复上述步骤直至完成排序</p><p><strong>平均时间复杂度:</strong> O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//默认第一个是最小的。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">//记录最小的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//通过与后面的数据进行比较得出，最小值和下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后将最小值与本次循环的，开始值交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">        <span class="comment">//说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。每次只需要找无需的最小值，做替换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p><strong>思想:</strong> 1. 默认从第二个数据开始比较。</p><p>　　  2.如果第二个数据比第一个小，则交换。然后在用第三个数据比较，如果比前面小，则插入（狡猾）。否则，退出循环</p><p>　　  3.说明：默认将第一数据看成有序列表，后面无序的列表循环每一个数据，如果比前面的数据小则插入（交换）。否则退出</p><p><strong>平均时间复杂度:</strong>  O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//外层循环，从第二个开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//内存循环，与前面排好序的数据比较，如果后面的数据小于前面的则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不小于，说明插入完毕，退出内层循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p><strong>采用分治法的思想：</strong>首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。</p><p><strong>平均时间复杂度:</strong>  O(n*log(n))  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//pivot:位索引;p_pos:轴值</span></span><br><span class="line">        <span class="type">int</span> pivot, p_pos, i, temp;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            p_pos = low;</span><br><span class="line">            pivot = arr[p_pos];</span><br><span class="line">            <span class="keyword">for</span> (i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">                    p_pos++;</span><br><span class="line">                    temp = arr[p_pos];</span><br><span class="line">                    arr[p_pos] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = arr[low];</span><br><span class="line">            arr[low] = arr[p_pos];</span><br><span class="line">            arr[p_pos] = temp;</span><br><span class="line">            <span class="comment">//分而治之</span></span><br><span class="line">            quickSort(arr, low, p_pos - <span class="number">1</span>);<span class="comment">//排序左半部分</span></span><br><span class="line">            quickSort(arr, p_pos + <span class="number">1</span>, high);<span class="comment">//排序右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">     d.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注-各排序时间复杂度"><a href="#注-各排序时间复杂度" class="headerlink" title="注: 各排序时间复杂度"></a>注: 各排序时间复杂度</h3><table><thead><tr><th>排序方法        平均情况        最好情况            最坏情况        辅助空间        稳定性</th></tr></thead><tbody><tr><td>冒泡排序         O(n^2)                  O(n)               O(n^2)            O(1)                稳定</td></tr><tr><td>选择排序         O(n^2)                 O(n^2)            O(n^2)            O(1)              不稳定</td></tr><tr><td>插入排序         O(n^2)                  O(n)               O(n^2)             O(1)                稳定</td></tr><tr><td>希尔排序O(n*log(n))~O(n^2)      O(n^1.3)       O(n^2)            O(1)              不稳定</td></tr><tr><td>堆排序          O(n<em>log(n))          O(n</em>log(n))       O(n*log(n))         O(1)              不稳定</td></tr><tr><td>归并排序       O(n<em>log(n))        O(n</em>log(n))       O(n*log(n))          O(n)                稳定</td></tr><tr><td>快速排序       O(n<em>log(n))        O(n</em>log(n))            O(n^2)             O(1)              不稳定</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序&quot;&gt;&lt;/a&gt;1.冒泡排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;思想:&lt;/strong&gt; 每一趟将待排序序列中最大元素移到最后，剩下的为新的待排序序列, 重复上述步骤直到排完所有元素。这只是冒泡排序的一种, 当然也可以从后往前排&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均时间复杂度:&lt;/strong&gt; O(n^2)     &lt;/p&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://imokkkk.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(一)开发者接入微信公众号</title>
    <link href="https://imokkkk.github.io/38103/"/>
    <id>https://imokkkk.github.io/38103/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2020-04-29T02:44:38.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="微信公众号开发-一-开发者接入微信公众号"><a href="#微信公众号开发-一-开发者接入微信公众号" class="headerlink" title="微信公众号开发(一)开发者接入微信公众号"></a>微信公众号开发(一)开发者接入微信公众号</h4><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>该文章基于<code>JDK1.8 </code>  <code>springboot2.1.7.RELEASE</code>环境</p><p>实现开发者第一次接入微信公众号后台的需求</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h3><h4 id="2-1-进入微信公众平台注册账号"><a href="#2-1-进入微信公众平台注册账号" class="headerlink" title="2.1 进入微信公众平台注册账号"></a>2.1 进入微信公众平台注册账号</h4><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>个人用户建议注册订阅号</p><span id="more"></span><h4 id="2-2-内网穿透"><a href="#2-2-内网穿透" class="headerlink" title="2.2 内网穿透"></a>2.2 内网穿透</h4><p>因为要直接用内网本机开发调试，微信网页授权在回调时要访问本机，所以直接做个内网穿透，可以直接在外网访问到本机，做法如下：</p><ol><li><p>登录 <span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24v">https://natapp.cn/<i class="fa fa-external-link-alt"></i></span> （我用的natapp.cn，你可以用其他类似的，个人感觉这个不错）</p></li><li><p>购买隧道：购买后使用方式: </p><blockquote><p> 参考官方教程：<span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24vYXJ0aWNsZS9uYXRhcHBfbmV3Ymll">https://natapp.cn/article/natapp_newbie<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ol><p>使用后会得到natapp分配的网址，如 xxx.natapp.cn，这个地址就可以访问到开发本机。</p><p>   <img data-src="/../../../../assets/img/142029.jpg"></p><ol start="3"><li><p>下载并配置config.ini, 运行natapp</p><p><img data-src="/../../../../assets/img/142853.jpg"></p></li></ol><h3 id="3-接入认证成为开发者"><a href="#3-接入认证成为开发者" class="headerlink" title="3.接入认证成为开发者"></a>3.接入认证成为开发者</h3><blockquote><p>可参考微信官方开发文档 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0FjY2Vzc19PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="3-1-填写服务器配置"><a href="#3-1-填写服务器配置" class="headerlink" title="3.1 填写服务器配置"></a>3.1 填写服务器配置</h4><p>登录微信公众号开发平台:<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span><code>开发</code>—<code>开发者工具</code>—<code>公众平台测试账号</code></p><p><img data-src="/../../../../assets/img/144010.jpg"></p><ul><li>Tips:</li></ul><ol><li>微信公众号接口必须以<span class="exturl" data-url="aHR0cDovL+aIlmh0dHBzLy8lRTUlQkMlODAlRTUlQTQlQjQlRUYlQkMlOEMlRTUlODglODYlRTUlODglQUIlRTYlOTQlQUYlRTYlOEMlODE4MCVFNyVBQiVBRiVFNSU4RiVBMyVFNSU5MiU4QzQ0MyVFNyVBQiVBRiVFNSU4RiVBMyVFRiVCQyU4MQ==">http:&#x2F;&#x2F;或https:&#x2F;&#x2F;开头，分别支持80端口和443端口！<i class="fa fa-external-link-alt"></i></span></li><li>这里的url可以选择自己买的服务器地址，记得必须开放80端口去使用！ 或者使用内网映射外网工具生成一个域名地址供给你开发使用，此方法自行百度，如下就是其中一种使用~</li><li>目前提交是无法配置成功的, 不要着急</li></ol><h4 id="3-2-提交验证URL有效性"><a href="#3-2-提交验证URL有效性" class="headerlink" title="3.2 提交验证URL有效性"></a>3.2 提交验证URL有效性</h4><h5 id="3-2-1-搭建SpingBoot工程"><a href="#3-2-1-搭建SpingBoot工程" class="headerlink" title="3.2.1 搭建SpingBoot工程"></a>3.2.1 搭建SpingBoot工程</h5><p>项目结构</p><p><img data-src="/../../../../assets/img/144403.jpg"></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weixin-java-mp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wechat:</span></span><br><span class="line">  <span class="attr">mpAppId:</span> <span class="string">xxxxxxxx</span><span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpAppSecret:</span> <span class="string">xxxxxx</span><span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpToken:</span> <span class="string">xxxxx</span><span class="comment">#与前面在公众平台测试账号---接口配置信息所填写保持一致</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span><span class="comment">#端口号</span></span><br></pre></td></tr></table></figure><p>sha1加密工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sha1</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;sha1&quot;</span>);</span><br><span class="line">            <span class="comment">// 放入加密字符串</span></span><br><span class="line">            digest.update(str.getBytes());</span><br><span class="line">            <span class="comment">// 进行加密</span></span><br><span class="line">            <span class="type">byte</span>[] digestMsg = digest.digest();</span><br><span class="line">            <span class="comment">// byte转换16进制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b : digestMsg) &#123;</span><br><span class="line">                sb.append(String.format(<span class="string">&quot;%02x&quot;</span>, b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;wechat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatAccountConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String mpAppId;</span><br><span class="line">    <span class="keyword">private</span> String mpAppSecret;</span><br><span class="line">    <span class="keyword">private</span> String mpToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/wechat/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WechatAccountConfig wechatAccountConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理微信认证：验证服务器地址的有效性，get提交</span></span><br><span class="line"><span class="comment">     * signature: 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span></span><br><span class="line"><span class="comment">     * timestamp 时间戳</span></span><br><span class="line"><span class="comment">     * nonce: 随机数</span></span><br><span class="line"><span class="comment">     * echostr: 随机字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkSignature</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;============= 处理微信认证 ===============&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到微信的请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;signature&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">echostr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;echostr&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 这里的token是微信公众平台上自己所配的！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> wechatAccountConfig.getMpToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① 将token、timestamp、nonce三个参数进行字典序排序 b a d c h ==&gt;a b c d h</span></span><br><span class="line">        String[] strArr = &#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="comment">// 字典排序</span></span><br><span class="line">        Arrays.sort(strArr);</span><br><span class="line">        <span class="comment">// ② 将三个参数字符串拼接成一个字符串进行sha1加密</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strArr) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha1Str</span> <span class="operator">=</span> SecurityUtil.sha1(sb.toString());</span><br><span class="line">        <span class="comment">// ③ 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">        <span class="keyword">if</span> (sha1Str.equals(signature)) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，就是来自微信请求</span></span><br><span class="line">            <span class="comment">// 若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效</span></span><br><span class="line">            response.getWriter().println(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WeChatService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-测试"><a href="#3-2-2-测试" class="headerlink" title="3.2.2 测试"></a>3.2.2 测试</h5><ol><li>启动该SpringBoot项目</li><li>回到公众平台测试账号—接口配置信息, 点击提交即可</li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;微信公众号开发-一-开发者接入微信公众号&quot;&gt;&lt;a href=&quot;#微信公众号开发-一-开发者接入微信公众号&quot; class=&quot;headerlink&quot; title=&quot;微信公众号开发(一)开发者接入微信公众号&quot;&gt;&lt;/a&gt;微信公众号开发(一)开发者接入微信公众号&lt;/h4&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;该文章基于&lt;code&gt;JDK1.8 &lt;/code&gt;  &lt;code&gt;springboot2.1.7.RELEASE&lt;/code&gt;环境&lt;/p&gt;
&lt;p&gt;实现开发者第一次接入微信公众号后台的需求&lt;/p&gt;
&lt;h3 id=&quot;2-准备工作&quot;&gt;&lt;a href=&quot;#2-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2.准备工作&quot;&gt;&lt;/a&gt;2.准备工作&lt;/h3&gt;&lt;h4 id=&quot;2-1-进入微信公众平台注册账号&quot;&gt;&lt;a href=&quot;#2-1-进入微信公众平台注册账号&quot; class=&quot;headerlink&quot; title=&quot;2.1 进入微信公众平台注册账号&quot;&gt;&lt;/a&gt;2.1 进入微信公众平台注册账号&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==&quot;&gt;https://mp.weixin.qq.com/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人用户建议注册订阅号&lt;/p&gt;</summary>
    
    
    
    
    <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://imokkkk.github.io/14808/"/>
    <id>https://imokkkk.github.io/14808/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2020-04-29T02:44:38.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 中一般认为有23种设计模式, 下面介绍几种常见的设计模式。总体来说设计模式分为三大类： </p><ul><li>创建型模式, 共5五种：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、原型模式。 </li><li>结构型模式，共7种：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、代理模式、外观模式、桥接模式、组合模式、享元模式。 </li><li>行为型模式，共11种：策略模式、模板方法模式、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><span id="more"></span><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>所谓的单例设计指的是<strong>一个类只允许产生一个实例化对象。</strong><br>最好理解的一种设计模式，分为懒汉式和饿汉式。</p><p><strong>饿汉式</strong>: 构造方法私有化，外部无法产生新的实例化对象，只能通过static方法取得实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类的内部可以访问私有结构，所以可以在类的内部产生实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * private 声明构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式</strong>: 当第一次去使用Singleton对象的时候才会为其产生实例化对象的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 还未实例化</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当多个线程并发执行 getInstance() 方法时，懒汉式会存在线程安全问题，所以用到了 synchronized 来实现线程的同步，当一个线程获得锁的时候其他线程就只能在外等待其执行完毕。而饿汉式则不存在线程安全的问题。</p><p><strong>适用场景：</strong><br>    单例模式<strong>只允许创建一个对象</strong>，因此<strong>节省内存，加快对象访问速度</strong>，因此<strong>对象需要被公用的场合适合使用</strong>，如多个模块使用同一个数据源连接对象等等。如：<br>    (1) 需要频繁实例化然后销毁的对象。<br>    (2) 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。<br>    (3) 有状态的工具类对象。<br>    (4) 频繁访问数据库或文件的对象。<br>以下都是单例模式的经典使用场景：<br>    (1) 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>    (2) 控制资源的情况下，方便资源之间的互相通信。如线程池等。 </p><h3 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h3><p>一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。 </p><h3 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h3><p>对已有的业务逻辑进一步的封装, 使其增加额外的功能, 要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p><p><strong>适用环境:</strong></p><p>​(1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p><p>​(2) 处理那些可以撤消的职责。</p><p>​(3) 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h3><p>适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h3><h4 id="5-1-简单工厂模式"><a href="#5-1-简单工厂模式" class="headerlink" title="5.1 简单工厂模式"></a>5.1 简单工厂模式</h4><p>简单工厂模式就是把<strong>对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的</strong>，只用告诉工厂我想要什么就行了。而这种方法的缺点也很明显，<strong>违背了设计模式的开闭原则</strong>，因为如果你要增加工厂可以初始化的类的时候，你必须对工厂进行改建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Benz开始启动了。。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Benz停车了。。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ford</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ford开始启动了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ford停车了。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCarInstance</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Benz&quot;</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="title class_">Benz</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Ford&quot;</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> <span class="title class_">Ford</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> Factory.getCarInstance(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            c.run();</span><br><span class="line">            c.stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;造不了这种汽车。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-工厂方法模式"><a href="#5-2-工厂方法模式" class="headerlink" title="5.2 工厂方法模式"></a>5.2 工厂方法模式</h4><p>设计一个工厂的接口，你想要什么东西，就写个类继承于这个工厂，这样就不用修改什么，直接添加就行了。就相当于，我这个工厂是用来生汽车的，而要什么品牌的汽车具体分到了每个车间，如果新多了一种品牌的汽车，直接新增一个车间就行了。那么问题又来了，如果想要生产大炮怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;plane....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broom</span> <span class="keyword">implements</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;broom.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Moveable <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlaneFactory</span> <span class="keyword">extends</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Moveable <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Plane</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BroomFactory</span> <span class="keyword">extends</span> <span class="title class_">VehicleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Moveable <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Broom</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VehicleFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroomFactory</span>();</span><br><span class="line">        <span class="type">Moveable</span> <span class="variable">m</span> <span class="operator">=</span> factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-抽象工厂模式"><a href="#5-3-抽象工厂模式" class="headerlink" title="5.3 抽象工厂模式"></a>5.3 抽象工厂模式</h4><p>与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title function_">createVehicle</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Weapon <span class="title function_">createWeapon</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Food <span class="title function_">createFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">createFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Vehicle <span class="title function_">createVehicle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Weapon <span class="title function_">createWeapon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AK47</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFactory</span>();</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">v</span> <span class="operator">=</span> f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        <span class="type">Weapon</span> <span class="variable">w</span> <span class="operator">=</span> f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        <span class="type">Food</span> <span class="variable">a</span> <span class="operator">=</span> f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 中一般认为有23种设计模式, 下面介绍几种常见的设计模式。总体来说设计模式分为三大类： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式, 共5五种：&lt;strong&gt;工厂方法模式&lt;/strong&gt;、&lt;strong&gt;抽象工厂模式&lt;/strong&gt;、&lt;strong&gt;单例模式&lt;/strong&gt;、建造者模式、原型模式。 &lt;/li&gt;
&lt;li&gt;结构型模式，共7种：&lt;strong&gt;适配器模式&lt;/strong&gt;、&lt;strong&gt;装饰器模式&lt;/strong&gt;、代理模式、外观模式、桥接模式、组合模式、享元模式。 &lt;/li&gt;
&lt;li&gt;行为型模式，共11种：策略模式、模板方法模式、&lt;strong&gt;观察者模式&lt;/strong&gt;、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="javase" scheme="https://imokkkk.github.io/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(三)快递信息查询</title>
    <link href="https://imokkkk.github.io/12221/"/>
    <id>https://imokkkk.github.io/12221/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2020-04-29T02:44:38.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-快递查询API"><a href="#1-快递查询API" class="headerlink" title="1.快递查询API"></a>1.快递查询API</h3><p>这里使用的是阿里云全国快递物流查询-快递查询接口:<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXQuYWxpeXVuLmNvbS9wcm9kdWN0cy81NjkyODAwNC9jbWFwaTAyMTg2My5odG1s">https://market.aliyun.com/products/56928004/cmapi021863.html<i class="fa fa-external-link-alt"></i></span></p><p>该接口支持只通过快递运单号查询物流信息, 不需要在额外设置参数. 该种方式95%能自动识别, 填写查询速度会更快, 已经满足一般开发的需求, 并能极大方便开发者的使用.</p><span id="more"></span><p><strong>请求参数说明</strong><img data-src="/../../../../assets/img/215607.jpg"></p><p><strong>返回结果说明</strong><img data-src="/../../../../assets/img/215818.jpg"></p><p>官方提供的示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;https://wuliu.market.alicloudapi.com&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/kdi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请先替换成自己的AppCode&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">appcode</span> <span class="operator">=</span> <span class="string">&quot;833509fd73fe1124838xxxxxxxx&quot;</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">&quot;no&quot;</span>, <span class="string">&quot;462587770684&quot;</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        querys.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;zto&quot;</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        <span class="comment">//JDK 1.8示例代码请在这里下载：  http://code.fegine.com/Tools.zip</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重要提示如下:</span></span><br><span class="line"><span class="comment">    * HttpUtils请从</span></span><br><span class="line"><span class="comment">    * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">                * 或者直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/HttpUtils.zip</span></span><br><span class="line"><span class="comment">    * 下载</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 相应的依赖请参照</span></span><br><span class="line"><span class="comment">    * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">                * 相关jar包（非pom）直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/aliyun-jar.zip</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">                <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">    <span class="comment">//System.out.println(response.toString());如不输出json, 请打开这行代码，打印调试头部状态码。</span></span><br><span class="line">                <span class="comment">//状态码: 200 正常；400 URL无效；401 appCode错误； 403 次数用完； 500 API网管错误</span></span><br><span class="line">    <span class="comment">//获取response的body</span></span><br><span class="line">          System.out.println(EntityUtils.toString(response.getEntity())); <span class="comment">//输出json</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>正常返回示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span><span class="comment">/* status 0:正常查询 201:快递单号错误 203:快递公司不存在 204:快递公司识别失败 205:没有信息 207:该单号被限制，错误单号 */</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;780098068058&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zto&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-09 11:59:26&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【石家庄市】快件已在【长安三部】 签收,签收人: 本人,感谢使用中通快递,期待再次为您服务!&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-09 09:03:10&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【石家庄市】 快件已到达 【长安三部】（0311-85344265）,业务员 容晓光（13081105270） 正在第1次派件, 请保持电话畅通,并耐心等待&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-08 23:43:44&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【石家庄市】 快件离开 【石家庄】 发往 【长安三部】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-08 21:00:44&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【石家庄市】 快件到达 【石家庄】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-07 01:38:45&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【广州市】 快件离开 【广州中心】 发往 【石家庄】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-07 01:36:53&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【广州市】 快件到达 【广州中心】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-07 00:40:57&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【广州市】 快件离开 【广州花都】 发往 【石家庄中转】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018-03-07 00:01:55&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【广州市】 【广州花都】（020-37738523） 的 马溪 （18998345739） 已揽收&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;deliverystatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">,</span> <span class="comment">/* 0：快递收件(揽件)1.在途中 2.正在派件 3.已签收 4.派送失败 5.疑难件 6.退件签收  */</span></span><br><span class="line"><span class="attr">&quot;issign&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span>                      <span class="comment">/*  1.是否签收                  */</span></span><br><span class="line"><span class="attr">&quot;expName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中通快递&quot;</span><span class="punctuation">,</span>              <span class="comment">/*  快递公司名称                */</span>       </span><br><span class="line"><span class="attr">&quot;expSite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;www.zto.com&quot;</span><span class="punctuation">,</span>           <span class="comment">/*  快递公司官网                */</span></span><br><span class="line"><span class="attr">&quot;expPhone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;95311&quot;</span><span class="punctuation">,</span>                <span class="comment">/*  快递公司电话                */</span></span><br><span class="line"><span class="attr">&quot;courier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;容晓光&quot;</span><span class="punctuation">,</span>                <span class="comment">/*  快递员 或 快递站(没有则为空)*/</span></span><br><span class="line">                <span class="attr">&quot;courierPhone&quot;</span><span class="punctuation">:</span><span class="string">&quot;13081105270&quot;</span><span class="punctuation">,</span>       <span class="comment">/*  快递员电话 (没有则为空)     */</span></span><br><span class="line">                <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2019-08-27 13:56:19&quot;</span><span class="punctuation">,</span> <span class="comment">/*  快递轨迹信息最新时间        */</span></span><br><span class="line">                <span class="attr">&quot;takeTime&quot;</span><span class="punctuation">:</span><span class="string">&quot;2天20小时14分&quot;</span><span class="punctuation">,</span>         <span class="comment">/*  发货到收货消耗时长 (截止最新轨迹)  */</span></span><br><span class="line">                <span class="attr">&quot;logo&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://img3.fegine.com/express/zto.jpg&quot;</span> <span class="comment">/* 快递公司LOGO */</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>失败返回示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;205&quot;</span><span class="punctuation">,</span>   <span class="comment">/* status状态码见产品详情 */</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;没有信息&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1111ADECD1234&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AUTO&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>错误码定义:</p><table><thead><tr><th align="left">错误码</th><th>错误信息</th><th>描述</th></tr></thead><tbody><tr><td align="left">201</td><td>快递单号错误</td><td>status：快递单号错误</td></tr><tr><td align="left">203</td><td>快递公司不存在</td><td>status：快递公司不存在</td></tr><tr><td align="left">204</td><td>快递公司识别失败</td><td>status：快递公司识别失败</td></tr><tr><td align="left">205</td><td>没有信息</td><td>status：没有信息</td></tr><tr><td align="left">207</td><td>该单号被限制，错误单号</td><td>status：该单号被限制，错误单号；一个单号对应多个快递公司，请求须指定快递公司</td></tr><tr><td align="left">0</td><td>正常</td><td>status：正常查询</td></tr></tbody></table><h3 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2.核心代码"></a>2.核心代码</h3><p><strong>工具类:</strong></p><ol><li><p>HttpUtils(官方提供)</p><blockquote><p>下载地址 <span class="exturl" data-url="aHR0cDovL2NvZGUuZmVnaW5lLmNvbS9IdHRwVXRpbHMuemlw">http://code.fegine.com/HttpUtils.zip<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>TextUtil  用于判断输入发送的消息是否为英文字母+数字或纯数字(即符合快递运单号基本规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">DecText</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        Pattern p=Pattern.compile(<span class="string">&quot;^[A-Za-z0-9]+$&quot;</span>);    <span class="comment">//正则表达式</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> p.matcher(text);</span><br><span class="line">        <span class="keyword">return</span>  matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExpressUtil  调用API查询物流信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">QueryExpress</span><span class="params">(String num)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;https://wuliu.market.alicloudapi.com&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/kdi&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">appcode</span> <span class="operator">=</span> <span class="string">&quot;06a9e928218141bxxxxxxx&quot;</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE &quot;</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">&quot;no&quot;</span>, num);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">        <span class="comment">//System.out.println(response.toString());</span></span><br><span class="line">        <span class="comment">//获取response的body</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());<span class="comment">//输出json</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(str);</span><br><span class="line">        <span class="comment">// 获取到key为result的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        jsonObject = JSONObject.parseObject(result);</span><br><span class="line">        <span class="comment">// 获取到key为list的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">list</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时返回的数据为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:45:12&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何海桃】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:45:12&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件在【浙江嘉善公司】进行装车，扫描员【何海桃】，车签号【】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:42:13&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:42:13&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件在【浙江嘉善公司】进行装包，扫描员【何德文】，袋号【9005261902881】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:41:07&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 19:29:40&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【浙江嘉善公司】的【公司称重（)】已收件，扫描员【公司出港1】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-02-29 18:32:52&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>MsgService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TextUtil.DecText(content)==<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ExpressUtil.QueryExpress(content);</span><br><span class="line">                    List&lt;HashMap&gt; r = JSON.parseArray(str, HashMap.class);</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        System.out.println(r.get(i).get(<span class="string">&quot;time&quot;</span>) + <span class="string">&quot;:&quot;</span> + r.get(i).get(<span class="string">&quot;status&quot;</span>));</span><br><span class="line">                        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> r.get(i).get(<span class="string">&quot;time&quot;</span>) + <span class="string">&quot;:&quot;</span> + r.get(i).get(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                            stringBuilder.append(string);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            stringBuilder.append(string).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(stringBuilder);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    <span class="type">TextMessage</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>();</span><br><span class="line">                    text.setContent(stringBuilder+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="3-功能测试"><a href="#3-功能测试" class="headerlink" title="3.功能测试"></a>3.功能测试</h3><p><img data-src="/../../../../assets/img/68078.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-快递查询API&quot;&gt;&lt;a href=&quot;#1-快递查询API&quot; class=&quot;headerlink&quot; title=&quot;1.快递查询API&quot;&gt;&lt;/a&gt;1.快递查询API&lt;/h3&gt;&lt;p&gt;这里使用的是阿里云全国快递物流查询-快递查询接口:&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tYXJrZXQuYWxpeXVuLmNvbS9wcm9kdWN0cy81NjkyODAwNC9jbWFwaTAyMTg2My5odG1s&quot;&gt;https://market.aliyun.com/products/56928004/cmapi021863.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该接口支持只通过快递运单号查询物流信息, 不需要在额外设置参数. 该种方式95%能自动识别, 填写查询速度会更快, 已经满足一般开发的需求, 并能极大方便开发者的使用.&lt;/p&gt;</summary>
    
    
    
    
    <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(二)自动回复功能实现简单的天气查询</title>
    <link href="https://imokkkk.github.io/39972/"/>
    <id>https://imokkkk.github.io/39972/</id>
    <published>2024-02-24T01:58:27.009Z</published>
    <updated>2020-04-29T02:44:38.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>微信公众平台服务器配置通过后，就能进行下面的开发啦</p><blockquote><p>首先可以查看官方的说明文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0dldHRpbmdfU3RhcnRlZC9PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>普通消息的类型分为7种：</p><span id="more"></span><ol><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地理位置消息</li><li>链接消息</li></ol><p>本文使用的是文本消息与图片消息</p><h3 id="2-图文消息的自动回复"><a href="#2-图文消息的自动回复" class="headerlink" title="2.图文消息的自动回复"></a>2.图文消息的自动回复</h3><h4 id="2-1-文本消息"><a href="#2-1-文本消息" class="headerlink" title="2.1 文本消息"></a>2.1 文本消息</h4><p>文本消息的XML结构是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数包含：<img data-src="/../../../../assets/img/203231.jpg"></p><p>定义一个BaseMessage，消息基类，封装通用属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息基类（普通用户 -&gt; 公众帐号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseMessage</span> &#123;</span><br><span class="line">    <span class="comment">// 开发者微信号</span></span><br><span class="line">    <span class="keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="comment">// 发送方帐号（一个OpenID）</span></span><br><span class="line">    <span class="keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="comment">// 消息创建时间 （整型）</span></span><br><span class="line">    <span class="keyword">private</span> String CreateTime;</span><br><span class="line">    <span class="comment">// 消息类型（text/image/location/link）</span></span><br><span class="line">    <span class="keyword">private</span> String MsgType;</span><br><span class="line">    <span class="comment">// 消息id，64位整型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> MsgId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位0x0001被标志时，星标刚收到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> FuncFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义文本消息属性TextMessage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextMessage</span> <span class="keyword">extends</span> <span class="title class_">BaseMessage</span>&#123;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="keyword">private</span> String Content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-图片消息"><a href="#2-2-图片消息" class="headerlink" title="2.2 图片消息"></a>2.2 图片消息</h4><p>图片消息的XML结构是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[image]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[this is a url]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span>&lt;![CDATA[media_id]]&gt;<span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数包含：<img data-src="/../../../../assets/img/215347.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageMessage</span> <span class="keyword">extends</span> <span class="title class_">BaseMessage</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-图文消息"><a href="#2-3-图文消息" class="headerlink" title="2.3 图文消息"></a>2.3 图文消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Description;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片链接，支持JPG、PNG格式，&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 较好的效果为大图640*320，小图80*80</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String PicUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Title;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击图文消息跳转链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 图文消息 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewsMessage</span> <span class="keyword">extends</span> <span class="title class_">BaseMessage</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息个数，限制为10条以内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ArticleCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多条图文消息信息，默认第一个item为大图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Article&gt; Articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><h4 id="3-1-工具类MessageUtil"><a href="#3-1-工具类MessageUtil" class="headerlink" title="3.1 工具类MessageUtil"></a>3.1 工具类MessageUtil</h4><ol><li>解析微信发来的请求（xml）</li><li>将响应消息的Java对象转换成xml</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESP_MESSAGE_TYPE_TEXT</span> <span class="operator">=</span> <span class="string">&quot;text&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：音乐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESP_MESSAGE_TYPE_MUSIC</span> <span class="operator">=</span> <span class="string">&quot;music&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：图文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESP_MESSAGE_TYPE_NEWS</span> <span class="operator">=</span> <span class="string">&quot;news&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_TEXT</span> <span class="operator">=</span> <span class="string">&quot;text&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_IMAGE</span> <span class="operator">=</span> <span class="string">&quot;image&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_LINK</span> <span class="operator">=</span> <span class="string">&quot;link&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：地理位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;location&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：音频</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_VOICE</span> <span class="operator">=</span> <span class="string">&quot;voice&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REQ_MESSAGE_TYPE_EVENT</span> <span class="operator">=</span> <span class="string">&quot;event&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE_SUBSCRIBE</span> <span class="operator">=</span> <span class="string">&quot;subscribe&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE_UNSUBSCRIBE</span> <span class="operator">=</span> <span class="string">&quot;unsubscribe&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EVENT_TYPE_CLICK</span> <span class="operator">=</span> <span class="string">&quot;CLICK&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml转换为map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">xmlToMap</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = request.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = reader.read(ins);</span><br><span class="line">            <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getRootElement();</span><br><span class="line"></span><br><span class="line">            List&lt;Element&gt; list = root.elements();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Element e : list) &#123;</span><br><span class="line">                map.put(e.getName(), e.getText());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 解析微信发来的请求（XML）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月7日 上午10:04:02</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">parseXml</span><span class="params">(HttpServletRequest request)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将解析结果存储在HashMap中</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 从request中取得输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        <span class="comment">// 读取输入流</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(inputStream);</span><br><span class="line">        <span class="comment">// 得到xml根元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">// 得到根元素的所有子节点</span></span><br><span class="line">        List&lt;Element&gt; elementList = root.elements();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> (Element e : elementList) &#123;</span><br><span class="line">            map.put(e.getName(), e.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public static XStream xstream = new XStream();</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本消息对象转换成xml</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textMessage 文本消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> xml</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">textMessageToXml</span><span class="params">(TextMessage textMessage)</span>&#123;</span><br><span class="line"><span class="comment">//        XStream xstream = new XStream();</span></span><br><span class="line">        xstream.alias(<span class="string">&quot;xml&quot;</span>, textMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图文消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> newsMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月8日 下午4:14:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">newsMessageToXml</span><span class="params">(NewsMessage newsMessage)</span> &#123;</span><br><span class="line">        xstream.alias(<span class="string">&quot;xml&quot;</span>, newsMessage.getClass());</span><br><span class="line">        xstream.alias(<span class="string">&quot;item&quot;</span>, <span class="keyword">new</span> <span class="title class_">Article</span>().getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(newsMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图片消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> imageMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月9日 上午9:25:51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">imageMessageToXml</span><span class="params">(ImageMessage imageMessage)</span> &#123;</span><br><span class="line">        xstream.alias(<span class="string">&quot;xml&quot;</span>, imageMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(imageMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象到xml的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">XStream</span> <span class="variable">xstream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XStream</span>(<span class="keyword">new</span> <span class="title class_">XppDriver</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> HierarchicalStreamWriter <span class="title function_">createWriter</span><span class="params">(Writer out)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrettyPrintWriter</span>(out) &#123;</span><br><span class="line">                <span class="comment">// 对所有xml节点的转换都增加CDATA标记</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">cdata</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startNode</span><span class="params">(String name, Class clazz)</span> &#123;</span><br><span class="line">                    <span class="built_in">super</span>.startNode(name, clazz);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeText</span><span class="params">(QuickWriter writer, String text)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cdata) &#123;</span><br><span class="line">                        writer.write(<span class="string">&quot;&lt;![CDATA[&quot;</span>);</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                        writer.write(<span class="string">&quot;]]&gt;&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h4><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复<code>文本</code>、<code>图片</code>、<code>图文</code>、<code>语音</code>、<code>视频</code>、<code>音乐</code>）。</p><p>上一篇文章，已经创建了IndexController ，里面的GET方法用来验证token，下面直接加一个POST方法，用于进行消息管理。消息接收<code>POST</code>和微信认证<code>GET</code>是同一个接口（开发者填写的URL）</p><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgProcess</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用核心业务类接收消息、处理消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">respMessage</span> <span class="operator">=</span> msgService.processRequest(request);</span><br><span class="line">    <span class="comment">// 响应消息</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        out.print(respMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        out = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(MsgService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">respMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fromUserName</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;FromUserName&quot;</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">toUserName</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;ToUserName&quot;</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msgType</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;MsgType&quot;</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> requestMap.get(<span class="string">&quot;Content&quot;</span>);</span><br><span class="line">            LOGGER.info(<span class="string">&quot;FromUserName is:&quot;</span> + fromUserName + <span class="string">&quot;, ToUserName is:&quot;</span> + toUserName + <span class="string">&quot;, MsgType is:&quot;</span> + msgType);</span><br><span class="line">            <span class="comment">// 文本消息</span></span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123;</span><br><span class="line">                <span class="comment">//这里根据关键字执行相应的逻辑，只有你想不到的，没有做不到的</span></span><br><span class="line">                <span class="keyword">if</span> (content.indexOf(<span class="string">&quot;天气&quot;</span>)!=-<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    <span class="type">NewsMessage</span> <span class="variable">newmsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewsMessage</span>();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">                    article.setTitle(<span class="string">&quot;天气预报&quot;</span>);</span><br><span class="line">                    article.setDescription(<span class="string">&quot;点击了解未来天气详情...&quot;</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">&quot;https://lwy-image.oss-cn-beijing.aliyuncs.com/ep.png&quot;</span>);</span><br><span class="line">                    article.setUrl(<span class="string">&quot;https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=auto&amp;key=f1688db9422246fc969a6ba559075097&quot;</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;error......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<img data-src="/../../../../assets/img/06215027.jpg"></p><blockquote><p>源码参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pob3VtaW5wei93ZWNoYXRQdWJsaWNBY2NvdW50LQ==">https://github.com/zhouminpz/wechatPublicAccount-<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;微信公众平台服务器配置通过后，就能进行下面的开发啦&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先可以查看官方的说明文档：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0dldHRpbmdfU3RhcnRlZC9PdmVydmlldy5odG1s&quot;&gt;https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;普通消息的类型分为7种：&lt;/p&gt;</summary>
    
    
    
    
    <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发常用命令</title>
    <link href="https://imokkkk.github.io/Vue_shell/"/>
    <id>https://imokkkk.github.io/Vue_shell/</id>
    <published>2024-02-24T01:58:26.995Z</published>
    <updated>2020-05-28T06:27:34.810Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-创建vue脚手架项目"><a href="#1-创建vue脚手架项目" class="headerlink" title="1.创建vue脚手架项目"></a>1.创建vue脚手架项目</h4>   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">init</span> webpack 项目名</span><br></pre></td></tr></table></figure><h4 id="2-axios"><a href="#2-axios" class="headerlink" title="2.axios"></a>2.axios</h4><ol><li><p>安装axios</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save-dev</span><br></pre></td></tr></table></figure></li><li><p>配置main.js中引入axios</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$http</span>=axios;</span><br></pre></td></tr></table></figure></li><li><p>使用axios<br>在需要发送异步请求的位置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(</span><br><span class="line">        <span class="string">&quot;url&quot;</span></span><br><span class="line">      )</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-ElementUI"><a href="#3-ElementUI" class="headerlink" title="3.ElementUI"></a>3.ElementUI</h4><ol><li><p>安装ElementUI</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure></li><li><p>配置main.js中引入ElementUI</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在vue脚手架中使用elementui</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-项目打包"><a href="#4-项目打包" class="headerlink" title="4.项目打包"></a>4.项目打包</h4><ol><li><p>打包<br>在项目根目录中执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><code>注意:vue脚手架打包的项目必须在服务器上运行不能直接双击运行</code></p></li><li><p>打包之后当前项目中变化<br>在打包之后项目中出现dist目录,dist目录就是vue脚手架项目生产目录或者说是直接部署目录</p></li><li><p>与后端合并部署<br>复制dist目录到Java工程resource下的static文件夹,index.html中修改路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">/dist/static/css/app...../</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">text/javascript</span> <span class="attr">src</span>=<span class="string">/dist/static/js/ma....</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>访问项目<br>浏览器访问:  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2Rpc3QvaW5kZXguaHRtbA==">http://localhost:8080/dist/index.html<i class="fa fa-external-link-alt"></i></span></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-创建vue脚手架项目&quot;&gt;&lt;a href=&quot;#1-创建vue脚手架项目&quot; class=&quot;headerlink&quot; title=&quot;1.创建vue脚手架项目&quot;&gt;&lt;/a&gt;1.创建vue脚手架项目&lt;/h4&gt;   &lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vue &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; webpack 项目名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;2-axios&quot;&gt;&lt;a href=&quot;#2-axios&quot; class=&quot;headerlink&quot; title=&quot;2.axios&quot;&gt;&lt;/a&gt;2.axios&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装axios&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install axios --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置main.js中引入axios&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://imokkkk.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://imokkkk.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>top K问题的优化解法</title>
    <link href="https://imokkkk.github.io/1060/"/>
    <id>https://imokkkk.github.io/1060/</id>
    <published>2024-02-24T01:58:26.995Z</published>
    <updated>2020-04-29T02:44:38.006Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="top-K问题的优化解法"><a href="#top-K问题的优化解法" class="headerlink" title="top K问题的优化解法"></a>top K问题的优化解法</h3><p>​在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。</p><span id="more"></span><p><strong>100亿数据找出最大的1000个数字</strong></p><p><strong>对于海量数据处理，思路基本上是：必须分块处理，然后再合并起来。</strong></p><h4 id="1-局部淘汰法"><a href="#1-局部淘汰法" class="headerlink" title="1.局部淘汰法"></a>1.局部淘汰法</h4><p>​用一个容器保存前1000个数，然后将剩余的所有数字一一与容器内的最小数字相比，如果所有后续的元素都比容器内的1000个数还小，那么容器内这个1000个数就是最大1000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O(n+m^2)，其中m为容器的大小。</p><p>​这个容器可以用（小顶堆）<strong>最小堆</strong>来实现。我们知道完全二叉树有几个非常重要的特性，就是假如该二叉树中总共有N个节点，那么该二叉树的深度就是log2N，对于小顶堆来说移动根元素到底部或者移动底部元素到根部只需要log2N，相比N来说时间复杂度优化太多了（1亿的logN值是26-27的一个浮点数）。基本的思路就是<strong>先从文件中取出1000个元素构建一个小顶堆数组k，然后依次对剩下的100亿-1000个数字进行遍历m，如果m大于小顶堆的根元素，即k[0]，那么用m取代k[0]，对新的数组进行重新构建组成一个新的小顶堆。</strong>这个算法的时间复杂度是O((100亿-1000)log(1000))，即O((N-M)logM)，空间复杂度是M</p><p>这个算法优点是性能尚可，<strong>空间复杂度低</strong>，<strong>IO读取比较频繁</strong>，对系统压力大。</p><h4 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2.分治法"></a>2.分治法</h4><p>(1) 将100亿个数据分为1000个大分区，每个区1000万个数据</p><p>(2) 每个大分区再细分成100个小分区。总共就有1000*100&#x3D;10万个分区</p><p>(3) 计算每个小分区上最大的1000个数</p><p>(4) 合并每个大分区细分出来的小分区。每个大分区有100个小分区，我们已经找出了每个小分区的前1000个数。将这100个分区的1000*100个数合并，找出每个大分区的前1000个数</p><p>(5) 合并大分区。我们有1000个大分区，上一步已找出每个大分区的前1000个数。我们将这1000*1000个数合并，找出前1000.这1000个数就是所有数据中最大的1000个数</p><h4 id="3-Hash法"><a href="#3-Hash法" class="headerlink" title="3.Hash法"></a>3.Hash法</h4><p>​如果这1亿个数据里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的1000个数。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;top-K问题的优化解法&quot;&gt;&lt;a href=&quot;#top-K问题的优化解法&quot; class=&quot;headerlink&quot; title=&quot;top K问题的优化解法&quot;&gt;&lt;/a&gt;top K问题的优化解法&lt;/h3&gt;&lt;p&gt;​	在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://imokkkk.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一个Java对象的大小怎么计算？</title>
    <link href="https://imokkkk.github.io/javaobjectsize/"/>
    <id>https://imokkkk.github.io/javaobjectsize/</id>
    <published>2024-02-24T01:58:26.995Z</published>
    <updated>2022-06-27T02:20:42.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个Java对象的大小怎么计算？"><a href="#一个Java对象的大小怎么计算？" class="headerlink" title="一个Java对象的大小怎么计算？"></a>一个Java对象的大小怎么计算？</h2><p><strong>对象头+实例数据+对其填充</strong></p><p><strong>对象头</strong></p><ol><li>MarkWord：用于存储对象运行时的数据，如hashCode、锁状态标志、GC分代年龄等。<strong>64位操作系统占8字节，32位操作系统占4字节。</strong></li><li>对象元数据指针(kclass)：对象指向类的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。<strong>开启压缩指针占4字节，未开启占8字节。</strong></li><li>数组长度：<strong>只有数组对象才有，占4字节。</strong></li></ol><span id="more"></span><p><strong>实例数据</strong></p><p>实例数据可能包括两种：</p><ol><li><p>8种基本数据类型</p><table><thead><tr><th>类型</th><th>占用空间</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>char</td><td>2</td></tr><tr><td>short</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr><tr><td>Reference</td><td>4</td></tr></tbody></table></li><li><p>对象</p></li></ol><p><strong>对其填充(Padding)</strong></p><p>Java对象内存起始地址必须为8的整数倍，即Java对象大小必须为8的整数倍。当对象头+实例数据大小不为8的整数倍时，将会使用对其填充。</p><p>如64位，开启压缩指针的虚拟机上new Object()实际大小：</p><p>Mark Word(8B) + kclass(4B) + Padding(4B) &#x3D; 16B</p><p><strong>例子</strong></p><ol><li><pre><code class="java">// Mark Word(8B) + kclass(4B) + i(4B) = 16Bpublic class Object1&#123;    private int i;&#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> ```java</span><br><span class="line">   <span class="comment">// Mark Word(8B) + kclass(4B) + i(4B) + j(4B) + s(4B) + b(1B) + c(2B) + Padding(5B) = 32B</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectSizeTest</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> j;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">String</span> s;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">boolean</span> b;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">char</span> c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">// HotSpot创建的对象的字段会默认按从长到短，引用排最后排序：long/double --&gt; int/float --&gt; short/char --&gt; byte/boolean --&gt;Reference//Mark Word(8B) + kclass(4B) + i1(4B) + i2(4B) + b1(1B) + b2(1B) + b3(1B) + Padding(1B) + s(4B) + obj(4B) = 32Bpublic class ObjectSizeTest &#123;    private String s; // 4    private int i1; // 4    private byte b1; // 1    private byte b2; // 1    private int i2;// 4    private Object obj; //4    private byte b3;  // 1&#125;</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一个Java对象的大小怎么计算？&quot;&gt;&lt;a href=&quot;#一个Java对象的大小怎么计算？&quot; class=&quot;headerlink&quot; title=&quot;一个Java对象的大小怎么计算？&quot;&gt;&lt;/a&gt;一个Java对象的大小怎么计算？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;对象头+实例数据+对其填充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象头&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MarkWord：用于存储对象运行时的数据，如hashCode、锁状态标志、GC分代年龄等。&lt;strong&gt;64位操作系统占8字节，32位操作系统占4字节。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对象元数据指针(kclass)：对象指向类的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。&lt;strong&gt;开启压缩指针占4字节，未开启占8字节。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数组长度：&lt;strong&gt;只有数组对象才有，占4字节。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://imokkkk.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://imokkkk.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>代理模式(JDK Proxy与CGLIB Proxy)</title>
    <link href="https://imokkkk.github.io/proxymode/"/>
    <id>https://imokkkk.github.io/proxymode/</id>
    <published>2024-02-24T01:58:26.995Z</published>
    <updated>2021-05-23T14:36:45.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><ol><li><p>售卖香水接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义真实对象和代理对象的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellPerfume</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellPerfume</span><span class="params">(<span class="type">double</span> price)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义香水提供商，实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChanelFactory</span> <span class="keyword">implements</span> <span class="title class_">SellPerfume</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellPerfume</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买香奈儿品牌的香水，价格是：&quot;</span> + price + <span class="string">&quot;元！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li><li><p>定义代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoHongSellProxy</span> <span class="keyword">implements</span> <span class="title class_">SellPerfume</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代理对象内部保存对真实目标对象的引用，控制其它对象对目标对象的访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChanelFactory chanelFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XiaoHongSellProxy</span><span class="params">(ChanelFactory chanelFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chanelFactory = chanelFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellPerfume</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        doSomethingBeforeSell();</span><br><span class="line">        chanelFactory.sellPerfume(price);</span><br><span class="line">        doSomethingAfterSell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingBeforeSell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小红代理购买香水前的额外操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingAfterSell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小红代理购买香水后的额外操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>购买香水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 访问者仅能通过代理对象访问真实目标对象，不可直接访问目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChanelFactory</span> <span class="variable">chanelFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChanelFactory</span>();</span><br><span class="line">        <span class="type">XiaoHongSellProxy</span> <span class="variable">xiaoHongSellProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoHongSellProxy</span>(chanelFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 代理对象并不是真正提供服务的对象，它只是替访问者访问目标对象的一个中间人，</span></span><br><span class="line"><span class="comment">         * 真正提供服务的还是目标对象，而代理对象的作用就是在目标对象提供服务之前或之后能够执行额外的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        xiaoHongSellProxy.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小红代理购买香水前的额外操作...</span><br><span class="line">成功购买香奈儿品牌的香水，价格是：<span class="number">100.0</span>元！</span><br><span class="line">小红代理购买香水后的额外操作...</span><br></pre></td></tr></table></figure></li></ol><p><strong>代理模式的定义：</strong>给目标对象提供一个代理对象，代理对象包含该目标对象，并控制对该目标对象的访问。</p><p><strong>代理模式的目的：</strong>通过代理对象的隔离，可以在对目标对象的访问前后增加额外的业务逻辑，实现功能增强；通过代理对象访问目标对象，可以防止系统大量的直接对目标对象进行不正确的访问。</p><h3 id="2-静态代理与动态代理"><a href="#2-静态代理与动态代理" class="headerlink" title="2.静态代理与动态代理"></a>2.静态代理与动态代理</h3><p><strong>共同点：</strong>都能实现代理模式；代理对象和目标对象都需要实现一个公共接口。</p><p><strong>不同点：</strong></p><ul><li>动态代理产生代理对象的时机是<strong>运行时动态生成</strong>，它没有Java源文件，<strong>直接生成字节码文件实例化代理对象</strong>，而静态代理的代理对象，在<strong>程序编译时</strong>已经写好了Java文件，直接new一个代理对象即可。</li><li>动态代理比静态代理更加稳健，对程序的可维护性和扩展性更加友好。</li></ul><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>面对新的需求时，不需要修改代理对象的代码，只需要新增接口对象，在客户端调用即可完成新的代理。</p><h4 id="3-1-JDK-Proxy"><a href="#3-1-JDK-Proxy" class="headerlink" title="3.1 JDK Proxy"></a>3.1 JDK Proxy</h4><p>JDK提供的一个动态代理机制，涉及到Proxy和InvocationHandler两个核心类。</p><p><strong>代理对象是在程序运行过程中，有代理工厂动态生成，代理对象本身不存在Java源文件。</strong></p><p>代理工厂需要实现InvocationHanlder接口并实现invoke()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SellProxyFactory</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行代理后的额外操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行代理前的额外操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 真正执行的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 调用第二个参数method时传入的参数列表值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invokeObject</span> <span class="operator">=</span> method.invoke(object, args);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成代理对象需要用到Proxy类，里面的静态方法newProxyInstance可以生成任意一个代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loader 加载动态代理的类的类加载器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 代理类实现的接口，可以传入多个接口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 指定代理类的调用处理程序，即调用接口中的方法时，会找到该代理工厂h，执行invoke()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure><p><strong>新增红酒代理功能：</strong></p><ul><li><p>创建新的红酒供应商和售卖红酒接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 红酒供应商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedWineFactory</span> <span class="keyword">implements</span> <span class="title class_">SellWine</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SellWine</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功售卖一瓶红酒，价格：&quot;</span> + price + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 售卖红酒接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellWine</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">SellWine</span><span class="params">(<span class="type">double</span> price)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在客户端实例化一个代理对象，然后向该代理对象购买红酒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// buyChannel();</span></span><br><span class="line">        buyRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buyChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ChanelFactory</span> <span class="variable">chanelFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChanelFactory</span>();</span><br><span class="line">        <span class="type">SellProxyFactory</span> <span class="variable">sellProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellProxyFactory</span>(chanelFactory);</span><br><span class="line">        <span class="type">SellPerfume</span> <span class="variable">sellPerfume</span> <span class="operator">=</span> (SellPerfume)Proxy.newProxyInstance(chanelFactory.getClass().getClassLoader(),</span><br><span class="line">            chanelFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        sellPerfume.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buyRedWine</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化一个红酒供应商</span></span><br><span class="line">        <span class="type">RedWineFactory</span> <span class="variable">redWineFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedWineFactory</span>();</span><br><span class="line">        <span class="comment">// 实例化代理工厂，传入红酒供应商引用控制对其的访问</span></span><br><span class="line">        <span class="type">SellProxyFactory</span> <span class="variable">sellProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellProxyFactory</span>(redWineFactory);</span><br><span class="line">        <span class="comment">// 实例化代理对象</span></span><br><span class="line">        <span class="type">SellWine</span> <span class="variable">sellWine</span> <span class="operator">=</span> (SellWine)Proxy.newProxyInstance(redWineFactory.getClass().getClassLoader(),</span><br><span class="line">            redWineFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        <span class="comment">// 代理售卖红酒</span></span><br><span class="line">        sellWine.SellWine(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong></p><ol><li>JDK动态代理的使用方法<ul><li>代理工厂需要实现InvocationHandle接口，调用代理方法会转向执行invoke()方法。</li><li>生成代理对象需要使用Proxy对象中的newProxyInsatnce()方法，返回对象可强转成传入的其中一个接口，然后调用接口方法即可实现代理。</li></ul></li><li>JDK动态代理的特点<ul><li>目标对象强制需要实现一个接口，否则无法使用JDK动态代理。</li></ul></li></ol><h4 id="3-2-CGLIB"><a href="#3-2-CGLIB" class="headerlink" title="3.2 CGLIB"></a>3.2 CGLIB</h4><p>CGLIB不是JDK自带的动态代理，它需要导入第三方依赖，它是一个字节码生成类库，能够在运行时动态生成代理类对Java类和Java接口扩展。CGLIB不仅能够为Java接口做代理，而且<strong>能够为普通的Java类做代理</strong>，而JDK Proxy只能为实现了接口的Java类做代理。</p><p><strong>CGLIB可以代理没有实现接口的Java类</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CGLIB代理中有两个核心的类：MetondInterceptor接口和Enhancer类，前者是实现一个代理工厂的根接口，后者是创建动态代理对象的类。</p><p>定义代理工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 关联真实对象，控制真实对象的访问</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从代理工厂获取一个代理对象实例，等价于创建小红代理</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置需要增强类的类加载器</span></span><br><span class="line">        enhancer.setClassLoader(object.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类，真实对象</span></span><br><span class="line">        enhancer.setSuperclass(object.getClass());</span><br><span class="line">        <span class="comment">// 设置方法拦截器，代理工厂</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行方法前额外的操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomethingAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行方法后额外的操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 被代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 被拦截方法的所有入参值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理，用于调用原始的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invokeSuperObject</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeSuperObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellProxyFactory</span> <span class="variable">sellProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取一个代理实例</span></span><br><span class="line">        <span class="type">ChanelFactory</span> <span class="variable">chanelFactoryInstance</span> <span class="operator">=</span> (ChanelFactory) sellProxyFactory.getProxyInstance(<span class="keyword">new</span> <span class="title class_">ChanelFactory</span>());</span><br><span class="line">        chanelFactoryInstance.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li><p>CGLIB的使用方法</p><ul><li>代理工厂需要<strong>实现MethodInterceptor接口</strong>，并重写方法，<strong>内部关联真实对象</strong>，控制第三者对真实对象的访问；代理工厂内部暴露getInstance(Object object)方法，<strong>用于从代理工厂中获取一个代理对象实例</strong>。</li><li>Enhancer类用于从代理工厂中实例化一个代理对象，给调用者提供代理服务。</li></ul></li><li><p>JDK Proxy和CGLIB的对比</p><table><thead><tr><th></th><th>JDK Proxy</th><th>CGLIB</th></tr></thead><tbody><tr><td>代理工厂实现接口</td><td>InvocationHandler</td><td>MethodInterceptor</td></tr><tr><td>构造代理对象给Client服务</td><td>Proxy</td><td>Enhancer</td></tr></tbody></table><p><strong>不同点：</strong></p><ul><li>CGLIB可以代理大部分类；而JDK Proxy仅能够代理实现了接口的类</li><li>CGLIB采用动态创建被代理类的子类实现方法拦截的方法，所以CGLIB不能代理被final关键字修饰的类和方法。</li></ul></li></ol></li></ol><h3 id="4-动态代理的实际运用"><a href="#4-动态代理的实际运用" class="headerlink" title="4.动态代理的实际运用"></a>4.动态代理的实际运用</h3><p>AOP允许我们<strong>将重复的代码逻辑抽取出来形成一个单独的覆盖层</strong>，在执行代码时可以将覆盖层嵌入到原代码逻辑里面去。</p><p>如下图，method1和method2都需要在方法执行前后记录日志，AOP可以将大量重复的Log.info代码包装到额外的一层，监听方法的执行，当方法被调用时，通用的日志记录层会拦截掉该方法，在该方法调用前后记录日志，这样可以让方法专注于自己的业务逻辑而无需关注其它不必要的信息。</p><p><img data-src="/../../../../assets/img/640.gif"></p><p>Spring AOP有许多功能：提供缓存、提供日志环绕、事务处理……</p><p><strong>事务</strong></p><p>@Transactional</p><p>每个有关数据库的操作都有保证一个事务内的所有操作，要么全部执行成功，要么全部执行失败，传统的事务失败回滚和成功提交是使用try…catch代码块完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    session = getSqlSessionFactory().openSession(<span class="literal">false</span>);</span><br><span class="line">    session.update(<span class="string">&quot;...&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    <span class="comment">// 事务提交</span></span><br><span class="line">    session.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// 事务回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭事务</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个方法都需要写这一段逻辑非常冗余，所以Spring封装了一个注解@Transactional，使用它后，调用方法时会监视方法，如果方法上含有该注解，就会自动把数据库相关操作的代码包裹起来，类似上面一段代码。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-静态代理&quot;&gt;&lt;a href=&quot;#1-静态代理&quot; class=&quot;headerlink&quot; title=&quot;1.静态代理&quot;&gt;&lt;/a&gt;1.静态代理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;售卖香水接口&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 定义真实对象和代理对象的公共接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;SellPerfume&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;sellPerfume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;double&lt;/span&gt; price)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义香水提供商，实现接口&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ChanelFactory&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;SellPerfume&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;sellPerfume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;double&lt;/span&gt; price)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;成功购买香奈儿品牌的香水，价格是：&amp;quot;&lt;/span&gt; + price + &lt;span class=&quot;string&quot;&gt;&amp;quot;元！&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
    <category term="代理模式" scheme="https://imokkkk.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用tree命令导出文件夹/文件的目录树</title>
    <link href="https://imokkkk.github.io/shell_tree/"/>
    <id>https://imokkkk.github.io/shell_tree/</id>
    <published>2024-02-24T01:58:26.995Z</published>
    <updated>2020-05-01T13:37:12.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Windows和Linux都有tree命令，主要功能是创建文件列表，将所有文件以树的形式列出来</p><h3 id="1-Windows的tree命令"><a href="#1-Windows的tree命令" class="headerlink" title="1.Windows的tree命令"></a>1.Windows的tree命令</h3><p>使用tree命令导出windows的文件夹&#x2F;文件的目录树</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE <span class="selector-attr">[drive:]</span><span class="selector-attr">[path]</span> <span class="selector-attr">[/F]</span> <span class="selector-attr">[/A]</span></span><br><span class="line">/F   显示每个文件夹中文件的名称。（带扩展名）</span><br><span class="line">/<span class="selector-tag">A</span>   使用 ASCII 字符，而不使用扩展字符。(如果要显示中文，例如 tree /f /<span class="selector-tag">A</span> &gt;tree<span class="selector-class">.txt</span>)</span><br><span class="line">tree /f &gt; list<span class="selector-class">.txt</span>  将带扩展名的文件目录输出到list<span class="selector-class">.txt</span>文件中</span><br></pre></td></tr></table></figure><h3 id="2-Linux的tree命令"><a href="#2-Linux的tree命令" class="headerlink" title="2.Linux的tree命令"></a>2.Linux的tree命令</h3><p>Linux下的tree就比较强大了，但一般系统并不自带这个命令，需要手动下载安装：sudo apt-get install tree 。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-a 显示所有文件和目录。</span></span><br><span class="line"><span class="deletion">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span></span><br><span class="line"><span class="deletion">-C 在文件和目录清单加上色彩，便于区分各种类型。</span></span><br><span class="line"><span class="deletion">-d 显示目录名称而非内容。</span></span><br><span class="line"><span class="deletion">-D 列出文件或目录的更改时间。</span></span><br><span class="line"><span class="deletion">-f 在每个文件或目录之前，显示完整的相对路径名称。</span></span><br><span class="line"><span class="deletion">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。</span></span><br><span class="line"><span class="deletion">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span></span><br><span class="line"><span class="deletion">-i 不以阶梯状列出文件或目录名称。</span></span><br><span class="line"><span class="deletion">-I 不显示符合范本样式的文件或目录名称。</span></span><br><span class="line"><span class="deletion">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span></span><br><span class="line"><span class="deletion">-n 不在文件和目录清单加上色彩。</span></span><br><span class="line"><span class="deletion">-N 直接列出文件和目录名称，包括控制字符。</span></span><br><span class="line"><span class="deletion">-p 列出权限标示。</span></span><br><span class="line"><span class="deletion">-P 只显示符合范本样式的文件或目录名称。</span></span><br><span class="line"><span class="deletion">-q 用&quot;?&quot;号取代控制字符，列出文件和目录名称。</span></span><br><span class="line"><span class="deletion">-s 列出文件或目录大小。</span></span><br><span class="line"><span class="deletion">-t 用文件和目录的更改时间排序。</span></span><br><span class="line"><span class="deletion">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span></span><br><span class="line"><span class="deletion">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span></span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>执行命令行<code>tree /f &gt; tree.txt</code></p><p><img data-src="/../../../../assets/img/105116.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows和Linux都有tree命令，主要功能是创建文件列表，将所有文件以树的形式列出来&lt;/p&gt;
&lt;h3 id=&quot;1-Windows的tree命令&quot;&gt;&lt;a href=&quot;#1-Windows的tree命令&quot; class=&quot;headerlink&quot; title=&quot;1.Windows的tree命令&quot;&gt;&lt;/a&gt;1.Windows的tree命令&lt;/h3&gt;&lt;p&gt;使用tree命令导出windows的文件夹&amp;#x2F;文件的目录树&lt;/p&gt;</summary>
    
    
    
    <category term="shell" scheme="https://imokkkk.github.io/categories/shell/"/>
    
    
    <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>SQL执行慢分析及SQL语句优化</title>
    <link href="https://imokkkk.github.io/31546/"/>
    <id>https://imokkkk.github.io/31546/</id>
    <published>2024-02-24T01:58:26.993Z</published>
    <updated>2020-04-29T02:44:37.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-SQL语句执行速度慢"><a href="#1-SQL语句执行速度慢" class="headerlink" title="1.SQL语句执行速度慢"></a>1.SQL语句执行速度慢</h3><p>一个SQL语句执行的速度很慢, 分两种情况讨论:</p><ul><li><p>大多数情况下很正常, 偶尔很慢, 则有如下原因:</p><ol><li>数据库在刷新脏页</li><li>执行的时候, 遇到锁, 如表锁, 行锁</li></ol></li><li><p>一直执行很慢, 则有如下原因</p></li></ul><span id="more"></span><ol><li>没有用上索引: 例如该字段没有索引, 由于对字段进行运算, 函数操作导致无法使用索引</li><li>数据库选错了索引</li></ol><h3 id="2-SQL语句的优化"><a href="#2-SQL语句的优化" class="headerlink" title="2.SQL语句的优化"></a>2.SQL语句的优化</h3><ol><li><p>设置合适的字段属性</p><p> 字段的长度越小, 占用的内存越小, 性能就越好; 例如,中国的手机号码为11位, vachar的长度设置为11位即可</p></li><li><p>使用join语法</p><p>join语法分为内连接, 左(外)连接, 右(外)连接</p></li><li><p>尽量少使用select *</p><p>select *会进行全表查询, 消耗的性能较大</p></li><li><p>在查找唯一一条数据的时候, 使用limit 1, 在查找到数据的时候会终止查找</p></li><li><p>使用limit分页</p></li><li><p>尽量少使用排序order by, order by DESC, order by ASC</p></li><li><p>避免进行类型转换</p></li><li><p>使用索引</p><ul><li><p>优点: 加快索引速度</p></li><li><p>缺点: 创建索引和维护索引需要耗费时间和精力</p><p>​  索引需要占用空间</p><p>​  进行数据的增删改查时需要动态维护索引</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-SQL语句执行速度慢&quot;&gt;&lt;a href=&quot;#1-SQL语句执行速度慢&quot; class=&quot;headerlink&quot; title=&quot;1.SQL语句执行速度慢&quot;&gt;&lt;/a&gt;1.SQL语句执行速度慢&lt;/h3&gt;&lt;p&gt;一个SQL语句执行的速度很慢, 分两种情况讨论:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大多数情况下很正常, 偶尔很慢, 则有如下原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库在刷新脏页&lt;/li&gt;
&lt;li&gt;执行的时候, 遇到锁, 如表锁, 行锁&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一直执行很慢, 则有如下原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://imokkkk.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Sping Cloud组件扩展</title>
    <link href="https://imokkkk.github.io/SpringCloud_02/"/>
    <id>https://imokkkk.github.io/SpringCloud_02/</id>
    <published>2024-02-24T01:58:26.978Z</published>
    <updated>2021-03-17T14:13:35.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-Apollo"><a href="#1-Apollo" class="headerlink" title="1.Apollo"></a>1.Apollo</h3><p>统一管理配置信息，增强配置管理的服务能力。<br><img data-src="/../../../../assets/img/CgotOV28B1WAF4S2AACIYGiePW0196.png"><br>使用配置中心管理配置后，可以将配置信息从项目转移到配置中心，一般一个项目会有一个唯一的标识ID，通过这个ID从配置中心获取对应的配置内容。</p><span id="more"></span><ol><li>拉取<br>项目在启动的时候通过配置中心拉取配置信息。</li><li>推送<br>在配置中心修改配置后，可以实时地推送给客户端进行更新。</li></ol><p>解决的问题：每个节点都要重启、格式不规范、容易被错改、没有历史记录、安全性不高</p><h4 id="1-1-主要功能"><a href="#1-1-主要功能" class="headerlink" title="1.1 主要功能"></a>1.1 主要功能</h4><ul><li>统一管理不同环境、不同集群的配置</li><li>配置修改实时生效，即热发布功能</li><li>版本发布管理</li><li>灰度发布</li><li>权限管理、发布审核、操作审计</li><li>提供Java和.Net原生客户端，轻松集成、操作简单</li><li>提供开放平台API</li><li>部署简单<br><strong>Apollo 和 Spring Cloud Config 对比</strong><br><img data-src="/../../../../assets/img/CgoB5l28B1WASOkYAAA7y7Kuj4o675.png"></li></ul><h4 id="1-2-概念介绍"><a href="#1-2-概念介绍" class="headerlink" title="1.2 概念介绍"></a>1.2 概念介绍</h4><ul><li><p>应用<br>应用指项目，标识用appId来指定，Spring Boot项目中建议直接配置在application.yml中。</p></li><li><p>环境<br>Apollo客户端在运行时除了需要知道项目当前的身份标识，还需要知道当前项目对应的环境，从而根据环境去配置中心获取对应的配置。可以通过Java System Property或配置文件指定，目前支持的环境有Local、DEV、FAT(测试环境)、UAT(集成环境)、PRO(生产环境)。</p></li><li><p>集群<br>不同的集群可以有不同的配置文件，可以通过Java System Property或配置文件来指定。</p></li><li><p>命名空间<br>可以用来对配置做分类，不同类型的配置存放在不同的命名空间中，如数据库配置文件、消息队列配置、业务相关配置等。命名空间还可以让多个项目共用一份配置，如Redis集群。</p></li><li><p>权限控制</p></li></ul><h4 id="1-3-架构设计"><a href="#1-3-架构设计" class="headerlink" title="1.3 架构设计"></a>1.3 架构设计</h4><p><img data-src="/../../../../assets/img/CgoB5l28B1eAT_QKAAIrr-cSeiQ864.png"></p><ul><li><p>Config Service<br>服务于Client对配置的操作，提供配置的查询、更新接口(基于Http long polling)</p></li><li><p>Admin Service<br>服务于后台Portal(Web管理端)，提供配置管理接口</p></li><li><p>Meta Server<br><strong>Meta Server是对Eureka的一个封装，提供了HTTP接口获取Admin Service和Config Service的服务信息。</strong>部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致。</p></li><li><p>Eureka<br>用于提供服务注册和发现，Config Service和Admin Service都会向Eureka注册服务。Eureka在部署时和Config Service在一个JVM进程中，即<strong>Config Service包含了Meta Server和Eureka</strong>。</p></li><li><p>Portal<br>后台Web界面管理配置，通过Meta Server获取Admin Service服务列表(IP+Port)进行配置的管理，客户端做负载均衡。</p></li><li><p>Cilent<br>Apollo提供的客户端，用于项目中对配置的获取、更新。<strong>通过Meta Server获取Config Service服务列表</strong>(IP+Port)进行配置的管理，客户端内做负载均衡。</p></li></ul><p><strong>工作流程：</strong></p><ol><li>注册、续约、取消，也就是服务注册的操作，Config Service和Admin Service都会注册到Eureka中。</li><li>服务发现的逻辑，Client需要指定所有的Config Service，Portal需要知道所有的Admin Service，然后才能发起对应的操作。查找服务列表是通过负载进行转发到Meta Server.</li><li>Meta Server去Eureka中获取对应的服务列表。</li><li>当获取到对应的服务信息后，就可以直接发起远程调用了。</li></ol><p><strong>推送设计：</strong><br><img data-src="/../../../../assets/img/CgotOV28B1eAVl80AADzD_Lkc-w754.png"><br>在Portal中进行配置的编辑和发布操作后，Portal会调用Admin Service提供的接口进行发布操作。Admin Service收到请求后，发送ReleaseMessage给各个Config Service，通知Config Service配置发生了变化。Config Service收到ReleaseMessage后，通知对应的客户端，基于HTTP长连接实现。</p><p><strong>消息设计：</strong><br><img data-src="/../../../../assets/img/CgoB5l28B1iAJa9tAACfTre4O3g300.png"><br>ReleaseMessage消息是通过MySQL实现了一个简单的消息队列。Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，Config Service会启动一个线程定时扫描ReleaseMessage表，去查看是否有新的消息记录。Config Service发现有新的消息记录，那么就会通知所有的消息监听器，消息监听器得到配置发布的信息后，则会通知对应的客户端。</p><p><strong>客户端设计：</strong><br><img data-src="/../../../../assets/img/CgotOV28B1iAHJTnAAFK5jsOc0Q150.png"><br>客户端和服务端保持了一个长连接，编译配置的实时更新推送。定时拉取配置是客户端本地的一个定时任务，默认5分钟1次，也可以通过在运行时指定System Property:apollo.refreshInterval来进行覆盖，单位是分钟，采用推送+定时拉取的方式就等于双保险。客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中。客户端会把从服务取到的配置在本地文件系统中缓存一份，当服务或网络不可用时可以使用本地配置，也就是本地开发模式env&#x3D;Local。</p><h3 id="2-分布式链路跟踪"><a href="#2-分布式链路跟踪" class="headerlink" title="2.分布式链路跟踪"></a>2.分布式链路跟踪</h3><p><img data-src="/../../../../assets/img/CgotOV3TXSmAClJKAAGdgZ3eA9U538.png"><br>分布式链路跟踪的关键在于如何将请求经过的服务节点都关联起来。</p><h4 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h4><ul><li><p>Span<br>基本工作单元，如发送RPC请求是一个新的Span、发送HTTP请求是一个新的Span、内部方法调用也是一个新的Span。</p></li><li><p>Trace<br>一次分布式调用的链路信息，每次调用链路信息都会在请求入口处生成一个TraceId。</p></li><li><p>Annotation<br>用于记录事件的信息。在Annotation中会有CS、SR、SS、CR这些信息。</p></li><li><p>CS<br>Client Sent，客户端发送一个请求，这个Annotation表示Span的开始。</p></li><li><p>SR<br>Server Received，服务端获得请求并开始处理，用SR的时间减去CS的时间即网络延迟时间。</p></li><li><p>SS<br>Server Sent，在请求处理完成时将响应发送回客户端，SR-SS，即服务端处理请求所需的时间。</p></li><li><p>CR<br>Client Recevied，表示Span结束，客户端从服务端收到响应，CR-CS，即全部时间。</p></li></ul><h4 id="2-2-请求追踪过程分解"><a href="#2-2-请求追踪过程分解" class="headerlink" title="2.2 请求追踪过程分解"></a>2.2 请求追踪过程分解</h4><p><img data-src="/../../../../assets/img/CgoB5l3TXSqAAotuAARIqATiaa4975.png"></p><ol><li>当一个请求访问SERVICE1时，此时没有Trace和Span，会生成Trace和Span，如图所示生成Trace ID是X，Span ID是A。</li><li>接着SERVICE1请求SERVICE2，这是一次远程请求，会生成一个新的Span，Span ID为B，Trace ID不变还是X。Span B处于CS状态，当请求到达SERVICE2后，SERVICE2有内部操作，生成了一个新的Span，Span ID为C，Trace ID不变。</li><li>SERVICE2处理完后向SERVICE3发起请求，生成新的Span，Span ID为D，Span D处于CS状态，SERVICE3接收请求后，Span D处于RS状态，同时SERVICE内部操作也会生成新的Span，Span ID为E。</li><li>SERVICE3处理完后，需要将结果响应给调用方，此时Span D处于SS状态，当SERVICE2收到响应后，Span D处于CR状态。</li></ol><p>一次请求会经过多个服务，会产生多个Span，但Trace ID只有一个。</p><h4 id="2-3-Spring-Cloud-Sleuth"><a href="#2-3-Spring-Cloud-Sleuth" class="headerlink" title="2.3 Spring Cloud Sleuth"></a>2.3 Spring Cloud Sleuth</h4><ul><li>可以添加链路信息到日志中</li><li>链路数据可直接上报给Zipkin</li><li>内置了很多框架的埋点，如Zuul、Feign、Hystrix</li></ul><h4 id="2-4-Zipkin"><a href="#2-4-Zipkin" class="headerlink" title="2.4 Zipkin"></a>2.4 Zipkin</h4><p><img data-src="/../../../../assets/img/CgotOV3TXSqAJOtrAAFNEaemXPk128.png"><br>收集数据、查询数据。</p><ul><li><p>Collector<br>Zipkin的数据收集器，进行数据验证、存储。</p></li><li><p>Storage<br>存储组件，Zipkin默认在内存中存储数据，数据落地的话支持ElasticSearch和MySQL。</p></li><li><p>Search<br>Zipkin的查询API，用于查找和检索数据，主要使用者为Web UI。</p></li><li><p>Web UI<br>提供可视化的操作界面，直观的查询链路跟踪数据。</p></li></ul><p>链路跟踪的信息会通过Transport传递给Zipkin的Collector，Transport支持的方式有HTTP和MQ进行传输。</p><h4 id="2-5-Sleuth关联整个请求链路日志"><a href="#2-5-Sleuth关联整个请求链路日志" class="headerlink" title="2.5 Sleuth关联整个请求链路日志"></a>2.5 Sleuth关联整个请求链路日志</h4><p>集成Spring Cloud Sleuth后，会在原始的日志加上一些链路的信息。</p><ul><li><p>application name<br>应用名称，即application.yml里的spring.application.name参数配置的属性。</p></li><li><p>traceId<br>为请求分配的唯一请求号，用来标识一条请求链路。</p></li><li><p>spanId<br>基本的工作单元，一个请求可以包含多个步骤，每个步骤有自己的Span ID，一次请求只有一个Trace ID和多个Span Id。</p></li><li><p>export<br>布尔类型，表示是否将该信息输出到Zipkin进行收集和展示。</p></li></ul><h4 id="2-6-使用技巧"><a href="#2-6-使用技巧" class="headerlink" title="2.6 使用技巧"></a>2.6 使用技巧</h4><ul><li><p>抽样采集数据<br>spring.sleuth.sampler.probability&#x3D;10<br>请求次数：Zipkin数据条数&#x3D;10：1</p></li><li><p>RabbitMQ代替HTTP发送调用链路数据<br>删除配置spring.zipkin.base-url，在启动Zipkin服务时指定RabbitMQ信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -DRABBIT_ADDRESSES=192.168.10.124:5672 -DRABBIT_USER=admin -DRABBIT_PASSWORD=123456 -jar zipkin.jar</span><br></pre></td></tr></table></figure></li><li><p>ElasticSearch存储调用链数据<br>启动Zipkin的时候指定存储类型为ES，指定ES的URL信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -DSTORAGE_TYPE=elasticsearch -DES_HOSTS=http://localhost:9200 -jar zipkin.jar</span><br></pre></td></tr></table></figure></li><li><p>手动埋点检测性能</p></li><li><p>Hystrix埋点分析</p></li></ul><h3 id="3-微服务安全认证"><a href="#3-微服务安全认证" class="headerlink" title="3.微服务安全认证"></a>3.微服务安全认证</h3><h4 id="3-1-常用的认证方式"><a href="#3-1-常用的认证方式" class="headerlink" title="3.1 常用的认证方式"></a>3.1 常用的认证方式</h4><ul><li><p>session<br>用户登陆后将信息存储在服务端，客户端通过cookie中的sessionId来标识对应的用户。</p><p>缺点：</p><ol><li>服务端需要保存每个用户的登录信息，如果用户量非常的，服务端的存储压力也会增大。</li><li>多节点时，通过负载均衡器进行转发，session可能会丢失。</li></ol><p>解决办法：<br>session复制，Nginx可以设置黏性Cookie来保证一个用户的请求只访问同一个节点；session集中存储，如存储在Redis中。</p></li><li><p>HTTP Basic Authentication<br>HTTP基本认证，客户端会在请求头中增加Authorization，Authorization是用户名和密码Base64加密后的内容，服务端获取Authorization Header中的用户名与密码进行验证。</p></li><li><p>Token<br>与HTTP Basic Authentication类似，与session不同，session只是一个key，会话信息存储在服务端。而Token中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，服务端拿到Token后进行解密获取用户信息。</p></li></ul><h4 id="3-2-JWT认证"><a href="#3-2-JWT认证" class="headerlink" title="3.2 JWT认证"></a>3.2 JWT认证</h4><p><strong>简介：</strong><br>JWT(JSON Web Token)<br>如用户登录时，基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个Token，用户可以使用这个Token访问服务器上受保护的资源。</p><p>JWT由三部分构成：头部(Header)、消息体(Payload)、签名(Signature)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token = encodeBase64(header) + <span class="string">&#x27;.&#x27;</span> + encodeBase64(payload) + <span class="string">&#x27;.&#x27;</span> + encodeBase64(signature)</span><br></pre></td></tr></table></figure><p>头部信息：令牌类型、签名算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>消息体：应用需要的信息，如用户的id</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>签名：用来判断消息在传递的路径上是否被篡改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256( base64UrlEncode(header)  + <span class="string">&quot;.&quot;</span> +  base64UrlEncode(payload), secret)</span><br></pre></td></tr></table></figure><p><strong>JWT认证流程：</strong><br><img data-src="/../../../../assets/img/CgotOV3WUG2ARl98AAD_xcd-ElM857.png"><br>客户端需要调用服务端提供的认证接口来获取 Token。获取 Token 的流程如图所示，客户端会首先发起一个认证的请求到网关，网关会将请求转发到后端的用户服务中，在用户服务中验证身份后，就会根据用户的信息生成一个 Token 返回给客户端，这样客户端就获取了后面请求的通行证。然后，客户端会将获取的 Token 存储起来，在下次请求时带上这个 Token，一般会将 Token 放入请求头中进行传递。当请求到达网关后，会在网关中对 Token 进行校验，如果校验成功，则将该请求转发到后端的服务中，在转发时会将 Token 解析出的用户信息也一并带过去，这样在后端的服务中就不用再解析一遍 Token 获取的用户信息，这个操作统一在网关进行的。如果校验失败，那么就直接返回对应的结果给客户端，不会将请求进行转发。</p><p>在网关中，验证过滤器会对 &#x2F;oauth&#x2F;token 这个认证 API 进行放行，不进行验证。<br><strong>用户信息的全局传递扩展：</strong><br>不需要加参数，直接通过请求头进行传递，在服务内部通过ThreadLocal进行上下文传递。主要流程：从网关传递到后端服务，后端服务接受数据后存储到ThreadLocal中，服务会调用其它服务，如果用Feign调用可以利用Feign的拦截器传递数据，如果用RestTemplate的拦截器传递数据也一样。</p><h4 id="3-3-Token的使用"><a href="#3-3-Token的使用" class="headerlink" title="3.3 Token的使用"></a>3.3 Token的使用</h4><p><strong>Token注销</strong><br><img data-src="/../../../../assets/img/CgoB5l3WUIGADfX2AAEhrMGcQDk308.png"><br>Token的有效期存储在Token本身中，只有解析出Token的信息，才能获取到Token的有效时间，不能修改。Token的有效期越短，安全性越高。还可以在用户退出登录时，进行Token的注销操作，如将注销的Token放入Redis中进行一层过滤，即在网关中验证Token有效性时先从Redis中判断Token是否存在，如果存在，直接拦截。Token放入Redis的过期时间一般会设置为Token剩余的有效时间。</p><p><strong>使用建议</strong></p><ul><li>设置较短(合理)的过期时间</li><li>注销的Token及时清除(放入Redis中做一层过滤)</li><li>监控Token的使用频率</li><li>核心功能敏感操作可以使用动态验证(验证码)</li><li>网络环境、浏览器信息等识别</li><li>加密密钥支持动态修改</li><li>加密密钥支持动态修改</li></ul><h4 id="3-4-内部服务之间的认证"><a href="#3-4-内部服务之间的认证" class="headerlink" title="3.4 内部服务之间的认证"></a>3.4 内部服务之间的认证</h4><p><img data-src="/../../../../assets/img/CgotOV3WUJuAU4JXAAEXJfEgv9o814.png"></p><ol><li><p>IP白名单<br>如用户服务只能某些IP或IP段访问，IP白名单可以采用配置中心来存储，具备实时刷新的能力。</p></li><li><p>内部同样使用Token进行验证<br>服务在启动时就可以在统一的认证服务中申请Token，申请需要的认证信息可以放在配置中心。这样服务启动时就有了能够访问其他服务的Token，在调用时带上Token，被调用的服务中进行Token的校验。<br>对于Token的失效更新：</p><ol><li>在请求时如果返回的Token已经失效，那么可以重新获取Token后再发起调用，这种在并发量大时需要加锁，不然会发生同时申请多个Token的情况。</li><li>定时更新，如Token有效期1个小时，那么定时任务可以50分钟更新一次。</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-Apollo&quot;&gt;&lt;a href=&quot;#1-Apollo&quot; class=&quot;headerlink&quot; title=&quot;1.Apollo&quot;&gt;&lt;/a&gt;1.Apollo&lt;/h3&gt;&lt;p&gt;统一管理配置信息，增强配置管理的服务能力。&lt;br&gt;&lt;img data-src=&quot;/../../../../assets/img/CgotOV28B1WAF4S2AACIYGiePW0196.png&quot;&gt;&lt;br&gt;使用配置中心管理配置后，可以将配置信息从项目转移到配置中心，一般一个项目会有一个唯一的标识ID，通过这个ID从配置中心获取对应的配置内容。&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="https://imokkkk.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="https://imokkkk.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Spring Cloud" scheme="https://imokkkk.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
