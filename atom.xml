<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ImOkkkk BLOG</title>
  <icon>https://www.gravatar.com/avatar/5503d12b09e32d800cc45af49aa8ef7c</icon>
  <subtitle>When they go low,we go high.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imokkkk.github.io/"/>
  <updated>2023-01-18T06:09:20.658Z</updated>
  <id>https://imokkkk.github.io/</id>
  
  <author>
    <name>ImOkkkk</name>
    <email>547717253@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring：自定义Converter实现参数转换</title>
    <link href="https://imokkkk.github.io/springcustomconverter/"/>
    <id>https://imokkkk.github.io/springcustomconverter/</id>
    <published>2023-01-18T05:51:18.160Z</published>
    <updated>2023-01-18T06:09:20.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>多个后端、前端开发时约定日期类型参数时未能统一，即存在<code>2022-12-21 12:45:00</code>，也存在<code>2022/12/21 12:45:00</code>。导致可以复用的接口，前端传参格式却不一样，前端改动的话，工作量比较大，所以在后端做格式兼容处理。</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li><p>项目中只有某些字段需要做兼容处理，新建一个注解，用于标识哪些字段需要做兼容处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BizDateAdapter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>ConditionalGenericConverter</code>接口，自定义匹配、转换逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizDateConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匹配逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetType.hasAnnotation(BizDateAdapter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span> &amp;&amp; source <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            Date date = DateUtil.parseDate(String.valueOf(source), <span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="keyword">if</span> (date == <span class="keyword">null</span>)&#123;</span><br><span class="line">                date = DateUtil.parseDate(String.valueOf(source), <span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加自定义的转换器到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addConverter(<span class="keyword">new</span> BizDateConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ApiResponse <span class="title">xxxxx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @RequestParam(value = <span class="string">"userId"</span>, required = <span class="keyword">false</span>)</span> String userId,</span></span><br><span class="line"><span class="function">  @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"bizDate"</span>)</span> @BizDateAdapter Date bizDate) </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxxx</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BizDateAdapter</span></span><br><span class="line">    <span class="keyword">private</span> Date bizDate;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;多个后端、前端开发时约定日期类型参数时未能统一，即存在&lt;code&gt;2022-12-21 12:45:00&lt;/code&gt;，也存在&lt;code&gt;2022/12/21 12:45:00&lt;/code&gt;。导致可以复用的接口，前端传参格式却不一样，前端改动的话，工作量比较大，所以在后端做格式兼容处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://imokkkk.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署主从MySQL</title>
    <link href="https://imokkkk.github.io/dockermysqlmasterslave/"/>
    <id>https://imokkkk.github.io/dockermysqlmasterslave/</id>
    <published>2022-12-01T02:38:14.947Z</published>
    <updated>2022-12-01T02:38:26.080Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Docker部署主从MySQL"><a href="#Docker部署主从MySQL" class="headerlink" title="Docker部署主从MySQL"></a>Docker部署主从MySQL</h2><ol><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7.37</span><br></pre></td></tr></table></figure></li><li><p>准备文件夹及配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkidir /mysql/data/</span><br><span class="line">mkidir /mysql/conf.d/</span><br><span class="line">touch /mysql/my.cnf</span><br></pre></td></tr></table></figure><a id="more"></a><p>my.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">user=mysql</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=9</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">secure_file_priv=/var/lib/mysql</span><br><span class="line">expire_logs_days=7</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p>从库操作同上，my.conf略有不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkidir /mysql-slave/data/</span><br><span class="line">mkidir /mysql-slave/conf.d/</span><br><span class="line">touch /mysql-slave/my.cnf</span><br></pre></td></tr></table></figure><p>my.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">lower_case_table_names=1</span><br><span class="line">user=mysql</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br><span class="line">slave-skip-errors=1032,1062</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">secure_file_priv=/var/lib/mysql</span><br><span class="line">expire_logs_days=7</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">max_connections=1000</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主库</span></span><br><span class="line">docker run  -di -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -v /root/mysql/my.cnf:/etc/mysql/my.cnf -p 3306:3306 --name mysql-master -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.37</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从库</span></span><br><span class="line"> docker run  -di -v /root/mysql-slave/data:/var/lib/mysql -v /root/mysql-slave/conf.d:/etc/mysql/conf.d -v /root/mysql-slave/my.cnf:/etc/mysql/my.cnf -p 3307:3306 --name mysql-master -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.37</span><br></pre></td></tr></table></figure></li><li><p>配置主从</p><p>主库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">连接主库</span></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p123456</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#创建sync用户</span></span></span><br><span class="line">create user 'sync'@'%' identified by '123';</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#授权用户</span></span></span><br><span class="line">grant all privileges on *.* to 'sync'@'%' ;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##刷新权限</span></span></span><br><span class="line">flush privileges;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看主服务器状态(显示如下)</span></span><br><span class="line">show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000002 |  2735529 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>从库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">连接从库</span></span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p123456</span><br><span class="line">change master to master_host='49.234.xx.xx',master_port=3306,master_user='sync',master_password='123456',master_log_file='mysql-bin.000001',master_log_pos=0;</span><br><span class="line"><span class="meta">#</span><span class="bash">启用从库</span></span><br><span class="line">start slave;</span><br><span class="line"><span class="meta">#</span><span class="bash">查看从库状态，看到Slave_IO_Running: Yes Slave_SQL_Running: Yes即可</span></span><br><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参考：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MDQ4NjU2OA==">https://zhuanlan.zhihu.com/p/90486568<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8yOTY2NDgxOS9hcnRpY2xlL2RldGFpbHMvMTEzMTM3Mzg3">https://blog.csdn.net/weixin_29664819/article/details/113137387<i class="fa fa-external-link-alt"></i></span></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker部署主从MySQL&quot;&gt;&lt;a href=&quot;#Docker部署主从MySQL&quot; class=&quot;headerlink&quot; title=&quot;Docker部署主从MySQL&quot;&gt;&lt;/a&gt;Docker部署主从MySQL&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拉取镜像&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull mysql:5.7.37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;准备文件夹及配置文件&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkidir /mysql/data/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkidir /mysql/conf.d/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;touch /mysql/my.cnf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://imokkkk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Docker" scheme="https://imokkkk.github.io/tags/Docker/"/>
    
      <category term="MySQL" scheme="https://imokkkk.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="https://imokkkk.github.io/fenkufenbiaon/"/>
    <id>https://imokkkk.github.io/fenkufenbiaon/</id>
    <published>2022-11-28T09:04:28.239Z</published>
    <updated>2022-12-14T08:54:26.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p><strong>什么情况下需要分库分表？</strong></p><p>MySQL单表容量大于1000万(BTREE索引树在3-5层之间)。</p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>根据业务耦合性，将业务关联度低的不同表存储在不同的数据库。类似于”微服务”。</p><a id="more"></a><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>把一个表的多个字段拆分成多个表，一般按字段的冷热拆分，热字段一个表，冷字段一个表。</p><p><strong>优点</strong></p><ol><li>同时解决了业务层面的耦合；</li><li>一定程度提升IO、数据库连接数、单机硬件的资源瓶颈。</li></ol><p><strong>缺点</strong></p><ol><li>无法使用sql join，需要编码进行聚合操作，开发复杂度增加；</li><li>分布式事务处理复杂；</li><li>依然存在单表数据量大的问题。</li></ol><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h4><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p><strong>优点</strong></p><ol><li>解决单表数据量过大的问题；</li><li>业务编码改造相对较小。</li></ol><p><strong>缺点</strong></p><ol><li>跨分片的事务一致性难以保证；</li><li>跨库的join关联查询性能差。</li></ol><h3 id="数据分片规则"><a href="#数据分片规则" class="headerlink" title="数据分片规则"></a>数据分片规则</h3><h4 id="Hash取模"><a href="#Hash取模" class="headerlink" title="Hash取模"></a>Hash取模</h4><p>按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系，从而将哈希值不同的数据分布到不同的节点上。</p><p>如选择id作为数据分片的key，n台实例，则取<code>id的hash值 % n</code>得到的结果就是数据所在实例。</p><p><strong>优点</strong></p><ol><li>实现简单</li></ol><p><strong>缺点</strong></p><ol><li>加入或者删除一个节点的时候，需要迁移大量的数据；</li><li>很难解决数据不均衡的问题；</li><li>如果查询条件中不带用于分片的key，那么需要查询所有分库，再在内存中合并数据，效率低，复杂度高/</li></ol><h4 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h4><p>按照关键值划分成不同的区间，每个物理节点负责一个或者多个区间。</p><p>如id 0-10000数据位于实例1，10000-20000位于实例2…。</p><p><strong>优点</strong></p><ol><li>单表/库大小可控；</li><li>易于水平扩展，假如/删除实例时，无需对其它实例的数据迁移；</li><li>易于范围查询。</li></ol><p><strong>缺点</strong></p><ol><li>热点数据(如按时间字段分片)；</li><li>元数据(每个实例存储哪些数据区间)相对复杂一些。</li></ol><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。</p><p><strong>特点</strong></p><ol><li>一致性 hash 方式在增删的时候只会影响到 hash 环上相邻的节点，不会发生大规模的数据迁移；</li><li>一致性 hash 方式在增加节点时，只能分摊一个节点的压力；删除节点时，改节点的压力只能转移到下一个节点，所以实际工程中一般引入虚拟节点，即节点个数远大于物理节点个数，一个物理节点负责多个虚拟节点的真实存储。<strong>操作数据时，先通过hash环找到对应的虚拟节点，再通过虚拟节点与物理节点的映射关系找到对应的物理节点。</strong></li></ol><p><strong>优点</strong></p><ol><li>一致性 hash 方式在节点增删的时候只会影响到 hash 环上相邻的节点，不会发生大规模的数据迁移；</li><li>可以根据物理节点的性能来调整每一个物理节点对于虚拟节点的数量，充分、合理利用资源。</li></ol><p><strong>缺点</strong></p><ol><li>需要维护的元数据增加(虚拟节点与物理节点的映射关系)</li></ol><h3 id="分库分表引入的问题"><a href="#分库分表引入的问题" class="headerlink" title="分库分表引入的问题"></a>分库分表引入的问题</h3><ol><li><p>分布式事务</p></li><li><p>跨节点join关联查询</p><ol><li>字段冗余：空间换时间，避免join查询。如订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”user表”；</li><li>数据组装：分为多次子查询请求，最后在内存中组装结果。</li></ol></li><li><p>跨节点分页、排序、函数问题</p><p>当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；如果排序字段非分片字段，需要在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序。</p></li><li><p>全局主键</p><p>雪花算法(时钟回拨问题)，百度<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener"><strong>uid-generator</strong></a>，美团<strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01laXR1YW4tRGlhbnBpbmcvTGVhZg==">Leaf<i class="fa fa-external-link-alt"></i></span></strong>、</p></li></ol><h2 id="ShardingShere"><a href="#ShardingShere" class="headerlink" title="ShardingShere"></a>ShardingShere</h2><p>ShardingSphere 是一款分布式的数据库生态系统， 可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强。</p><p><strong>常用功能</strong></p><ul><li>数据分片<ul><li>分库 &amp; 分表</li><li>读写分离</li><li>分片策略定制</li><li>无中心化分布式主键</li></ul></li><li>分布式事务<ul><li>LOCAL 事务</li><li>XA 强一致性事务</li><li>BASE柔性事务</li></ul></li><li>数据库治理<ul><li>数据脱敏、加密</li><li>流量治理</li><li>数据迁移</li></ul></li></ul><h3 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h3><h3 id="ShardingSphere-Proxy"><a href="#ShardingSphere-Proxy" class="headerlink" title="ShardingSphere-Proxy"></a>ShardingSphere-Proxy</h3><h3 id="结果归并"><a href="#结果归并" class="headerlink" title="结果归并"></a>结果归并</h3><p>将各个数据节点获取的多数据结果集，组合、处理成一个结果集并返回给请求。</p><p>遍历、排序、分组、分页、聚合。</p><ol><li><p>遍历归并</p><p>将多个数据结果集合并为一个单向链表；</p></li><li><p>排序归并</p><p>每个数据结果集自身有序，所以需要对多个有序的数组进行排序；ShardingSphere在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（<strong>通过实现Java的Comparable接口完成</strong>），并将其放入<code>优先级队列</code>。</p></li><li><p>分组归并</p><p>流式分组归并：要求SQL的排序项与分组项的字段及排序类型(ASC或DESC)必须保持一致；</p><p>内存归并</p></li><li><p>聚合归并</p><p>装饰者模式</p></li><li><p>分页归并</p><p>ShardingSphere通过<code>装饰者模式</code>来增加对数据结果集进行分页的能力。</p></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="ShardingSphere读写分离"><a href="#ShardingSphere读写分离" class="headerlink" title="ShardingSphere读写分离"></a>ShardingSphere读写分离</h3><h4 id="Docker部署主从MySQL"><a href="#Docker部署主从MySQL" class="headerlink" title="Docker部署主从MySQL"></a>Docker部署主从MySQL</h4><p>参考：<a href="https://imokkkk.github.io/dockermysqlmasterslave/">https://imokkkk.github.io/dockermysqlmasterslave/</a></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须搭配druid，不能使用druid-spring-boot-starter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master0,slave0</span></span><br><span class="line">      <span class="attr">master0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">slave0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3307/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">ms:</span></span><br><span class="line">          <span class="attr">masterDataSourceName:</span> <span class="string">master0</span></span><br><span class="line">          <span class="attr">slaveDataSourceNames:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">slave0</span></span><br><span class="line">          <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>效果</p><p>增删改操作主库，查询操作从库：</p><p><img data-src="../assets/img/image-20221201105517286.png" alt></p></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1yZWFkLXdyaXRlLXNwbGl0dGluZw==">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-read-write-splitting<i class="fa fa-external-link-alt"></i></span></p><h3 id="ShardingSphere读写分离-单库分表"><a href="#ShardingSphere读写分离-单库分表" class="headerlink" title="ShardingSphere读写分离+单库分表"></a>ShardingSphere读写分离+单库分表</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>依赖</p><p>同上</p></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">slave0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3307/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master,</span> <span class="string">slave0</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">url:</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds0.url$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">surl</span></span><br><span class="line">              <span class="comment">#对url表surl字段hash取模(分表的个数)</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">url$-&gt;&#123;Math.abs(surl.hashCode())%2&#125;</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">ds0:</span></span><br><span class="line">          <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">slave-data-source-names:</span> <span class="string">slave0</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>效果</p><p>批量插入3条数据：2条数据新增到主库的url0表，1条数据新增到url1表。</p><p><img data-src="../assets/img/image-20221208152127526.png" alt></p></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1yZWFkLXdyaXRlLXNwbGl0dGluZy10YWJsZQ==">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-read-write-splitting-table<i class="fa fa-external-link-alt"></i></span></p><h3 id="ShardingSphere分库-分表"><a href="#ShardingSphere分库-分表" class="headerlink" title="ShardingSphere分库+分表"></a>ShardingSphere分库+分表</h3><ol><li><p>依赖</p><p>同上</p></li><li><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">ds0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://49.234.xx.xxx:3306/url_gen1?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">ENC(xPowsGGk7qtWdvCvCtChLOVLXPAyMPOrrZWKSmN5mwyKIzgAwBxNx4uxcJ+9Ksbn)</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds0,</span> <span class="string">ds1</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment">#分库策略</span></span><br><span class="line">      <span class="attr">default-database-strategy:</span></span><br><span class="line">        <span class="attr">inline:</span></span><br><span class="line">          <span class="attr">sharding-column:</span> <span class="string">sid</span></span><br><span class="line">          <span class="attr">algorithm-expression:</span> <span class="string">ds$-&gt;&#123;Math.abs(sid.hashCode())%2&#125;</span></span><br><span class="line">      <span class="comment">#分表策略</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">url:</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">ds$-&gt;&#123;0..1&#125;.url$-&gt;&#123;0..1&#125;</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">surl</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">url$-&gt;&#123;Math.abs(surl.hashCode())%2&#125;</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>效果</p><p>批量插入3条数据：</p><ul><li>1条数据新增到ds1的url1表；</li><li>1条数据新增到ds1的url0表；</li><li>1条数据新增到ds0的url0表。</li></ul><p><img data-src="../assets/img/image-20221214165028079.png" alt></p></li></ol></li></ol><p>详细的实现代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ltT2tra2svc2hvcnQtbGluay1nZW5lcmF0b3IvdHJlZS9zaGFyZGluZ3NwaGVyZS1zcGxpdHRpbmctZGF0YWJhc2UtdGFibGU=">https://github.com/ImOkkkk/short-link-generator/tree/shardingsphere-splitting-database-table<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h1&gt;&lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么情况下需要分库分表？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL单表容量大于1000万(BTREE索引树在3-5层之间)。&lt;/p&gt;
&lt;h3 id=&quot;垂直切分&quot;&gt;&lt;a href=&quot;#垂直切分&quot; class=&quot;headerlink&quot; title=&quot;垂直切分&quot;&gt;&lt;/a&gt;垂直切分&lt;/h3&gt;&lt;h4 id=&quot;垂直分库&quot;&gt;&lt;a href=&quot;#垂直分库&quot; class=&quot;headerlink&quot; title=&quot;垂直分库&quot;&gt;&lt;/a&gt;垂直分库&lt;/h4&gt;&lt;p&gt;根据业务耦合性，将业务关联度低的不同表存储在不同的数据库。类似于”微服务”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://imokkkk.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="MySQL" scheme="https://imokkkk.github.io/tags/MySQL/"/>
    
      <category term="分库分表" scheme="https://imokkkk.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
      <category term="ShardingSphere" scheme="https://imokkkk.github.io/tags/ShardingSphere/"/>
    
  </entry>
  
  <entry>
    <title>CAP理论&amp;常用的分布式事务概览</title>
    <link href="https://imokkkk.github.io/cpaandtransaction/"/>
    <id>https://imokkkk.github.io/cpaandtransaction/</id>
    <published>2022-11-25T02:27:49.050Z</published>
    <updated>2022-11-25T02:27:56.979Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CAP理论-amp-常用的分布式事务概览"><a href="#CAP理论-amp-常用的分布式事务概览" class="headerlink" title="CAP理论&amp;常用的分布式事务概览"></a>CAP理论&amp;常用的分布式事务概览</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP理论是分布式系统的重要理论，即一个分布式系统最多只能同时满足一致性(C: Consistency)、可用性(A: Availability)、分区容错性(Partition tolerance)这三项中的两项。</p><p><strong>一致性</strong></p><p>数据能一起变化，能让数据整齐划一。</p><a id="more"></a><p><strong>可用性</strong></p><p>每一个非故障节点接收的任何请求，都能处理并返回响应结果。</p><p><strong>分区容错性</strong></p><p>分区：分布式系统中，节点之间通信出现了问题。</p><p>如果出现了分区问题，系统仍然可以运行。</p><h4 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h4><p>在分布式系统中，网络异常不可避免，所以<strong>P</strong>往往无法忽略，所以需要考虑在发生分区故障时，如何选择<strong>C</strong>和<strong>A</strong>。</p><p><strong>CP</strong></p><p>系统一旦发生分区故障后，允许系统停机或者长时间无响应，但系统每个节点总是会返回一致的数据。如：分布式协调系统Zookeeper、分布式存储系统Redis等，数据一致性是最基本的要求。</p><p><strong>AP</strong></p><p>如果系统发生分区故障后，依然可以访问系统，但是无法保证全局数据的一致性(舍弃数据的强一致性，退而求其次保证最终一致性)。如：Eureka</p><p>CAP如何权衡和取舍没有好坏之分，需要根据不同的业务场景进行选择，适合的才是最好的。对于涉及到钱这种不能有任何差错的场景，数据强一致性是必须要保证的。对于其他场景，比较<strong>普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全</strong>。</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>既然无法保证强一致性(Strong Consistency)，应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</p><p>BASE指基本可用(Basically Available)、软状态(Soft State)、最终一致性(Eventual Consistency)。</p><p><strong>基本可用</strong></p><p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p><ul><li>电商大促，流量激增，部分用户可能会被引导到降级页面，服务层也可能提供降级服务；</li><li>网络异常，接口响应从0.5s增加到2s。</li></ul><p><strong>软状态</strong></p><p>允许系统存在中间状态，而该中间状态不会影响系统整体可用性。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。如MySQL主从节点间的数据同步。</p><p><strong>最终一致性</strong></p><p>统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><h3 id="常见分布式事务"><a href="#常见分布式事务" class="headerlink" title="常见分布式事务"></a>常见分布式事务</h3><p>分布式事务可以简单的理解为协调多个资源，达到共同提交或共同失败的效果，及分布式ACID。</p><h4 id="两阶段提交-2PC"><a href="#两阶段提交-2PC" class="headerlink" title="两阶段提交(2PC)"></a>两阶段提交(2PC)</h4><p>分布式系统中，所有的节点虽然都可以知道自己执行后的状态，但无法知道其它节点执行后的状态，一个事务跨越多个系统时，需要引入一个协调者的组件来统一各个节点的执行结果是否提交。</p><ol><li><p>准备阶段</p><p>协调者询问事务的参与者是否可以执行操作，并等待参与者响应，参与者会执行相应的事务操作并记录重做和回滚日志，所有执行成功的参与者向协调整发送<code>AGREEMENT</code> 或者 <code>ABORT</code> 表示执行操作的结果。</p></li><li><p>提交阶段</p><p>当事务的所有参与者都决定提交事务时，协调者会向参与者发送 <code>COMMIT</code> 请求，参与者在完成操作并释放资源之后向协调者返回完成消息，协调者在收到所有参与者的完成消息时会结束整个事务；与之相反，当有参与者决定 <code>ABORT</code> 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的<strong>回滚日志</strong>对操作进行回滚并向协调者发送完成的消息，在提交阶段，无论当前事务被提交还是回滚，所有的资源都会被释放并且事务也一定会结束。</p></li></ol><p><strong>问题</strong></p><ol><li>阻塞；</li><li>两阶段提交的执行过程中，如果协调者永久宕机，部分参与者将永远无法完成事务；整个事务不一致。</li></ol><h4 id="三阶段提交-3PC"><a href="#三阶段提交-3PC" class="headerlink" title="三阶段提交(3PC)"></a>三阶段提交(3PC)</h4><p>三阶段提交相较于二阶段提交引入了<code>超时机制</code>和<code>询问阶段</code>，如果协调者或者参与者在规定之间内没有接受到来自其它节点的响应，就会根据当前的状态选择提交或终止整个事务。</p><p>3PC        2PC</p><p>询问        准备</p><p>准备        </p><p>提交        提交</p><p>3PC的询问阶段，对应的才是2PC的准备阶段，都是ASK参与者是否准备好了，但2PC的执行过程是阻塞的，一个资源在进入准备阶段之后，必须等所有的资源准备完毕后才能进入下一步，对全局一无所知。而3PC拆分出询问阶段，在确保所有参与者建康良好的情况下，才会发起真正的事务处理，在效率和容错性上更胜一筹。而且3PC在准备阶段，如果超时，就认为失败；在提交阶段如果超时还会继续执行下去。整个事务不会一直等待下去。</p><p><strong>问题</strong></p><p>准备与提交阶段不是原子的，与2PC一样，依然存在一致性问题。</p><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>补偿事务，为每一个操作，都准备一个确认动作和相应的补偿动作。</p><ol><li><p>try 尝试阶段</p><p>尝试锁定资源；</p></li><li><p>confirm 确认阶段 </p><p>尝试将锁定的资源提交；</p></li><li><p>cancel 取消阶段</p><p>其中某个环节执行失败，发起事务取消动作。</p></li></ol><p>如：资金转账：try就是冻结金额；confirm就是完成扣减；cancel就是解冻，只要对应的订单号是一直的，多次执行也不会有任何问题。</p><p><strong>问题</strong></p><p>需要编码实现，额外精力设计TCC逻辑。</p><p><strong>框架</strong></p><p>tcc-transaction、seata等。</p><h4 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h4><p>很多业务场景下，只需要保证业务的最终一致性。SAGA通过消息来协调一系列的本地子事务，来保证最终一致性。</p><p>与TCC相比，SAGA少了try，需要提供执行逻辑和补偿逻辑。在每一个本地事务中都会向集群中的其他服务发送一条的新的消息来触发下一个本地的事务；一旦本地的事务因为违反了业务逻辑而失败，那么就会立刻触发补偿逻辑来撤回之前本地事务造成的副作用。</p><p><strong>问题</strong></p><ol><li>嵌套问题，SAGA只允许两层嵌套，层次过深的话，消息流转会太复杂；</li><li>补偿操作无法保证执行成功，可以记录日志或人工参与；</li><li>本地小事务不是同时提交的，执行过程中，会产生脏数据。</li></ol><p><strong>框架</strong></p><p>seata</p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>解决数据库事务和MQ之间的事务问题。</p><p>有一个分布式事务，在正常落库之后，需要通过MQ来协调后续业务的执行。</p><ol><li>正常写入数据库；写入本地消息表(记录MQ消息处理状态，<code>发送中</code>和<code>已完成</code>)，此处使用<code>本地事务</code>；</li><li>写入本地消息表成功后，异步发送MQ消息；</li><li>后续业务订阅MQ消息，消费成功后，把执行成功的状态再通过MQ来发送。本地业务订阅这个执行状态，并把消息表中对应的记录状态，改为已完成；如果消费失败，则不做处理；</li><li>存在一个定时任务，持续扫描本地消息表中，状态为<code>发送中</code>的消息(注意延时)，并再次把这些消息发送到MQ，重复2的过程。</li></ol><p><strong>问题</strong></p><ol><li>需要额外编码，与业务耦合；</li><li>本地消息表需要写数据库，增加数据库压力。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际中，普遍选用软事务，TCC、SAGA、本地消息表。SAGA应对长事务特别拿手，但隔离性稍差；TCC需要较多编码，适合少量的分布式事务流程；本地消息表应用场景有限，耦合业务不能复用。各有利弊，需要结合使用场景进行选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CAP理论-amp-常用的分布式事务概览&quot;&gt;&lt;a href=&quot;#CAP理论-amp-常用的分布式事务概览&quot; class=&quot;headerlink&quot; title=&quot;CAP理论&amp;amp;常用的分布式事务概览&quot;&gt;&lt;/a&gt;CAP理论&amp;amp;常用的分布式事务概览&lt;/h2&gt;&lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;p&gt;CAP理论是分布式系统的重要理论，即一个分布式系统最多只能同时满足一致性(C: Consistency)、可用性(A: Availability)、分区容错性(Partition tolerance)这三项中的两项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据能一起变化，能让数据整齐划一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://imokkkk.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://imokkkk.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://imokkkk.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>扩展EnvironmentPostProcessor从数据库加载配置项&amp;spring.factories</title>
    <link href="https://imokkkk.github.io/EnvironmentPostProcessor/"/>
    <id>https://imokkkk.github.io/EnvironmentPostProcessor/</id>
    <published>2022-11-25T02:26:05.047Z</published>
    <updated>2023-01-18T05:46:15.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用未接入配置中心时，一些配置项(如oss存储配置信息、邮件服务配置信息等)需要从其它数据源获取，下面以从数据库获取配置信息为例。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>既然需要通过从数据库中读取配置信息，那么先了解一下@Value的工作原理：</p><a id="more"></a><ol><li><p>SpringBoot应用启动</p><p><code>org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String...)</code> =&gt; </p><p><code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code> =&gt; </p></li><li><p>刷新Spring容器</p><p><code>org.springframework.boot.SpringApplication#refreshContext</code> =&gt; </p><p><code>org.springframework.context.support.AbstractApplicationContext#refresh</code></p></li><li><p>实例化Bean</p><p><code>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</code> =&gt; </p><p><code>org.springframework.beans.factory.config.ConfigurableListableBeanFactory#preInstantiateSingletons</code>（实例化非懒加载的单例Bean) =&gt;</p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String)</code> =&gt; </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code> =&gt; </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#createBean</code> =&gt;</p><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code></p></li><li><p>属性填充</p><p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</code> =&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">//实例化后</span></span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//@Bean(autowire = Autowire.BY_NAME)</span></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">   </span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">//依赖注入入口</span></span><br><span class="line"><span class="comment">//@Autowired @Value：AutowiredAnnotationBeanPostProcessor @Resource：CommonAnnotationBeanPostProcessor</span></span><br><span class="line">PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()会覆盖@Autowired</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code> =&gt; </p><p><code>org.springframework.beans.factory.annotation.InjectionMetadata#inject</code> =&gt; </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"><span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"><span class="comment">//遍历每个注入点进行依赖注入</span></span><br><span class="line"><span class="comment">//Autowired：AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject</span></span><br><span class="line"><span class="comment">//AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement.inject</span></span><br><span class="line"><span class="comment">//Resource：InjectionMetadata.InjectedElement.inject</span></span><br><span class="line">element.inject(target, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#resolveFieldValue</code> =&gt; </p><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code> =&gt; </p><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></p></li><li><p>处理@Value</p><p><code>org.springframework.beans.factory.annotation.QualifierAnnotationAutowireCandidateResolver#findValue</code> </p><p><code>org.springframework.beans.factory.support.AbstractBeanFactory#resolveEmbeddedValue</code> =&gt; </p><p><img data-src="../assets/img/image-20221116112008529.png" alt></p><p><code>org.springframework.context.support.PropertySourcesPlaceholderConfigurer#processProperties(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.core.env.ConfigurablePropertyResolver)</code> (<strong>把所有的配置文件都变成了一个个propertysource对象，同时把environment对象也包装成了一个propertysource对象，并且一个个propertysource对象存储在了MutablePropertySources中。</strong>)</p></li></ol><p>大致上来看，@Value解析，分为以下几步：</p><ol><li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</code> =&gt; </p><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#findAutowiringMetadata</code> =&gt; </p><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata</code></p><p>收集标注了@Value等注解的字段；</p></li><li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code>开始注入值；</p></li><li><p>注入过程中，从DefaultListableBeanFactory中遍历所有的embeddedValueResolver，这些embeddedValueResolvers是StringValueResolver，调用其resolveStringValue方法；</p></li><li><p>其中有一个PropertySourcesPlaceholderConfigurer类构造的StringValueResolver，调用它的resolveStringValue，最终从一个PropertySourcesPropertyResolver的propertySources中遍历所有的propertySource，其中就有Environment的propertySources，匹配到值后返回。</p></li></ol><h3 id="EnvironmentPostProcessor"><a href="#EnvironmentPostProcessor" class="headerlink" title="EnvironmentPostProcessor"></a>EnvironmentPostProcessor</h3><p>从上面可以得出结论，在容器refresh之前，从数据库读取信息封装为MapPropertySource塞入Environment#Property即可。</p><p>主要实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseEnvironmentPostProcessor</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurableEnvironment environment, SpringApplication application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">"databasePropertySources"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 命令行参数</span></span><br><span class="line">    <span class="keyword">boolean</span> commandLineArgs = environment.getPropertySources().contains(<span class="string">"commandLineArgs"</span>);</span><br><span class="line">    <span class="keyword">if</span> (commandLineArgs) &#123;</span><br><span class="line">      environment</span><br><span class="line">          .getPropertySources()</span><br><span class="line">          .addBefore(<span class="string">"commandLineArgs"</span>, loadConfigurationFromDatabase(environment));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (environment.getProperty(<span class="string">"spring.datasource.url"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        environment.getPropertySources().addFirst(loadConfigurationFromDatabase(environment));</span><br><span class="line">        <span class="comment">// 设置激活的Profile</span></span><br><span class="line">        String activeProfile = environment.getProperty(<span class="string">"spring.profiles.active"</span>, <span class="string">"prd"</span>);</span><br><span class="line">        environment.addActiveProfile(activeProfile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PropertySource <span class="title">loadConfigurationFromDatabase</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">    String url = environment.getProperty(<span class="string">"spring.datasource.url"</span>);</span><br><span class="line">    String username = environment.getProperty(<span class="string">"spring.datasource.username"</span>);</span><br><span class="line">    String password = environment.getProperty(<span class="string">"spring.datasource.password"</span>);</span><br><span class="line">    String driverClassName = environment.getProperty(<span class="string">"spring.datasource.druid.driver-class-name"</span>);</span><br><span class="line">    Map&lt;String, ?&gt; configs =</span><br><span class="line">        <span class="keyword">new</span> DatabasePropertySourceLoader(url, username, password, driverClassName).load();</span><br><span class="line">    PropertySource propertySource =</span><br><span class="line">        <span class="keyword">new</span> MapPropertySource(<span class="string">"databasePropertySources"</span>, (Map&lt;String, Object&gt;) configs);</span><br><span class="line">    <span class="keyword">return</span> propertySource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring.factories</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">cn.imokkkk.env.DatabaseEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure><h4 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h4><p>Spring Factories是一种类似于Java SPI的机制，在resources/META-INF/spring.factories文件中配置接口的实现类名称(接口名称=实现类)，然后在程序中读取该配置文件并实例化，是spring-boot-starter-xxx的实现基础。</p><p>为了实现从数据库读取配置信息的需求，显然需要在容器refresh之前完成从数据库读取并添加到<strong>环境变量</strong>中。</p><p><strong>调用链路</strong></p><ol><li><p>从spring.factories加载ApplicationListener对应的监听器，并启动</p><p><code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code> =&gt; </p><p><code>org.springframework.boot.SpringApplication#getRunListenersorg.springframework.boot.SpringApplication#run(java.lang.String...)</code> =&gt; <code>org.springframework.boot.SpringApplication#getSpringFactoriesInstances(java.lang.Class&lt;T&gt;, java.lang.Class&lt;?&gt;[], java.lang.Object...)</code> =&gt; <code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames</code></p></li><li><p>发布ApplicationEnvironmentPreparedEvent</p><p><code>org.springframework.boot.SpringApplication#prepareEnvironment</code> =&gt; </p><p><code>org.springframework.boot.context.event.EventPublishingRunListener#environmentPrepared</code></p></li><li><p>监听到事件并执行</p><p><code>org.springframework.context.event.SimpleApplicationEventMulticaster#invokeListener</code> =&gt;</p><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener#onApplicationEvent</code> =&gt; </p><p><code>org.springframework.boot.context.config.ConfigFileApplicationListener#onApplicationEnvironmentPreparedEvent</code> =&gt; </p><p><code>cn.imokkkk.env.DatabaseEnvironmentPostProcessor#postProcessEnvironment</code></p></li></ol><blockquote><p>sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;CREATE TABLE `app_config`  (</span><br><span class="line">&gt;  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">&gt;  `config_key` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">&gt;  `config_value` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">&gt;  `remark` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">&gt;  `is_halt` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,</span><br><span class="line">&gt;  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">&gt;) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用未接入配置中心时，一些配置项(如oss存储配置信息、邮件服务配置信息等)需要从其它数据源获取，下面以从数据库获取配置信息为例。&lt;/p&gt;
&lt;h3 id=&quot;Value&quot;&gt;&lt;a href=&quot;#Value&quot; class=&quot;headerlink&quot; title=&quot;@Value&quot;&gt;&lt;/a&gt;@Value&lt;/h3&gt;&lt;p&gt;既然需要通过从数据库中读取配置信息，那么先了解一下@Value的工作原理：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://imokkkk.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Spring" scheme="https://imokkkk.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码</title>
    <link href="https://imokkkk.github.io/SpringSourceCode/"/>
    <id>https://imokkkk.github.io/SpringSourceCode/</id>
    <published>2022-09-06T08:35:59.549Z</published>
    <updated>2022-11-10T09:19:05.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring源码"><a href="#Spring源码" class="headerlink" title="Spring源码"></a>Spring源码</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><a id="more"></a><table><thead><tr><th>注解</th><th>功能</th></tr></thead><tbody><tr><td>@Bean</td><td>容器中注册组件</td></tr><tr><td>@Primary</td><td>同类组件如果有多个，标注主组件</td></tr><tr><td>@DependsOn</td><td>组件之间声明依赖关系</td></tr><tr><td>@Lazy</td><td>组件懒加载(使用的时候才会创建)</td></tr><tr><td>@Scope</td><td>声明组件的作用域(SCOPE_PROTOTYPE，SCOPE_SINGLETON)</td></tr><tr><td>@Configuration</td><td>声明这是一个配置类，替换配置文件</td></tr><tr><td>@Component</td><td>@Controller、@Service、@Repository</td></tr><tr><td>@Indexed</td><td>加速注解，标注了@Indexed的组件，直接会启动快速加载</td></tr><tr><td>@Order</td><td>数字越小优先级越高，越先工作</td></tr><tr><td>@ComponentScan</td><td>包扫描</td></tr><tr><td>@Conditional</td><td>条件注入</td></tr><tr><td>@Import</td><td>导入第三方Jar包中的组件，或定制批量导入组件逻辑</td></tr><tr><td>@ImportResource</td><td>导入以前的xml配置文件，让其生效</td></tr><tr><td>@Profile</td><td>基于多环境激活</td></tr><tr><td>@PropertySource</td><td>外部properties配置文件和JavaBean进行绑定，结合ConfigurationProperties</td></tr><tr><td>@PropertySource</td><td>@PropertySource组合注解</td></tr><tr><td>@Autowired</td><td>自动装配，默认按类型装配</td></tr><tr><td>@Qualifier</td><td>精确指定，默认按名称装配</td></tr><tr><td>@Resource</td><td>来自于JSR-250，非Spring提供，默认按名称装配</td></tr><tr><td>@Value</td><td>取值、计算机环境变量、JVM系统。@Value(“${XX}”)</td></tr><tr><td>@Lookup</td><td>单例组件依赖非单例组件，非单例组件获取需要使用方法</td></tr></tbody></table><h2 id="Resource-amp-ResourceLoader"><a href="#Resource-amp-ResourceLoader" class="headerlink" title="Resource&amp;ResourceLoader"></a>Resource&amp;ResourceLoader</h2><h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>需要处理不同类型的外部资源(URL、File、ClassPath等等)，而且处理这些资源步骤都是类似的(打开资源，读取资源，关闭资源)。Spring提供Resource接口来统一这些底层资源一致的访问，<strong>作为所有资源的统一抽象</strong>。</p><p><strong>Resource体系</strong></p><p><img data-src="../assets/img/Resource.png" alt></p><p><strong>Resource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前Resource资源是否存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前Resource是否可读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前Resource是否已经打开，如果返回true，则只能被读取一次然后关闭以避免资源泄露；</span></span><br><span class="line"><span class="comment"> * 常见的Resource实现一般返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为文件资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前Resource代表的资源能由java.util.URL代表，则返回该URL，否则抛出IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前Resource代表的资源能由java.util.URI代表，则返回该URL，否则抛出IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前Resource代表的底层资源能由java.io.File代表，则返回该File，否则抛出IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前Resource代表的底层文件资源的长度，一般是值代表的文件资源的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前Resource代表的底层资源的最后修改时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前Resource代表的底层文件资源的文件路径，比如File资源“file://d:/test.txt”将返回“d:/test.txt”；</span></span><br><span class="line"><span class="comment"> * 而URL资源http://www.baidu.cn将返回null，因为只返回文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前Resource代表的底层资源的描述符，通常就是资源的全路径（实际文件名或实际URL地址）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ByteArrayResource：对于字节数组的实现，为其构造一个ByteArrayInputStream；</li><li>ClassPathResource：ClassPath类型资源的实现，使用指定的Class或ClassLoader加载资源。用来访问类加载路径下的资源，该种类型在Web应用中可以自动搜索位于WEB-INF/classes下的资源文件，而无需使用绝对路径访问；</li><li>InputStreamResource：InputStream的实现，如果需要将资源描述符保存在某处，或者如果需要从流中多次读取，不要使用InputStreamResource；</li><li>UrlResource：对于java.net.URL类型资源的实现，支持File和URL的形式，既可以访问网络资源，也可以访问本地资源，加不同的前缀即可；</li><li>FileSystemResource：对java.io.File类型和java.nio.file.Path资源的封装，支持File和URL的形式。实现了WritableResource接口，支持对资源的写操作；</li><li>EncodedResource：实现对文件编码类型的处理。</li></ul><p>它们都继承抽象类AbstractResource，AbstractResource实现了Resource接口。自定义Resource只需继承AbstractResource抽象类，它已经实现Resource接口的大部分公共实现，再根据自定义的资源特性覆盖相应的方法。</p><h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>Resource定义统一的资源，ResourceLoader加载资源。</p><p><strong>ResourceLoader体系</strong></p><p><img data-src="../assets/img/ResourceLoader.png" alt></p><p><strong>DefaultResourceLoader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"><span class="comment">// 是否有自定义协议策略</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以“/”开头，构造返回ClassPathContextResource</span></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="comment">// 以"classpath:"开头，构造返回ClassPathResource</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则构造URL地址</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="comment">// 如果是FileURL，构造返回FileUrlResource，否则构造返回UrlResource</span></span><br><span class="line"><span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">//构造URL失败(不符合URL规范)，当作普通路径处理</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ProtocolResolver</strong></p><p>用户自定义协议资源解决策略，作为DefaultResourceLoader的SPI，允许用户自定义资源加载协议，而不需要继承ResourceLoader的子类。实现ProtocolResolver接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProtocolResolver</span> <span class="keyword">implements</span> <span class="title">ProtocolResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">resolve</span><span class="params">(String location,</span></span></span><br><span class="line"><span class="function"><span class="params">ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"自定义加载资源......"</span>);</span><br><span class="line">FileSystemResourceLoader fileSystemResourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line"><span class="keyword">return</span> fileSystemResourceLoader.getResource(<span class="string">"D:\\IDEAProbject\\openSources\\spring-framework\\gradle\\docs.gradle"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DefaultResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">resourceLoader.addProtocolResolver(<span class="keyword">new</span> MyProtocolResolver());</span><br><span class="line">Resource resource = resourceLoader.getResource(<span class="string">"/"</span>);</span><br><span class="line">System.out.println(resource.getFilename()); <span class="comment">//docs.gradle</span></span><br><span class="line">System.out.println(resource.getDescription()); <span class="comment">//file [D:\IDEAProbject\openSources\spring-framework\gradle\docs.gradle]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ResourcePatternResolver——ResourceLoader接口的增强</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持classpath*:形式路径匹配，即Ant风格；允许使用通配符来对路径进行匹配。"classpath*:"可以返回路径下所有满足条件的资源实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持根据路径匹配模式返回多个 Resource 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PatchMatchingResourcePatternResolver</strong></p><p>ResourcePatternResolver最常用的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负责对基于字符串的路径和指定的模式符号进行匹配</span></span><br><span class="line"><span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化一个DefaultResourceLoader，继承自ResourceLoader的方法委托给内部的DefaultResourceLoader实现</span></span><br><span class="line"><span class="comment"> * PathMatchingResourcePatternResolver只负责处理实现ResourcePatternResolver中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ApplicationContext-amp-BeanFactory"><a href="#ApplicationContext-amp-BeanFactory" class="headerlink" title="ApplicationContext&amp;BeanFactory"></a>ApplicationContext&amp;BeanFactory</h2><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><strong>BeanFactory体系</strong></p><p><img data-src="../assets/img/BeanFactory.png" alt></p><p><strong>BeanFactory</strong></p><p>BeanFactory是访问Spring中Bean容器的顶级接口，提供了IOC容器应遵守的最基本的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FactoryBean实例前缀，如bean的名称为myJndiObject，并且该bean是FactoryBean，则获得&amp;myJndiObject的bean时会返回Factory而不是Factory返回的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定名称的bean</span></span><br><span class="line"><span class="comment"> * 如果name是别名，最终会转换回真实的名称；</span></span><br><span class="line"><span class="comment"> * 如果本Factory实例没找到，会询问父Factory查找；</span></span><br><span class="line"><span class="comment"> * 未找到抛出BeansException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与&#123;<span class="doctag">@link</span> #getBean(String)&#125;类似，增加类型校验，如果类型异常抛出BeanNotOfRequiredTypeException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的参数匹配构造函数或者工厂方法创建给定名称的实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按类型获取唯一Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的参数匹配构造函数或者工厂方法创建给定类型的实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定Bean的Provider，允许延迟按需检索实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否存在指定名称的bean</span></span><br><span class="line"><span class="comment"> * 如果本Factory实例没找到，会询问父Factory查找；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断name对应的bean是否为单例的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断name对应的bean是否为原型作用域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断name对应的bean与指定的类型是否匹配，更具体来说就是判断getBean方法返回的对象与目标类型是否匹配</span></span><br><span class="line"><span class="comment"> * ResolvableType.forClass(XXXX.class)))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断name对应的bean与指定的类型是否匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据name获取其对应的bean的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据name获取其对应的bean的类型。指定是否允许FactoryBean初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定名称的所有别名信息，如果name是别名，返回原始名和其他笔名，原始名在数组的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/image-20220907213437948.png" alt></p><p>有3个接口直接继承了BeanFactory：HierarchicalBeanFactory、ListableBeanFactory、AutowireCapableBeanFactory。</p><p><strong>HierarchiaclBeanFactory</strong></p><p>增加了层级结构管理的功能，通过ConfigurableBeanFactory接口中的setParentBeanFactory，允许配置父BeanFactory。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前BeanFactory的父BeanFactory，如果没有返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回本BeanFactory是否包含指定namne的bean，不考虑父BeanFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ListableBeanFactory</strong></p><p>可以列表所有内部定义的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断BeanFactory是否含给定名称的Bean定义，并不考虑层次结构，并忽略通过Bean定义以外方式注册的单例Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取BeanFactory中已经定义的Bean数量，并不考虑层次结构，并忽略通过Bean定义以外方式注册的单例Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回本BeanFactory中所有Bean定义的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定Bean的提供者，支持延迟初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType, <span class="keyword">boolean</span> allowEagerInit)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType, <span class="keyword">boolean</span> allowEagerInit)</span></span>;</span><br><span class="line"></span><br><span class="line">String[] getBeanNamesForType(ResolvableType type);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回与给定类型及子类匹配的bean的名称</span></span><br><span class="line"><span class="comment"> * allowEagerInit 是否初始化FactoryBean。如果为false，会检查原始的FactoryBean是否与给定类型匹配，不考虑任何层次结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit);</span><br><span class="line"></span><br><span class="line">String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type);</span><br><span class="line"></span><br><span class="line">String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的类型获取其对应的bean实例，其中map的key是bean的名称，value是该bean对应的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找包含给定注解的bean的名称，而不创建对应的bean实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找包含给定注解的bean名称，并创建对应的bean实例，其中返回的map中key为bean名称，value为bean的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在给定name的bean上面查找是否包含给定的注解，如果包含则返回该注解，不包含则返回null</span></span><br><span class="line"><span class="comment"> * 通过此方法可以获得给定bean的注解，并获取其注解中对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, Class&lt;A&gt; annotationType, <span class="keyword">boolean</span> allowFactoryBeanInit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AutowireCapableBeanFactory</strong></p><p>增加了自动装配Bean属性依赖的能力，提供多种自动装配策略和细粒度控制装配过程的方法。</p><p><strong>ConfigurableBeanFactory</strong></p><p>扩展自HierarchicalBeanFactory和SingletonBeanRegistry，提供了对BeanFactory的配置能力。扩展的内容：类加载器、类型转换、属性编辑器、BeanPostProcessor、作用域、bean定义，处理bean依赖关系等。</p><p><strong>ConfigurableListableBeanFactory</strong></p><p>继承自上面3个接口，接口的集大成者。提供了分析和修改BeanDefinition以及预实例化单例的工具。、</p><p><strong>抽象类</strong></p><p>AbstractBeanFactory：实现了ConfigurableBeanFactory大部分功能；</p><p>AbstractAutowireCapableBeanFactory：继承自AbatractBeanFactory，并额外实现了AutowireCapableBeanFactory。</p><p><strong>实现类</strong></p><p>DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，并实现了ConfigurableListableBeanFactory和BeanDefinitionRegistry。</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext扩展自ResourcePatternResolver、ListableBeanFactory、HierarchicalBeanFactory、MessageSource、ApplicationEventPublisher、EnvironmentCapable。ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能，而且ApplicationContext还在功能上做了扩展。有如下功能：</p><ol><li>发现、定义、维护、管理Bean；</li><li>可以向外界暴露当前程序所运行的环境信息；</li><li>国际化；</li><li>事件发布/订阅；</li><li>解析资源；</li><li>层次化上下文；</li><li>一些context可能通过持有AutowireCapableBeanFactory来支持自动装载能力。</li></ol><p><strong>ApplicationContext体系</strong></p><p><img data-src="../assets/img/ApplicationContext.png" alt></p><p><strong>ConfigurableApplicationContext</strong></p><p>提供了配置ApplicationContext的功能。配置和生命周期方法被封装在这里，以避免它们对使用ApplicationContext的代码可见。</p><p><strong>AbstractApplicationContext</strong></p><p>模板模式：模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。</p><p>refresh：<strong>加载或刷新配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="comment">// 加锁：registerShutdownHook，close，refresh互斥</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 通知子类刷新内部factory并返回</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//准备BeanFactory以在此上下文中使用</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 后置处理BeanFactory</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">//调用所有注册在context中的BeanFactoryPostProcessor</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//注册BeanPostProcessor后置处理器，这里的后置处理器在下方实例化Bean方法中会用到</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">beanPostProcess.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">//初始化特定子类上下文中的其它特殊bean（模板模式）</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//实例化BeanFactory中已经被注册但是未实例化的所有Bean(懒加载的不需要实例化)。即生成环境所需要的Bean。</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">contextRefresh.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ClassPathXmlApplicationContext</strong></p><p>通过读取类路径下的xml配置文件来构建ApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//refresh也会调用子类的相关方法以模板模式来完成整个刷新功能，刷新的最终结果就是beanfactory中被塞了一些context需要的bean和postprocessor，并且beandefinition被冻结，所有singleton被预实例化。</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XmlBeanDefinitionReder</p><p>自动扫描和自动装配的功能都是context命名空间提供的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取一个命名空间处理器解析器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandlerResolver <span class="title">getNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.namespaceHandlerResolver == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.namespaceHandlerResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> NamespaceHandlerResolver <span class="title">createDefaultNamespaceHandlerResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ClassLoader cl = (getResourceLoader() != <span class="keyword">null</span> ? getResourceLoader().getClassLoader() : getBeanClassLoader());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultNamespaceHandlerResolver(cl); <span class="comment">//META-INF/spring.handlers</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextNamespaceHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser()); <span class="comment">//组件自动扫描</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NamespaceHandlerSupport</p><p>策略模式+模板模式</p><p>NamespaceHolder继承了NamespaceHolderSupport，可以通过注册BeanDefinitionParser和BeanDefinitionDecorator来解析对应的XML节点，执行需要的功能，注册该功能返回的BeanDefinition。</p><p>ComponentScanBeanDefinitionParser</p><p>使用component-scan时的自动装配功能并不是BeanFactory实现的，它通过为BeanDefinition设置默认值，完全禁用了每一个Bean的自动装配功能，取而代之的是，它通过BeanPostProcessor拦截Bean的生命周期实现仅对具有@Autowired注解的属性注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给basePackage包下所有<span class="doctag">@Component</span>标注的类创建BeanDefinition，应用默认BeanDefinition设置，</span></span><br><span class="line"><span class="comment"> * 并且检查Bean类上的一些注解，对BeanDefinition进行对应设置，如<span class="doctag">@Lazy</span>注解。</span></span><br><span class="line"><span class="comment"> * 最后，它会将BeanDefinition包装成BeanDefinitionHolder，并返回Holder列表。</span></span><br><span class="line"><span class="comment"> * 而且，该方法已经向BeanFactoryRegistry注册了BeanDefinition。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line"><span class="comment">//初始化BeanDefinition集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//扫描所有basePackage</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//候选组件</span></span><br><span class="line"><span class="comment">//使用自带的默认AnnotationTypeFilter来过滤basePackage指定的所有包下具有@Component注解的组件</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//设置作用域</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">//bean名称</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">//检测是否具有@Lazy、@Primary、@DependsOn、@Role、@Description注解，如果有就向BeanDefinition中设置对应的配置</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">//将BeanDefinition以及生成的beanName包装到BeanDefinitionHolder中</span></span><br><span class="line"><span class="comment">//BeanDefinitionHolder中封装了BeanDefinition和它的BeanName、别名等信息</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">//向registry中注册BeanDefinition</span></span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathBeanDefinitionScanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给basePackage包下所有<span class="doctag">@Component</span>标注的类创建BeanDefinition，应用默认BeanDefinition设置，</span></span><br><span class="line"><span class="comment"> * 并且检查Bean类上的一些注解，对BeanDefinition进行对应设置，如<span class="doctag">@Lazy</span>注解。</span></span><br><span class="line"><span class="comment"> * 最后，它会将BeanDefinition包装成BeanDefinitionHolder，并返回Holder列表。</span></span><br><span class="line"><span class="comment"> * 而且，该方法已经向BeanFactoryRegistry注册了BeanDefinition。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line"><span class="comment">//初始化BeanDefinition集合</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//扫描所有basePackage</span></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">//候选组件</span></span><br><span class="line"><span class="comment">//使用自带的默认AnnotationTypeFilter来过滤basePackage指定的所有包下具有@Component注解的组件</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//设置作用域</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">//bean名称</span></span><br><span class="line">String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">//检测是否具有@Lazy、@Primary、@DependsOn、@Role、@Description注解，如果有就向BeanDefinition中设置对应的配置</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line"><span class="comment">//将BeanDefinition以及生成的beanName包装到BeanDefinitionHolder中</span></span><br><span class="line"><span class="comment">//BeanDefinitionHolder中封装了BeanDefinition和它的BeanName、别名等信息</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder =</span><br><span class="line">AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">//向registry中注册BeanDefinition</span></span><br><span class="line">registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li><code>ClassPathXmlApplicationContext</code>默认并不带自动装配功能，它只通过XML中定义的结构去解析并生成BeanDefinition；</li><li>自动装配功能由<code>context</code>命名空间提供；</li><li><code>context</code>命名空间的组件扫描功能为每一个扫描到的组件都定义了它BeanDefinition的默认值，并在关闭了它的自动装配功能；</li><li><code>context</code>命名空间通过向ApplicationContext中添加<code>BeanPostProcessor</code>Bean来向底层BeanFactory中注册一批BeanPostProcessor，这其中包括用于实现自动装配的<code>AutowiredAnnotationBeanPostProcessor</code>；</li><li><code>AutowiredAnnotationBeanPostProcessor</code>是一个实例化感知BeanPostProcessor，它重写<code>postProcessProperties</code>方法和<code>postProcessPropertyValues</code>方法，拦截了Bean初始化阶段的属性设置post-processing。它对于每一个包含<code>@Value</code>、<code>@Autowired</code>、<code>@Inject</code>注解的属性，通过调用BeanFactory中的<code>resolveDependency</code>来获得需要被注入的Bean或值，并注入进被拦截的Bean中。</li></ul><h3 id="ApplicationContext与BeanFactory的区别"><a href="#ApplicationContext与BeanFactory的区别" class="headerlink" title="ApplicationContext与BeanFactory的区别"></a>ApplicationContext与BeanFactory的区别</h3><ol><li>BeanFactory是IOC底层容器，面向Spring；ApplicationContext是具备应用特性的BeanFactory超集，面向使用 Spring框架的开发者。额外提供AOP、资源管理、国际化、事件、Environment抽象等功能；</li><li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化；ApplicationContext则在容器启动时，就实例化Bean，常驻在容器内，也可以为Bean配置Lazy-init=true来让Bean延迟实例化。</li></ol><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p><strong>Spring容器启动的过程中，会将Bean解析成Spring内部的BeanDefinition结构</strong>。 不管是是通过xml配置文件的<code>\&lt;Bean&gt;</code>标签，还是通过注解配置的@Bean，它最终都会被解析成一个Bean定义信息（对象），最后我们的Bean工厂就会根据这份Bean的定义信息，对bean进行实例化、初始化等等操作</p><h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>Spring中Bean的定义，包含Bean的元数据信息：对应的bean的全限定类名，属性值，构造方法参数值和继承自它的类的更多信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果父类存在，设置这个bean定义的父定义的名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定此bean定义的bean类名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖此bean的作用域，指定一个新的作用域。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *设置这个bean是否应该被延迟初始化。如果false，那么这个bean将在启动时由bean工厂实例化，</span></span><br><span class="line"><span class="comment"> * 懒加载 &lt;bean lazy-init="true/false"&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置这个bean依赖被初始化的bean的名字。 bean工厂将保证这些bean首先被初始化。</span></span><br><span class="line"><span class="comment"> * &lt;bean depends-on=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置Bean是否是自动装配的候选者 默认为 true XML中的 &lt;bean autowire-candidate=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果找到了多个可注入bean，那么则选择被Primary标记的bean/获取当前 Bean 是否为首选的 Bean  XML中的 &lt;bean primary=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置FactoryBean的名字  XML中的&lt;bean factory-bean=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置/获取 FactoryMethod 的名字，可以是某个实例的方法（和factoryBean配合使用）</span></span><br><span class="line"><span class="comment"> * 也可以是静态方法。 XML 中的&lt;bean factory-method=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回该 Bean 构造方法的参数值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取普通属性的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置 Bean 的初始化方法 XML中的&lt;bean init-method=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getInitMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置 Bean 的销毁方法  XML中的&lt;bean destroy-method=""&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDestroyMethodName</span><span class="params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getDestroyMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRole</span><span class="params">(<span class="keyword">int</span> role)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(@Nullable String description)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a human-readable description of this bean definition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read-only attributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a resolvable type for this bean definition,</span></span><br><span class="line"><span class="comment"> * based on the bean class or other specific metadata.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is typically fully resolved on a runtime-merged bean definition</span></span><br><span class="line"><span class="comment"> * but not necessarily on a configuration-time definition instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resolvable type (potentially &#123;<span class="doctag">@link</span> ResolvableType#NONE&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#getMergedBeanDefinition</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用来解析一个Bean对应的类型上的各种信息，比如泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ResolvableType <span class="title">getResolvableType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single, shared instance</span></span><br><span class="line"><span class="comment"> * returned on all calls.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance</span></span><br><span class="line"><span class="comment"> * returned for each call.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return whether this bean is "abstract", that is, not meant to be instantiated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a description of the resource that this bean definition</span></span><br><span class="line"><span class="comment"> * came from (for the purpose of showing context in case of errors).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the originating BeanDefinition, or &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Allows for retrieving the decorated bean definition, if any.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the</span></span><br><span class="line"><span class="comment"> * originator chain to find the original BeanDefinition as defined by the user.</span></span><br><span class="line"><span class="comment"> * 如果当前 BeanDefinition 是一个代理对象，那么该方法可以用来返回原始的 BeanDefinition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanDefinition体系</strong></p><p><img data-src="../assets/img/BeanDefinition.png" alt></p><p><strong>AttributeAccessor</strong></p><p>为其它任意类中获取或设置元数据提供了一个通用的规范。具体实现是AttributeAccessorSupport，采用LinkedHashMap进行存储。</p><p><strong>BeanMetadataDefinition</strong></p><p>提供了getSource()，返回Bean的来源。</p><h3 id="抽象实现"><a href="#抽象实现" class="headerlink" title="抽象实现"></a>抽象实现</h3><p><strong>AbstractBeanDefinition</strong></p><p>抽象类，BeanDefinition定义了一系列的get/set方法，并没有提供对应的属性。AbstractBeanDefinition中将所有的属性定义出来了。</p><p><strong>RootBeanDefinition</strong></p><p>Spring去创建Bean就是基于RootBeanDefinition，在AbstractBeanDefinition的基础上扩展一些之外的功能。</p><p><strong>ChildBeanDefinition</strong></p><p>不可以单独存在，必须依赖一个父BeanDefinition。构造ChildBeanDefinition时，其构造方法传入父BeanDefinition的名称或通过setParentName设置父BeanDefinition名称。它可以从父类继承方法参数、属性值，并可以重写父类的方法，同时也可增加新的属性或者方法。</p><p>Spring2.5之后，逐渐被GenericBeanDefinition替代。</p><p><strong>GenericBeanDefinition</strong></p><p>GenericBeanDefinition 可以动态设置父 Bean，同时兼具 RootBeanDefinition 和 ChildBeanDefinition 的功能。通过注解配置的bean以及XML配置的BeanDefinition类型都是GenericBeanDefinition。</p><h3 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h3><p><strong>AnnotatedBeanDefinition</strong></p><p>表示注解类型 BeanDefinition，拥有获取注解元数据和方法元数据的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要对 Bean 的注解信息进行操作，如：获取当前 Bean 标注的所有注解、判断是否包含指定注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法的元数据类。提供获取方法名称、此方法所属类的全类名、是否是抽象方法、判断是否是静态方法、判断是否是final方法等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AnnotatedGenericBeanDefinition</strong></p><p>xxxBeanDefinitionReader加载的BeanDefinition</p><p>继承自GenericBeanDefinition并实现了AnnotatedBeanDefinition接口，使用了 @Configuration 注解标记配置类会解析为 AnnotatedGenericBeanDefinition。</p><p><strong>ScannedGenericBeanDefinition</strong></p><p>ClassPathBeanDefinitionScanner加载的BeanDefinition</p><p>实现了 AnnotatedBeanDefinition也继承了 GenericBeanDefinition。使用了@Component、@Service、@Controller等注解类会解析为 ScannedGenericBeanDefinition。</p><p><strong>ConfigurationClassBeanDefinition</strong></p><p>ConfigurationClassBeanDefinitionReader的一个使用静态内部类，负责将使用了@Bean的方法转换为ConfigurationClassBeanDefinition 类。</p><p>Spring初始化时，会用GenericBeanDefinition或是ConfigurationClassBeanDefinition（<strong>用@Bean注解注释的类</strong>）存储用户自定义的Bean，在初始化Bean时，又会将其转换为RootBeanDefinition。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>BeanDefinitionBuilder</strong></p><p>快速创建一个BeanDefinition，可以进行链式的方法调用，<strong>建造者模式</strong>，默认是GenericBeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(User<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//<span class="title">Spring5</span>.0后提供的，可以自己书写函数，在里面做任意事情</span></span><br><span class="line"><span class="class">.<span class="title">applyCustomizers</span>(</span></span><br><span class="line"><span class="class">//<span class="title">bd</span>是个<span class="title">AbstractBeanDefinition</span></span></span><br><span class="line"><span class="class">(<span class="title">bd</span> -&gt; </span>&#123;</span><br><span class="line">MutablePropertyValues propertyValues = bd.getPropertyValues();</span><br><span class="line">propertyValues.add(<span class="string">"name"</span>, <span class="string">"安卓"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">).getBeanDefinition();</span><br><span class="line">System.out.println(beanDefinition); <span class="comment">//Generic bean: class [cn.BeanDefinition.RootBeanDefinition.User]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null</span></span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">"user"</span>, beanDefinition);</span><br><span class="line">User user = (User) beanFactory.getBean(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user); <span class="comment">//User(name=安卓, age=null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanDefinitionReader</strong></p><p>读取Spring配置文件中的内容，将其转换为IOC容器内的数据结构BeanDefinnition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到Bean定义的register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于加载资源的 ResourceLoader（可以为null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载Bean的类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成Bean名称的名字生成器（若没有指定名称的话，会调用它生成）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心方法，加载bean定义进来，然后注册到上面的register里面去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/image-20220915142457917.png" alt="BeanDefinitionReader继承结构"></p><ul><li><p>AbstractBeanDefinitionReader</p><p>实现了EnvironmentCapable，提供了获取/设置环境的方法。实现一些基本方法，通过策略模式核心方法loadBeanDefinitions交给子类实现。</p></li><li><p>XmlBeanDefinitionReader</p><p>继承了 AbstractBeanDefinitionReader 所有的方法，同时也扩展了很多新的方法，主要用于读取 XML 文件中定义的 bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.获取资源</span></span><br><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"spring-config.xml"</span>);</span><br><span class="line"><span class="comment">// 2.获取BeanFactory</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">// 3.根据新建的BeanFactory创建一个BeanDefinitionReader对象，用于资源解析</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"><span class="comment">// 4.装载资源</span></span><br><span class="line"><span class="comment">// 4.1 资源定位</span></span><br><span class="line"><span class="comment">// 4.2 装载：BeanDefinitionReader读取、解析Resource资源，也就是将用户定义的Bean表示成IOC容器的内部数据结构：BeanDefinition。</span></span><br><span class="line"><span class="comment">// 4.3 注册：向IOC容器注册在第二步解析好的BeanDefinition，这个过程是通过BeanDefinitionRegistry接口来实现的。</span></span><br><span class="line"><span class="comment">// 本质上是将解析得到的BeanDefinition注入到一个HashMap容器中，IOC容器就是通过这个HashMap来维护这些BeanDefinition的。</span></span><br><span class="line"><span class="comment">// 注意：此过程并没有完成依赖注入，依赖注册是发生在应用第一次调用getBean()向容器索要Bean时。(可以通过设置预处理，即对某个Bean设置lazyInit属性)</span></span><br><span class="line">beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">Person person = beanFactory.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PropertiesBeanDefinitionReader</p><p>从properties文件或者Map里加载Bean。</p></li><li><p>GroovyBeanDefinitionReader</p><p>可以读取 Groovy 语言定义的 Bean。</p></li></ul><p>@Bean是@Configuration，统一由ConfigurationClassParser#parse()处理；</p><p>@Component这种组件统一由解析@ComponentScan的处理器的ComponentScanAnnotationParser(借助ClassPathBeanDefinitionScanner)。</p><h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><p>有时需要感知到容器的存在，获取容器相关信息，Spring提供许多实现Aware接口的类，这些类主要是为了辅助Spring访问容器中的数据。</p><p><img data-src="../assets/img/image-20220929100532369.png" alt></p><h3 id="常见的Aware接口"><a href="#常见的Aware接口" class="headerlink" title="常见的Aware接口"></a>常见的Aware接口</h3><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>BeanNameAware</td><td>获得容器中Bean名称</td></tr><tr><td>BeanClassLoaderAware</td><td>获得类加载器</td></tr><tr><td>BeanFactoryAware</td><td>获得Dean创建工厂</td></tr><tr><td>EnvironmentAware</td><td>获得环境变量</td></tr><tr><td>EmbeddedValueResolverAware</td><td>获得Spring容器加载的Properties文件属性值</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器</td></tr><tr><td>ApplicationEventPublishAware</td><td>获得应用事件发布器</td></tr><tr><td>MessageSourceAware</td><td>获得文本信息</td></tr><tr><td>ApplicationContextAware</td><td>获得当前应用上下文</td></tr></tbody></table><h3 id="Aware调用链"><a href="#Aware调用链" class="headerlink" title="Aware调用链"></a>Aware调用链</h3><p><code>AbstractAutowireCapableBeanFactory#createBean()</code> ===&gt; <code>AbstractAutowireCapableBeanFactory#doCreateBean()</code> ===&gt;<br><code>AbstractAutowireCapableBeanFactory#initializeBean()</code> ===&gt; <code>AbstractAutowireCapableBeanFactory#invokeAwareMethods()</code> ===&gt; <code>AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization()</code> ===&gt; <code>ApplicationContextAwareProcessor#postProcessBeforeInitialization()</code> ===&gt;  <code>ApplicationContextAwareProcessor#invokeAwareInterfaces()</code></p><h3 id="自定义Aware"><a href="#自定义Aware" class="headerlink" title="自定义Aware"></a>自定义Aware</h3><ol><li><p>新建接口继承Aware</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyBeanNameAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个BeanPostProcessor实现类，重新postProcessBeforeInitialization处理自定义的Aware</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanNameAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBeanNameAware)&#123;</span><br><span class="line">((MyBeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">MyBeanNameAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String beanName;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"test"</span> + <span class="string">"___"</span> + <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beanName = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactory的后置处理器，用来对BeanFactory进行加工。</p><p>修改已经注册的beanDefinition的元信息。发生在Spring启动时，实例化单例Bean之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">BeanDefinition userService = beanFactory.getBeanDefinition(<span class="string">"userService"</span>);</span><br><span class="line">userService.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ApplicationContext内部有一个核心的DefaultListableBeanFactory，实现了ConfigurableListableBeanFactory和BeanDefinitionRegistry接口，所以ApplicationContext和DefaultListableBeanFactory是可以注册BeanDefinition的，但是ConfigurableListableBeanFactory是不能注册BeanDefinition的，只能获取BeanDefinition，然后做修改。</p><h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a><strong>BeanDefinitionRegistryPostProcessor</strong></h3><p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，所以BeanDefinitionRegistryPostProcessor不仅提供postProcessBeanFactory()，方法还扩展了支持注册BeanDefinition的方法postProcessBeanDefinitionRegistry()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      registry.registerBeanDefinition(<span class="string">"1"</span>,</span><br><span class="line">            BeanDefinitionBuilder.genericBeanDefinition(OrderService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                  .<span class="title">getBeanDefinition</span>())</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactoryPostProcessor调用链"><a href="#BeanFactoryPostProcessor调用链" class="headerlink" title="BeanFactoryPostProcessor调用链"></a>BeanFactoryPostProcessor调用链</h3><p><code>AbstractApplicationContext#refresh()</code> ===&gt; <code>AbstractApplicationContext#invokeBeanFactoryPostProcessors()</code> ===&gt; <code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors()</code> ===&gt; <code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors()</code> ===&gt; <code>BeanFactoryPostProcessor#postProcessBeanFactory()</code></p><h2 id="InitializingBean、DisposableBean"><a href="#InitializingBean、DisposableBean" class="headerlink" title="InitializingBean、DisposableBean"></a>InitializingBean、DisposableBean</h2><p>Spring 开放了扩展接口，允许自定义 bean 的初始化和销毁方法。即当 Spring 容器在 bean 进行到相应的生命周期阶段时，会自动调用我们自定义的初始化和销毁方法。这两个扩展接口即是 <code>InitializingBean</code> 和 <code>DisposableBean</code> 。</p><h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>InitializingBean与SmartInitialzingSingleton的区别</strong></p><ol><li><p>SmartInitialzing只作用于单例Bean，InitialzingBean无此要求；</p></li><li><p>SmartInitialzing是在所有的非懒加载单例Bean初始化完成后调用，InitialzingBean在每个Bean初始化后调用。</p><ul><li><p>InitialzingBean调用源码：org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否实现了initializingBean接口</span></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.hasAnyExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//执行自定义的afterPropertiesSet()</span></span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">                <span class="comment">//反射调用指定的initMethod</span></span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SmartInitialzingBean调用源码：org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="comment">// 触发所有非延迟加载单例 Bean 的初始化</span></span><br><span class="line">......</span><br><span class="line">       <span class="comment">//触发所有 SmartInitializingSingleton 后初始化的回调</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">"spring.beans.smart-initialize"</span>)</span><br><span class="line">.tag(<span class="string">"beanName"</span>, beanName);</span><br><span class="line">SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">smartInitialize.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h3><p>DisposableBean 接口为<code>单例 bean</code>提供了在容器销毁 bean 时的处理方法，在 bean 被销毁时都会执行重写了的destroy()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用源码：org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#destroyBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(String beanName, @Nullable DisposableBean bean)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//执行destroy</span></span><br><span class="line">bean.destroy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Destruction of bean with name '"</span> + beanName + <span class="string">"' threw an exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring-Factories"><a href="#Spring-Factories" class="headerlink" title="Spring Factories"></a>Spring Factories</h2><p>Spring Factories是一种类似于Java SPI的机制，在resources/META-INF/spring.factories文件中配置接口的实现类名称(接口名称=实现类)，然后在程序中读取该配置文件并实例化，是spring-boot-starter-xxx的实现基础。</p><h3 id="为什么需要spring-factories？"><a href="#为什么需要spring-factories？" class="headerlink" title="为什么需要spring.factories？"></a>为什么需要spring.factories？</h3><p><strong>如果想要被Spring容器管理的Bean的路径不在spring-boot项目的扫描路径下，该怎么办呢？</strong></p><p>解耦容器注入，帮助外部包(独立于spring-boot项目)注册Bean到spring-boot项目中。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>org.springframework.core.io.support.SpringFactoriesLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按接口获取spring.fatories文件中的实现类的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(factoryType, <span class="string">"'factoryType' must not be null"</span>);</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loaded ["</span> + factoryType.getName() + <span class="string">"] names: "</span> + factoryImplementationNames);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryImplementationNames.size());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按接口获取spring.factories文件中的实现类全称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line">String factoryTypeName = factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链路：<br><code>org.springframework.boot.SpringApplication#SpringApplication()</code> ==&gt;<br><code>org.springframework.boot.SpringApplication#getSpringFactoriesInstances()</code> ==&gt;<br><code>org.springframework.core.io.support.SpringFactoriesLoader#loadFactoryNames</code> ==&gt;<br><code>org.springframework.core.io.support.SpringFactoriesLoader#loadSpringFactories</code></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>从数据库加载配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseEnvironmentPostProcessor</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">      SpringApplication application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">"databasePropertySources"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring.factories：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.web.env.DatabaseEnvironmentPostProcessor</span></span><br></pre></td></tr></table></figure><blockquote><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTEzMTY2MTg2ODQ5NzYzMzU4">https://juejin.cn/post/7113166186849763358<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring源码&quot;&gt;&lt;a href=&quot;#Spring源码&quot; class=&quot;headerlink&quot; title=&quot;Spring源码&quot;&gt;&lt;/a&gt;Spring源码&lt;/h1&gt;&lt;h2 id=&quot;核心注解&quot;&gt;&lt;a href=&quot;#核心注解&quot; class=&quot;headerlink&quot; title=&quot;核心注解&quot;&gt;&lt;/a&gt;核心注解&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://imokkkk.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Spring" scheme="https://imokkkk.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一个Java对象的大小怎么计算？</title>
    <link href="https://imokkkk.github.io/javaobjectsize/"/>
    <id>https://imokkkk.github.io/javaobjectsize/</id>
    <published>2022-06-27T02:20:37.207Z</published>
    <updated>2022-06-27T02:20:42.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一个Java对象的大小怎么计算？"><a href="#一个Java对象的大小怎么计算？" class="headerlink" title="一个Java对象的大小怎么计算？"></a>一个Java对象的大小怎么计算？</h2><p><strong>对象头+实例数据+对其填充</strong></p><p><strong>对象头</strong></p><ol><li>MarkWord：用于存储对象运行时的数据，如hashCode、锁状态标志、GC分代年龄等。<strong>64位操作系统占8字节，32位操作系统占4字节。</strong></li><li>对象元数据指针(kclass)：对象指向类的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。<strong>开启压缩指针占4字节，未开启占8字节。</strong></li><li>数组长度：<strong>只有数组对象才有，占4字节。</strong></li></ol><a id="more"></a><p><strong>实例数据</strong></p><p>实例数据可能包括两种：</p><ol><li><p>8种基本数据类型</p><table><thead><tr><th>类型</th><th>占用空间</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>char</td><td>2</td></tr><tr><td>short</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr><tr><td>Reference</td><td>4</td></tr></tbody></table></li><li><p>对象</p></li></ol><p><strong>对其填充(Padding)</strong></p><p>Java对象内存起始地址必须为8的整数倍，即Java对象大小必须为8的整数倍。当对象头+实例数据大小不为8的整数倍时，将会使用对其填充。</p><p>如64位，开启压缩指针的虚拟机上new Object()实际大小：</p><p>Mark Word(8B) + kclass(4B) + Padding(4B) = 16B</p><p><strong>例子</strong></p><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark Word(8B) + kclass(4B) + i(4B) = 16B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark Word(8B) + kclass(4B) + i(4B) + j(4B) + s(4B) + b(1B) + c(2B) + Padding(5B) = 32B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HotSpot创建的对象的字段会默认按从长到短，引用排最后排序：long/double --&gt; int/float --&gt; short/char --&gt; byte/boolean --&gt;Reference</span></span><br><span class="line"><span class="comment">//Mark Word(8B) + kclass(4B) + i1(4B) + i2(4B) + b1(1B) + b2(1B) + b3(1B) + Padding(1B) + s(4B) + obj(4B) = 32B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSizeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i1; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b1; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b2; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i2;<span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> b3;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一个Java对象的大小怎么计算？&quot;&gt;&lt;a href=&quot;#一个Java对象的大小怎么计算？&quot; class=&quot;headerlink&quot; title=&quot;一个Java对象的大小怎么计算？&quot;&gt;&lt;/a&gt;一个Java对象的大小怎么计算？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;对象头+实例数据+对其填充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象头&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MarkWord：用于存储对象运行时的数据，如hashCode、锁状态标志、GC分代年龄等。&lt;strong&gt;64位操作系统占8字节，32位操作系统占4字节。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对象元数据指针(kclass)：对象指向类的指针，虚拟机通过这个指针来确定这个对象是哪一个类的实例。&lt;strong&gt;开启压缩指针占4字节，未开启占8字节。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数组长度：&lt;strong&gt;只有数组对象才有，占4字节。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://imokkkk.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://imokkkk.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Kubernetes</title>
    <link href="https://imokkkk.github.io/docker/"/>
    <id>https://imokkkk.github.io/docker/</id>
    <published>2022-06-20T06:22:51.218Z</published>
    <updated>2022-09-09T08:54:26.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li><p><strong>Chroot</strong></p><p>改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。</p></li><li><p><strong>NameSpace</strong></p><p>对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。</p></li><li><p><strong>Cgroup</strong></p><p>限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。</p></li></ol><a id="more"></a><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="容器的5种状态"><a href="#容器的5种状态" class="headerlink" title="容器的5种状态"></a>容器的5种状态</h3><p>初建、运行、停止、暂停、删除。</p><p><img data-src="../assets/img/image-20220413161321391.png" alt></p><h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>与服务端交互：</p><ol><li>Docker命令</li><li>REST API</li><li>SDK</li></ol><h3 id="Docker服务端"><a href="#Docker服务端" class="headerlink" title="Docker服务端"></a>Docker服务端</h3><p>dockerd(Docker Daemon)：负责响应和处理来自客户端的请求，然后将其转化为具体操作。</p><p>containerd：通过containerd-shim启动并管理runC</p><p>runC：用来运行容器的轻量级工具</p><h3 id="docker-attach-exec"><a href="#docker-attach-exec" class="headerlink" title="docker attach/exec"></a>docker attach/exec</h3><p>docker attach：给一个正在运行的容器分配了stdin、stdout、stderr，所有终端窗口同(显示一样的内容；同时阻塞)，使用exit退出时原容器也会退出，可以使用Ctrl+C。</p><p>docker exec：相当于fork了一个和容器相同NameSpace的进程。</p><h2 id="镜像与容器的区别"><a href="#镜像与容器的区别" class="headerlink" title="镜像与容器的区别"></a>镜像与容器的区别</h2><p>docker image inspect &lt; image &gt; 查看镜像分层</p><p><strong>镜像中的层都是只读的，容器在镜像上多了一个读写层。</strong></p><p>docker commit 可以基于运行时的容器生成新的镜像，将读写层数据写到新的镜像中。</p><p><strong>所有写入或修改运行时容器的数据都存储在读写层，当容器停止运行时，读写层的数据也会同时删除掉。</strong></p><p>写时复制：因为镜像层的数据是只读的，所以我们运行同一个镜像的多个容器副本时，可以共享镜像存储层，节省磁盘。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p><img data-src="../assets/img/image-20220429133157063.png" alt></p><p>将镜像层(只读)组织成多个目录(branch)，运行时容器文件作为一层容器层(读写)覆盖在镜像层之上，最后通过联合挂载技术呈现。</p><p><strong>联合挂载：</strong>同一个挂载点同时挂载多个文件系统，将挂载点的源目录与挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层文件和目录。</p><h3 id="OverlayFS"><a href="#OverlayFS" class="headerlink" title="OverlayFS"></a>OverlayFS</h3><p><img data-src="../assets/img/image-20220429141408096.png" alt></p><p>将镜像层(只读)称为lowerdir，容器层(读写)称为upperdir，最后联合挂载为mergedir，在容器上的改动，在upperdir、mergeddir中都会体现。</p><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="docker0网桥"><a href="#docker0网桥" class="headerlink" title="docker0网桥"></a>docker0网桥</h3><p><img data-src="../assets/img/image-20220524114018238.png" alt></p><p>启动Docker Daemon进程之后，会多出一个docker0的网卡，连接容器网段和宿主机网段，IP: 172.17.0.1/16(可修改)。</p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>Docker会在宿主机系统上增加一些iptables规则，用来管理Docker容器与容器之间及外界的通信。</p><ul><li>外界访问Docker是通过iptables做DNAT实现的，DNAT将SNAT中的Source转成Destiantion，表示目的地址转换。</li></ul><h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><ul><li><p><strong>bridge模式</strong></p><p>默认网络模式，所有Docker容器连接到docker0网桥或自定义网桥上，所有的Docker容器处于同一个子网。</p></li><li><p><strong>host模式</strong></p><p>Docker容器和宿主机使用同一个网络协议栈(同一个network namespace)，和宿主机共享网卡、IP、端口等信息。性能更好，但没做网络隔离。</p></li><li><p><strong>overlay模式</strong></p><p>在多个Docker Daemon之间创建一个分布式网络，允许容器之间加密通讯，需要处理容器之间和主机之间的网络包。</p></li><li><p>macvlan模式</p><p>网卡虚拟化技术，可以在同一个物理网卡上虚拟出多个网卡，通过不同的Mac地址在数据链路层进行网络数据的转发。</p></li><li><p>none模式</p><p>除了自带的IO网卡(loopback 127.0.0.1)外没有其它任何网卡、IP等信息，需要自己添加网卡。</p></li></ul><h2 id="容器间网络通信：link"><a href="#容器间网络通信：link" class="headerlink" title="容器间网络通信：link"></a>容器间网络通信：link</h2><p>将新创建出来的Docker容器与已有的容器之间创建一个安全通道来做数据交互。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name mysql mysql:latest</span><br><span class="line">docker run --name busybox --link mysql:mysql busybox:latest </span><br><span class="line"><span class="meta">#</span><span class="bash">--link name or id:<span class="built_in">alias</span>，第一个参数是目标容器的名字或者ID，第二个<span class="built_in">alias</span>相当于在busybox Docker容器中访问MySQL Docker容器的host。</span></span><br></pre></td></tr></table></figure><ul><li><p>host文件修改</p><p>容器/etc/hosts文件中多了一条<code>172.17.0.2 mysql e47e603ffb17</code>记录</p></li><li><p>环境变量</p><p>通过link建立连接之后，会在接收容器额外设置一些环境变量保存源容器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ # env | grep MYSQL</span><br><span class="line">MYSQL_PORT_33060_TCP=tcp://172.17.0.2:33060</span><br><span class="line">MYSQL_ENV_MYSQL_MAJOR=8.0</span><br><span class="line">MYSQL_PORT_3306_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_ENV_MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">MYSQL_ENV_GOSU_VERSION=1.7</span><br><span class="line">MYSQL_PORT_3306_TCP_PORT=3306</span><br><span class="line">MYSQL_PORT_3306_TCP_PROTO=tcp</span><br><span class="line">MYSQL_PORT_33060_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_PORT=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_3306_TCP=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_33060_TCP_PORT=33060</span><br><span class="line">MYSQL_ENV_MYSQL_VERSION=8.0.19-1debian9</span><br><span class="line">MYSQL_PORT_33060_TCP_PROTO=tcp</span><br><span class="line">MYSQL_NAME=/busybox/mysql</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker数据存储模式"><a href="#Docker数据存储模式" class="headerlink" title="Docker数据存储模式"></a>Docker数据存储模式</h2><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>Volume会把文件存储在宿主机的指定位置(Linux：/var/lib/docker/volumes/)，这些文件只能由Docker进程修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-4-5-centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test -v my-vol:/data nginx:latest</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test --mount type=volume,src=myvol,target=/data nginx:latest</span><br></pre></td></tr></table></figure><p>-v/–volume：volume的名字(匿名可忽略):容器内的挂载点</p><p>type=volume,src=&lt; VOLUME-NAME&gt;,dst=&lt; CONTAINER-PATH&gt;,volume-driver=local</p><h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>可以将文件存储到宿主机的任意位置，而且别的应用程序也可以修改。</p><h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>只支持linux，只会将数据存储在宿主机的内存中，并不会落盘，容器停止，数据就会被清除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name test --mount type=tmpfs,target=/data,tmpfs-mode=1770 nginx:latest</span><br></pre></td></tr></table></figure><ul><li>tmpfs-size：指定tmpfs的大小，默认不受限制，单位byte</li><li>tmpfs-mode：Linux系统的文件模式，默认1777，任何用户都可以写</li></ul><h2 id="为什么说Docker是单进程模型？"><a href="#为什么说Docker是单进程模型？" class="headerlink" title="为什么说Docker是单进程模型？"></a>为什么说Docker是单进程模型？</h2><p>不管是在容器还是虚拟机中都有一个1号进程(容器：entrypoint启动进程；虚拟机：systemd进程)，然后其它进程都是1号进程的子进程，或子进程的子进程等等。</p><h3 id="回收子进程资源"><a href="#回收子进程资源" class="headerlink" title="回收子进程资源"></a>回收子进程资源</h3><ol><li>父进程通过系统调用wait()或waitpid()来等待子进程结束，从而回收子进程的资源；</li><li>异步：子进程结束之后向父进程发送SIGCCHILD信号，基于此父进程注册一个SIGCHILD信号的处理函数进行子进程的资源回收。</li></ol><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，并且父进程没有对子进程残留的资源进行回收，就会产生僵尸进程。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程先于子进程退出，产生孤儿进程。虚拟机会将孤儿进程的父进程设置为1号进程即systemd进程，然后由systemd对孤儿进程的资源进行回收，而容器的1号进程为entrypoint启动进程，无法处理。</p><p><strong>如何避免？</strong></p><p>Kubernetes：可以将多个容器编排到一个pod里，共享同一个Linux NameSpace，本质是k8s实例化出一个pause镜像，其它容器加入这个镜像实例化出的NameSpace实现NameSpace共享。</p><p>pod中的1号进程变成了pause，其它容器的entrypoint变成了1号进程的子进程。</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用于容器化应用的<strong>容器化应用、自动化部署、扩缩容、管理。</strong></p><p><strong>核心功能</strong></p><ul><li>服务发现和负载均衡</li><li>自动装箱</li><li>自动修复</li><li>存储编排</li><li>应用自动发布与回滚</li><li>配置管理</li><li>批任务执行</li><li>弹性伸缩</li></ul><p><strong>核心概念</strong></p><ul><li><p>Pod</p><p>Kubernetes中的最小调度单元，一个Pod可以由多个容器组成，同一个Pod内容器之间没有进行隔离。容器和Pod间的关系，类似进程组和进程。</p></li><li><p>Deployment</p><p>启动多个应用实例时(启动多个相同的Pod)，Deployment可以理解为一组Pod的管理器。</p></li><li><p>Service</p><p>服务发现和负载均衡是通过Service来做的，Service可以关联一组Pod，Service对象创建成功之后会映射到一个域名和固定的IP，只需要访问这种情况就可以通过这个固定的IP就可以访问后端的Pod中运行的应用了。</p></li><li><p>Configmap</p><p>创建和管理不同环境的配置，将配置和应用解耦。</p></li><li><p>NameSpace</p><p>资源的逻辑空间，包括鉴权、资源管理等。Kubernetes中的每个资源，如Pod、Depolement、Service等都有一个NameSpace属主，不同NameSpace的资源不能跨NameSpace访问，NameSpace内的资源要求命令唯一性。</p></li></ul><h2 id="资源隔离：NameSpace"><a href="#资源隔离：NameSpace" class="headerlink" title="资源隔离：NameSpace"></a>资源隔离：NameSpace</h2><p>同一个namesace内的资源必须保证名字唯一，不同namespace内的资源可以名字相同。(资源：Pod、Deployment、Service等)</p><p>Kubernetes自动创建的3个NameSpace：</p><ol><li>default；</li><li>kube-system；</li><li>kube-public</li></ol><p><strong>为Namespace设置资源配额</strong></p><p>resource quota资源文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">quota</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">hard:</span></span><br><span class="line">      <span class="attr">configmaps:</span> <span class="string">"20"</span></span><br><span class="line">      <span class="attr">limits.cpu:</span> <span class="string">"4"</span></span><br><span class="line">      <span class="attr">limits.memory:</span> <span class="string">10Gi</span></span><br><span class="line">      <span class="attr">persistentvolumeclaims:</span> <span class="string">"10"</span></span><br><span class="line">      <span class="attr">pods:</span> <span class="string">"30"</span></span><br><span class="line">      <span class="attr">requests.storage:</span> <span class="string">10Ti</span></span><br><span class="line">      <span class="attr">secrets:</span> <span class="string">"60"</span></span><br><span class="line">      <span class="attr">services:</span> <span class="string">"40"</span></span><br><span class="line">      <span class="attr">services.loadbalancers:</span> <span class="string">"50</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kybectl apply -f resourcequota.yaml -n myNamespace</span><br></pre></td></tr></table></figure><p><strong>为Nmaespace设置资源限制</strong></p><p>为了避免单个容器或者pod用光node上的所有可用资源。</p><p>LimitRange资源对象</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">limit-mem-cpu-per-container</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">max:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"800m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"1Gi"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"100m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"99Mi"</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"700m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"900Mi"</span></span><br><span class="line">  <span class="attr">defaultRequest:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"110m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"111Mi"</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Container</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f limitrange.yaml -n myNamespace</span><br></pre></td></tr></table></figure><p><strong>查看pod的资源情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8s kubectl describe pods myapp-pod -n myNamespace</span><br></pre></td></tr></table></figure><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ol><li><p>解决task co-scheduling的问题</p><p>Pod中的容器被自动安排到集群中的同一个物理或虚拟机上，并可以一起进行调度。</p></li><li><p>管理</p></li><li><p>资源共享和通信</p><p>Pod 内的容器之间没有进行资源隔离，可以进行资源共享和通信。</p></li></ol><p><strong>Pod的生命周期</strong></p><ul><li>挂起(Pending)：Pod已被Kubernetes接受，但有一个或多个容器镜像尚未创建。(调度Pod的时间、通过网络下载镜像的时间)</li><li>运行中(Running)：该Pod已经绑定到了一个节点上，Pod中所有容器都已被创建，至少有一个容器正在运行或处于启动或重启状态。</li><li>成功(Succeeded)：Pod中的所有容器都被成功终止了，并且不会再重启。</li><li>失败(Failed)：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。</li><li>未知(Unknown)：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li></ul><p><strong>常用参数</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#表示 api 对象的版本（比如 Pod 就是一种 api 对象）</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#表明 api 对象类型，Pod 对应的 kind 是 Pod</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">#包含一些元信息，比如 name 、 labels 等</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">#定义了 Pod 的一些描述信息，重要信息都是在 spec 这里进行描述的，比如：</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment">#containers：Pod 中运行的容器的镜像列表，可以包含多个</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br></pre></td></tr></table></figure><ul><li><p>command</p></li><li><p><strong>affinity</strong></p><ul><li>nodeAffinity：描述了 Pod 和 Node 之间的调度关系，比如把 Pod 调度到含有指定的标签的 Node 节点上；<ul><li>requiredDuringSchedulingIgnoredDuringExecution：Pod必须部署到满足条件的节点上，如果没有满足条件的节点，就不停重试。</li><li>preferredDuringSchedulingIgnoredDuringExecution：优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署。</li></ul></li><li>podAffinity：描述了 Pod 之间的调度关系，比如将某两种 Pod 调度到指定的节点上；</li><li>podAntiAffinity：和 podAffinity 正好相反，这个叫反亲和，比如让某两种 Pod 不要调度到同一个节点。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;label-name&gt;</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;value&gt;</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo Hello Kubernetes! &amp;&amp; sleep 3600'</span><span class="string">]</span></span><br></pre></td></tr></table></figure></li><li><p>hostAliases</p></li><li><p>Init Container</p><p>Pod可以包含多个容器，需要某个或某几个容器优于其他容器启动。</p><ol><li>init container总是运行到完成；</li><li>每个init container运行完成，下一个容器才会运行，如果有多个init container，则按顺序启动；</li><li>如果init container运行失败，Kubernetes会不断重启Pod，直到init container成功为止，除非restartPolicy值为Never。</li></ol></li></ul><h2 id="配置管理ConfigMap和Secret"><a href="#配置管理ConfigMap和Secret" class="headerlink" title="配置管理ConfigMap和Secret"></a>配置管理ConfigMap和Secret</h2><ul><li>ConfigMap：普通配置存储；</li><li>Secret：密文存储，如数据库密码等。</li></ul><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>不同环境对应不同的配置，将镜像和配置分离。</p><p><strong>创建</strong></p><ol><li><p>通过目录</p></li><li><p>通过文件</p></li><li><p>通过环境变量文件</p></li><li><p>直接编写configmap</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">ui.properties:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">color.good=purple</span></span><br><span class="line">    <span class="string">color.bad=yellow</span></span><br><span class="line">    <span class="string">allow.textmode=true</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ui-config-file</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编写configmap对象的yaml文件</span></span><br><span class="line">kubectl apply -f .\ui.yaml</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用</strong></p><ol><li><p>环境变量</p></li><li><p>通过volume挂载</p></li></ol><p><strong>使用限制</strong></p><ol><li>ConfigMap是通过etcd存储的(实际上kubernetes中所有API对象都是存储在etcd中的)，etcd的value默认限制1M大小；</li><li>更新问题。环境变量：需要重启pod；volume挂载方式：10s左右更新。</li></ol><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret对象类型一般用于保存敏感信息，如密码、令牌和ssh key等。</p><p><strong>创建</strong></p><ol><li><p>kubectl命令行；</p></li><li><p>直接编写Secret</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MWYyZDFlMmU2N2Rm</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-password-1</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f .\db-user-pass.yaml</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用</strong></p><ol><li><p>环境变量</p></li><li><p>通过volume挂载</p></li></ol><h2 id="容器化守护进程DaemonSet"><a href="#容器化守护进程DaemonSet" class="headerlink" title="容器化守护进程DaemonSet"></a>容器化守护进程DaemonSet</h2><p>DaemonSet：控制Daemon Pod</p><p>Daemon Pod：</p><ul><li>这个Pod运行在Kubernetes集群中的每一个节点(Node)上；</li><li>每个节点只能运行一个Daemon Pod实例；</li><li>当有新的节点(Node)加入到Kubernetets集群时，Daemon Pod会自动被拉起；</li><li>当有旧节点被删除时，其上运行的Daemon Pod也被删除。</li></ul><p><strong>应用场景</strong></p><ul><li>存储守护进程，如glusted或者ceph；</li><li>日志收集进程，如fluentd或者filebeat；</li><li>监控守护进程，如Prometheus的node-exporter；</li></ul><p><strong>创建</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">fluentd</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl get pod</span><br><span class="line">NAME                READY   STATUS    RESTARTS      AGE</span><br><span class="line">fluentd-app-ts8p2   1/1     Running   1 (14m ago)   19h</span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl get daemonset</span><br><span class="line">NAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">fluentd-app   1         1         1       1            1           &lt;none&gt;          19h</span><br><span class="line"><span class="meta">#</span><span class="bash">DESIRED：期望运行的Pod实例的个数；CURRENT：当前运行的Pod实例的个数；READY：状态ready的Pod实例的个数</span></span><br></pre></td></tr></table></figure><p><strong>只在某些指定的节点上面运行Pod</strong></p><ol><li>指定.spec.template.spec.nodeSelector，DaemonSet将在能够与Node Selector匹配的节点上创建Pod；</li><li>指定.spec.template.spec.affinity，DaemonSet 将在能够与 nodeAffinity 匹配的节点上创建 Pod。</li></ol><ul><li><p>nodeSelector示例：</p><ol><li><p>给某个节点打上特定的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl label nodes docker-desktop daemonset-label=master</span><br><span class="line">node/docker-desktop labeled</span><br></pre></td></tr></table></figure></li><li><p>在 DaemonSet 的 yaml 文件中指定 nodeSelector</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">daemonset-label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>nodeAffinity示例</p><p>4种策略：</p><ul><li>requiredDuringSchedulingIgnoredDuringExecution：表示 Pod 必须部署到满足条件的节点上，如果没有满足条件的节点，就不停重试；</li><li>requiredDuringSchedulingRequiredDuringExecution：类似 requiredDuringSchedulingIgnoredDuringExecution ，不过如果节点标签发生了变化，不再满足pod指定的条件，则重新选择符合要求的节点；</li><li>preferredDuringSchedulingIgnoredDuringExecution：表示优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署；</li><li>preferredDuringSchedulingIgnoredDuringExecution：表示优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署。其中RequiredDuringExecution表示如果后面节点标签发生了变化，满足了条件，则重新调度到满足条件的节点。</li></ul></li></ul><p><strong>DaemonSet工作原理</strong></p><p>控制器会不断检查状态是不是预期的，如果不是预期的就会做一些处理。</p><p>DaemonSet Controller：遍历所有的Node，状态有如下情况：</p><ul><li>没有指定的Pod在运行，需要创建；</li><li>有指定的Pod在运行，可能有多个 需要将多余的Pod删除；</li><li>正好有一个指定的Pod在运行。</li></ul><h2 id="ReplicationController和ReplicaSet"><a href="#ReplicationController和ReplicaSet" class="headerlink" title="ReplicationController和ReplicaSet"></a>ReplicationController和ReplicaSet</h2><h3 id="RepicationController"><a href="#RepicationController" class="headerlink" title="RepicationController"></a>RepicationController</h3><p>RepicationController确保集群内任何时刻都有指定的Pod副本处于运行状态，监控管理集群内跨多个节点的多个Pod。</p><p><strong>工作原理</strong></p><p>ReplicationController会监听Kubernetes集群内运行的Pod个数，如果多于指定副本数，则删除多余的Pod；如果少于指定的副本数，则启动缺少的Pod。即使只需要一个Pod，也建议使用ReplicationController来创建Pod。</p><h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>下一代的Replication Controller，支持新的基于集合的选择器(Deployment，DaemonSet也支持)。</p><p><strong>动态伸缩</strong></p><ol><li><p>修改ReplicaSet中的.spec.replicas字段来实现运行的Pod的个数伸缩限制，更新完yaml文件后直接kubectl apply重新应用一下即可；</p></li><li><p>结合HorizontalPodAutoscaler(水平Pod缩放器)，HPA可以基于CPU利用率(或其它)自动伸缩replication controller、deployment和replica set中的Pod数量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span> <span class="comment">#hpa的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-scaler</span> <span class="comment">#hpa的名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment">#指定目标类型为ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">frontend</span> <span class="comment">#指定目标ReplicaSet为frontend</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">3</span> <span class="comment">#最少pod副本为3 </span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod副本为10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span> <span class="comment">#设定cpu百分比，超过50%就增加pod数量</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>类似ReplicaSet，更新和扩缩容操作上更加友好。</p><p><strong>创建</strong></p><p>Deployment 创建的过程会首先创建一个 ReplicaSet，然后由 ReplicaSet 间接创建Pod。Deployment 负责管理 ReplicaSet，ReplicaSet 负责管理 Pod。</p><p><strong>更新</strong></p><p>Deployment 的更新实际上就是两个 ReplicaSet(OldReplicatSets、NewReplicaSets) 通过StrategyType 做更新的过程。</p><p><strong>回滚</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看历史版本</span></span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\deployment&gt; kubectl rollout history deployment nginx-deployment</span><br><span class="line"><span class="meta">#</span><span class="bash">显示每个版本具体的行为</span></span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\deployment&gt; kubectl rollout history deployment nginx-deployment  --revision=2</span><br><span class="line"><span class="meta">#</span><span class="bash">回滚到上一次修改的版本</span></span><br><span class="line">kubectl rollout undo deployment nginx-deployment </span><br><span class="line"><span class="meta">  #</span><span class="bash">回滚到指定的某个版本</span></span><br><span class="line">kubectl rollout undo deployment nginx-deployment --to-revisoin=1</span><br></pre></td></tr></table></figure><p><strong>缩放Deployment</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">扩容</span></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas=7</span><br><span class="line"><span class="meta">#</span><span class="bash">缩容</span></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas=3</span><br><span class="line"><span class="meta">#</span><span class="bash">水平自动缩放 Pod，根据 cpu 使用率来进行自动缩放。</span></span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><h2 id="批处理：Job和CronJob"><a href="#批处理：Job和CronJob" class="headerlink" title="批处理：Job和CronJob"></a>批处理：Job和CronJob</h2><p>CronJob 是Job 的定时调度。</p><p>Pod 作为 Kubernetes 的基本调度单位，Job 的执行最后也是通过 Pod 来运行的。</p><p>通过Job去初始化环境，通过CronJob去定时清理集群中的某些资源。</p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>通过Job去初始化环境，通过CronJob去定时清理集群中的某些资源。</p><p><strong>创建</strong></p><p>通过 perl 计算 pi 的小数点后两千位数，并输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">["perl",</span> <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>并行度：</p><ul><li>非并行任务：只会启动一个Pod，Pod成功结束就表示Job正常完成了；</li><li>带有固定competion数目的并行任务：spec.completions 定义 Job 至少要完成的 Pod 数据，即 Job 的最小完成数；</li><li>具有工作队列的并行任务：通过参数 spec.parallelism 指定一个 Job 在任意时间最多可以启动运行的 Pod数。</li></ul><p><strong>清理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete jobs pi</span><br></pre></td></tr></table></figure><p>自动清理</p><p>TTL(Time To Live)：存活时间</p><p>在Job的spec中增加参数ttlSecondsAfterFinished(Job结束之后的存活时间)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>类似于Linux的Crontab，不过CronJob的周期性任务是相对于整个Kubernetes集群。</p><p><strong>创建</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cronjob-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">"*/2 * * * *"</span>  <span class="comment">#每隔 2 分钟输出当前时间和一串文本信息 “Hello from the Kubernetes cluster”</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><p><strong>清理</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete cronjob cronjob-demo</span><br></pre></td></tr></table></figure><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>ReplicaController、Deployment等都是Kubernetes中的控制器，控制循环，不断比较资源的状态是不是期望状态，如果不是期望状态，则执行一些动作，否则什么都不做。</p><p><strong>状态</strong></p><ul><li><p>当前状态</p><p>Kubernetes可以认为是一种server-agent架构，server可以是API Server等，agent是运行在每个Node上的kubelet。kubelet通过心跳汇报其所在节点上运行的容器状态和节点状态。</p></li><li><p>期望状态</p><p>Kubernetes中的所有API对象都会提交给API Server，然后保存到ETCD中。期望状态来源于YAML文件，也是存储在ETCD中。控制器不直接与ETCD交互，而是通过API Server来中转。ETCD提供watch机制。</p><ol><li>Deployment 控制器从 API Server 获取到所有带有特定标签的 Pod，并统计数目，这个就是实际状态；</li><li>Deployment 对象中的 Replica 字段的值是期望状态；</li><li>Deployment 控制器比较这两个状态，然后根据比较结果来决定是创建新的 Pod，还是删除已有的 Pod。</li></ol></li></ul><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>Deployment不能用来管理有状态的应用，它认为所有代理的后端的Pod是相同的。</p><p>有状态的应用：</p><ol><li>后端的多个Pod的角色是不同的，如Zookeeper有一个Leader节点，剩下都是Follower；</li><li>状态是存储和应用之间绑定的，如Hadoop中的HDFS会启动很多个DataNode，每个DataNode存储的数据是有区别的。</li></ol><p><strong>工作原理</strong></p><p>控制的Pod拥有唯一的标识，包括顺序标识、稳定的网络标识和稳定的存储，启动周标识就是固定的，重启之后也不会发生变化。</p><ul><li><p>顺序标识</p><p>对具有N个Pod副本的StatefulSet，StatefulSet会为每个Pod分配一个固定的名字，如&lt; statefulset-name&gt;-x，其中 x 介于 0 和 N-1 之间。正如我们上面看到的 Pod 的名称 web-0、web-1、web-2。</p></li><li><p>网络标识</p><p>Stateful通过Headless Service控制Pod的网络标识，网络标识的格式为<code>$(服务名称).$(命名空间).svc.cluster.local</code>，其中<code>cluster.local</code>是集群域。一旦Pod创建成功，就会得到一个匹配的DNS子域，格式为<code>$(pod名称).$(所属服务的 DNS 域名)</code>，其中所属服务由StatefulSet的spec中的serviceName域来设定。由于Pod的名称的固定，所以每个Pod对应的DNS子域也是固定的。</p></li><li><p>稳定存储</p><p>Kubernetes为每个VolumeClaimTemplate域创建一个PV。如果没有声明 StorageClass，就会使用默认的 StorageClass。当Pod被调度以及重新调度(比如Pod重启或Node节点挂掉)到节点上时，它的volumeMounts会挂载与其PersistentVolumeClaims相关联的PV。</p><p>当Pod或者StatefulSet被删除时，Pod之前使用的PV并不会自动删除，需要手动删除。</p></li></ul><p><strong>部署和扩缩容</strong></p><ul><li>对于包含 N 个 Pod 副本的 StatefulSet，当部署时，Pod 按 0，1，…，N-1 的顺序依次被创建的。</li><li>当删除 StatefulSet 时，Pod 按 N-1，…，1，0 的顺序被逆序终止的。</li><li>当缩放操作应用到某个 Pod 之前，它前面的所有 Pod 必须是 Running 和 Ready 状态，所谓前面的 Pod 的意<br>思是序号小于当前 Pod 的序号。</li><li>在 Pod 终止之前，所有序号大于该 Pod 的 Pod 都必须完全关闭。</li></ul><h2 id="使用Service访问一组特定的Pod"><a href="#使用Service访问一组特定的Pod" class="headerlink" title="使用Service访问一组特定的Pod"></a>使用Service访问一组特定的Pod</h2><p>Service可以理解为一种访问一组特定Pod的策略。</p><p>如Pod 运行了 3 个副本，并且是无状态的。前端访问该应用程序时，不需要关心实际是调用了那个 Pod 实例。通过Service解耦，Service 与后端的多个 Pod 进行关联（通过 selector），前端只需要访问Service 即可。</p><p><strong>创建</strong></p><p>对80端口的TCP请求转发到标签<code>app=nginx</code>的并且使用TCP端口80的Pod上</p><p>ClusterIP 类型的 Service 只能在集群内部进行访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>多端口Service</strong></p><p><strong>设置固定IP</strong></p><p>在 Service 的定义中通过参数 <code>spec.clusterIP</code> 指定自己的clusterIP。</p><p><strong>服务发现</strong></p><p>TODO</p><p><strong>Headless Service</strong></p><p>拥有ClusterIP的Service，会自动做负载均衡。</p><p>指定负载均衡策略：指定ClusterIP的值为None，此时创建出来的Service则为Headless Service。这个时候做服务发现时，这个Service返回的为后端的Pod列表。</p><h2 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h2><ul><li>ClusterIP：默认的 Service Type，通过集群的内部 IP 暴露服务，只能在集群内部进行访问；</li><li>NodePort：通过每个 Node 上面的某个端口 （NodePort）暴露服务。通过该端口的请求会自动路由到后端的ClusterIP 服务，这个 ClusterIP 服务是自动创建的。通过 NodePort，我们可以在集群外部访问我们的服务，但是，在生产环境上面并不建议使用 NodePort；</li><li>LoadBalancer：使用云厂商提供的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到<br>NodePort 和 ClusterIP 服务；</li><li>ExternalName：通过返回 CNAME 将服务映射到 externalName 字段中的内容；</li><li>Ingress：严格来说，Ingress 不是一种服务类型，而是用来充当集群的服务的入口点。Ingress 可以将路由规<br>则整合到一个资源中，然后通过同一个 IP 地址暴露多个服务。</li></ul><p><strong>NodePort</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">30001</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get service</span></span><br><span class="line">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class="line">nginx-service ClusterIP 10.0.213.149 &lt;none&gt; 80/TCP 7h26m</span><br><span class="line">nginx-service-nodeport NodePort 10.0.8.178 &lt;none&gt; 30001:31633/TCP 1s #前面表示 ClusterIP 对应的端口，也就是 30001；后面的表示 Node 本地对应的端口，是 31633。</span><br></pre></td></tr></table></figure><p>NodePort 类型的 Service 后端还是通过 ClusterIP 来实现。</p><p>Node本地对应的端口为一个区间随机生成的，默认为30000-32767，可以通过参数–service-node-port-range来指定。</p><p>指定NodePort：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">30001</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30002</span>  <span class="comment">#保证指定的值处于参数 --service-node-port-range 指定的区间内</span></span><br></pre></td></tr></table></figure><ul><li>NodePort：Node节点本地启动的用来监听和转发请求的端口，每个节点上都会启动；</li><li>Port：NodePort类型的Service自动创建的ClusterIP的端口；</li><li>TargetPort：ClusterIP转发的目标端口。</li></ul><p>所以对于NodePort类型的Service，外部的请求顺序是：<strong>NodePort -&gt; Port -&gt; TargetPort</strong></p><p><strong>Ingress</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.example.com</span>  <span class="comment">#host：服务暴露的域名；</span></span><br><span class="line">    <span class="attr">http:</span>  <span class="comment">#http：路由转发协议，可以是 http 或者 https</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span>  <span class="comment">#path：路由 router</span></span><br><span class="line">        <span class="attr">backend:</span> <span class="comment">#backend：后端服务，主要包括服务名称和服务端口</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Chroot&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;NameSpace&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cgroup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="云原生" scheme="https://imokkkk.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="Docker" scheme="https://imokkkk.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://imokkkk.github.io/tags/Kubernetes/"/>
    
      <category term="云原生" scheme="https://imokkkk.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://imokkkk.github.io/computernetwork/"/>
    <id>https://imokkkk.github.io/computernetwork/</id>
    <published>2021-06-15T14:42:33.436Z</published>
    <updated>2021-07-10T14:10:32.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-TCP-为什么握手是-3-次、挥手是-4-次？"><a href="#1-TCP-为什么握手是-3-次、挥手是-4-次？" class="headerlink" title="1.TCP 为什么握手是 3 次、挥手是 4 次？"></a>1.TCP 为什么握手是 3 次、挥手是 4 次？</h3><ul><li>如果一个Host主动向另一个Host发起连接，称为SYN，请求同步；</li><li>如果一个Host主动断开请求，称为FIN，请求完成；</li><li>如果一个Host给另一个Host发送数据，称为PSH，数据推送。</li></ul><a id="more"></a><img data-src="../assets/img/image-20210620162355901.png" alt="image-20210620162355901" style="zoom:67%;"><img data-src="../assets/img/image-20210620162420844.png" alt="image-20210620162420844" style="zoom:67%;"><p>TCP是一个双工协议，建立连接的时候，连接双方都需要向对方发送SYN和ACK。握手阶段没有繁琐的工作，因此一方向另一方发起同步(SYN)之后，另一方可以将自己的ACK和SYN打包作为一条消息回复，因此是3次握手。</p><p>挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应(ACK)，表示收到了挥手请求。最后等所有工作结束，再发送请求中断连接(FIN)，因此是4次挥手。</p><h3 id="2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"><a href="#2-TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？" class="headerlink" title="2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？"></a>2.TCP协议是如何恢复数据的顺序，TCP拆包和粘包的作用是什么？</h3><p>TCP拆包：将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程中需要保证数据经过网络传输，又能恢复到原始的顺序。TCP利用发送字节数(Sequence Number)和接收字节数(Acknowledgement Number)的唯一性来确定封包之间的顺序关系(无论是Seq还是ACK，都是针对对方而言的。是对方发送的数据和对方接受的数据)。粘包是为了防止数据量过小，导致大量的传输，而将多个TCP段合并成一个发送。</p><p><img data-src="../assets/img/image-20210620150902311.png" alt></p><h3 id="3-滑动窗口和流速控制"><a href="#3-滑动窗口和流速控制" class="headerlink" title="3.滑动窗口和流速控制"></a>3.滑动窗口和流速控制</h3><p>深绿色：已经收到了ACK的段    浅绿色：发送了，但是没有收到ACK的段    白色：没有发送的段    紫色：暂时不能发送的段。</p><ol><li><p>有两个封包到达，标记为绿色。</p><p><img data-src="../assets/img/image-20210620161423153.png" alt></p></li><li><p>滑动窗口可以向右滑动</p><p><img data-src="../assets/img/image-20210620161910667.png" alt></p></li></ol><p><strong>重传</strong></p><ol><li><p>如果部分数据没能收到ACK，如段4迟迟没有收到ACK。</p><p><img data-src="../assets/img/image-20210620162206747.png" alt></p></li><li><p>此时滑动窗口只能右移一个位置</p><p><img data-src="../assets/img/image-20210620162314291.png" alt></p><p>如果段4重传成功(接收到ACK)，那么窗口就会继续右移。如果段4发送失败，还是没能收到ACK，那么接收方也会抛弃段5、6、7。这样从段4开始之后的数据都需要重发。</p></li></ol><p><strong>快速重传</strong></p><p>例如段1、2、4到了，但是3没到。接收方可以发送多次3的ACK(不发段4的ACK)。如果发送方收到多个3的ACK，就会重发段3。这和超时重发不同，是一种催促机制，接收方希望催促发送方尽快补全某个TCP段。</p><p>实际操作中，每个TCP段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中滑动窗口的大小单位是字节数。</p><p><strong>总结</strong></p><p>滑动窗口是TCP协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出的顺序，但是窗口中的分组会一次性发送。窗口中序号最大的分组如果收到ACK，窗口就会发生滑动；如果有分组为收到ACK，则会滑动到该窗口。</p><p>在多次传输中，网络的平均延迟往往是相对固定的，这样TCP协议可以通过<strong>发送方和接收方协商窗口大小控制流速</strong>。</p><h3 id="4-TCP和UDP的区别"><a href="#4-TCP和UDP的区别" class="headerlink" title="4.TCP和UDP的区别"></a>4.TCP和UDP的区别</h3><p><strong>UDP</strong></p><p>UDP，目标是在传输层提供直接发送报文的能力。Datagram是数据传输的最小单位，UDP协议不会帮助拆分数据，它的目标只有一个，就是能发送报文。</p><p>UDP的可靠性仅仅就是通过Checksum保证。如果一个数据封包Datagram发生了数据损坏，UDP可以通过Checksum纠错或者修复。</p><p><strong>UDP与TCP的区别</strong></p><ol><li><p>目的差异</p><p>TCP：提供可靠的网络传输。</p><p>UDP：提供报文交换能力基础上尽可能的简化协议。</p></li><li><p>可靠性差异</p><p>TCP：可靠，收到的数据会进行排序。</p><p>UDP：不可靠，只管发送数据包。</p></li><li><p>连接vs无连接</p><p>TCP：面向连接，会有握手的过程，传输数据必须先建立连接。</p><p>UDP：无连接协议，数据随时都可以发送，只提供发送封包的能力。</p></li><li><p>流控技术</p><p>TCP在发送缓冲区中存储数据，并在接收缓冲区中接收数据，如果接收缓冲区已满，接收方无法处理更多数据，并将其丢弃。UDP没有提供类似的能力。</p></li><li><p>传输速度</p><p>UDP协议简化，封包小，没有连接、可靠性检查等，因此单纯从速度上讲，UDP更快。</p></li><li><p>理论上，任何一个用TCP协议构造的成熟应用层协议，都可以UDP重构。想要把网络优化到极致，就会用UDP作为底层技术，然后在UDP基础上解决可靠性。</p><p>TCP场景：</p><ul><li>远程控制(SSH)</li><li>File Transfer Protocol(FTP)</li><li>邮件(SMTP、IMAP等)</li><li>点对点文件传输(微信等)</li></ul><p>UDP场景</p><ul><li>网络游戏</li><li>音视频传输</li><li>DNS</li><li>ping</li><li>直播</li></ul><p>模糊地带</p><ul><li>HTTP(目前以TCP为主)</li><li>文件传输</li></ul></li></ol><p>TCP最核心的价值就是提供封装好的一套解决可靠性的优秀方案。UDP最核心的价值是灵活、轻量、传输速度快。场景不同选择不同。</p><h3 id="5-IPv4"><a href="#5-IPv4" class="headerlink" title="5.IPv4"></a>5.IPv4</h3><p>IP协议自身不能不能保证可靠性(数据无损的到达目的地)。</p><p>IP协议接收IP协议上方的Host-To-Host协议传来的数据，然后进行拆分，这个能力叫做分片。然后IP协议为每个片段增加一个IP头，组成一个IP封包。之后，IP协议调用底层的局域网(数据链路层)传送数据。最后IP协议通过寻址和路由最终将封包送达目的地。</p><p>延迟：指1bit数据从网络的一个终端传送到另一个终端需要的时间。<br>吞吐量：单位时间内可以传输的平均数据量。如bit/s(bps)。<br>丢包率：指发出去的封包没有到达目的地的比例。</p><p><strong>IPv4地址</strong><br>4个8喂排列而成，总共可以编址43亿个地址。<br>如103.16.3.1</p><p><img data-src="../assets/img/23223038.png" alt></p><p><strong>寻址与路由的区别</strong></p><p>寻址就是通过地址找设备，比如根据地址找到一个公寓。在 IPv4 协议中，寻址找到的是一个设备所在的位置。路由的本质是路径的选择，就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。</p><p>所以，要做路由，就必须理解地址，也就是借助寻址的能力。找到最终的设备又要借助路由在每个节点选择数据传输的线路。因此，路由和寻址相辅相成。</p><h3 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6.IPv6"></a>6.IPv6</h3><p><strong>相似点</strong></p><p>工作原理与IPv4类似，分成切片、增加封包头、路由(寻址)几个阶段。</p><p><strong>不同点</strong></p><ul><li><p>IPv6地址</p><p>IPv4的地址是4个8位，总共32位，如103.28.7.35，每一个是8位，用0-255的数字表示；IPv6的地址是8个16位，总共128位，如0123:4567:89ab:cdef:0123:4567:89ab:cdef，通常用16进制表示。</p></li><li><p>IPv6的寻址</p><ul><li><p>全局单播</p><p>将消息从一个设备传到另一个设备，和IPv4的发送/接收数据大同小异。IPv6地址太多，因此不需要子网掩码，而是直接将IPv6的地址分区即可。</p></li><li><p>本地单播</p><p>在局域网中，实现设备到设备的通信。本地单播必须以fe80开头，类似IPv4中以127开头。</p></li><li><p>分组多播</p><p>将消息发送给多个接收者。</p></li><li><p>任意播</p><p>将消息发送给多个接收方，并选择一条最优的路径。</p></li></ul></li></ul><p><strong>IPv6和IPv4的兼容</strong></p><ul><li><p>一个IPv6的客户端想访问IPv4的服务器</p><p><img data-src="../assets/img/gfgfdg225213.png" alt></p><ol><li>客户端通过DNS64服务器查询AAAA记录。(DNS64：一种解决IPv4和IPv6兼容问题的DNS服务，会把IPv4和IPv6地址同时返回)</li><li>DNS64服务器返回含IPv4地址的AAAA记录。</li><li>客户端将对应的IPv4地址请求发送给一个NAT64路由器。</li><li>NAT64路由器将IPv6地址转换为IPv4地址，从而访问IPv4网络，并收集结果。</li><li>消息返回客户端。</li></ol></li><li><p>两个IPv6网络被IPv4隔离</p><p><img data-src="../assets/img/iij225838.png" alt></p><p>隧道的本质就是在两个IPv6的网络出口网关处，实现一段地址转换的程序。</p></li></ul><p><strong>Tunnel是什么？</strong></p><p>Tunnel就是隧道，两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。隧道是两个网络间用程序定义的一种通道。具体来说，如果两个IPv6网络被IPv4分隔开，那么两个IPv6网络的出口处(和IPv4的网关处)就可以用程序(或硬件)实现一个隧道，方便两个网络中设备的通信。</p><h3 id="7-BIO、NIO和AIO有什么区别？"><a href="#7-BIO、NIO和AIO有什么区别？" class="headerlink" title="7.BIO、NIO和AIO有什么区别？"></a>7.BIO、NIO和AIO有什么区别？</h3><p>BIO接口设计会直接导致当前线程阻塞。NIO的设计不会触发当前线程的阻塞。AIO为I/O提供了异步的能力，也就是将I/o的响应程序放到一个独立的时间线上去执行。但是通常AIO的提供者还会提供异步编程模型，就是实现一种对异步计算封装的数据结构，并且将异步计算同步回主线的能力。</p><p>通常情况下，这3种API都会伴随I/O多路复用。如果底层用红黑树管理注册的文件描述符和事件，可以在很小的开销内由内核将I/O消息发送给指定的线程。另外，还可以使用DMA、内存映射等方式优化I/O。</p><h3 id="8-怎样实现RPC框架？"><a href="#8-怎样实现RPC框架？" class="headerlink" title="8.怎样实现RPC框架？"></a>8.怎样实现RPC框架？</h3><ol><li><p>调用约定和命名</p><p>远程调用一个函数，命名空间+类名+方法名    IP、端口</p></li><li><p>注册和发现</p><p>调用的时候，需要根据字符串(命名)去获取IP和端口(机器和服务)</p><ul><li><p>Redis hash</p><p>注册：上线一个服务时，用Redis的hash对象存储它和它对应的IP地址+端口列表。</p><p>发现：根据RPC服务的名称(命名空间+类名+方法名)查找到提供服务的IP + 端口清单并指定某个 IP + 端口(提供服务)</p><p>不足：所有RPC调用着都去Redis查询，压力较大，增加缓存，缓存和注册表之间数据不一致。</p></li><li><p>Zookeeper提供订阅，让RPC调用者订阅到服务地址的变更，及时更新自己的缓存。</p></li></ul></li><li><p>多路复用</p><p>提升吞吐量：1.顺序传输  2.切片传输。</p></li><li><p>负载均衡</p><p>负载均衡可以看作发现模块的一个子组件，请求到达RPC的网关(或某个路由程序)后，发现组件会提供服务对应的所有实例(IP+端口)，然后负载均衡算法会指定其中一个响应请求。</p></li><li><p>可用性和容灾</p><ul><li>当一个服务实例崩溃的时候，发现模块及时从注册表中删除这个服务实例。</li><li>注册表和RPC调用者之间存在不一致现象，而且注册表的更新本身也可能滞后。如确认一个服务有没有崩溃，可能需要一个心跳程序持续请求这个服务，调用到一个不存在或崩溃的服务，需要自己重新发现组件申请新的服务实例(地址+端口)。</li><li>临时访问量剧增，需要扩容的场景，上线更多的容器，并且去注册。</li></ul></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？"><a href="#1-一台内存8G左右的服务器，理论上可以同时维护多少个连接？" class="headerlink" title="1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？"></a>1.一台内存8G左右的服务器，理论上可以同时维护多少个连接？</h4><p>TCP连接上限受限于机器的内存，假设一个TCP连接需要占用的最小内存是8k(发送、接收缓存各4k，当然还要考虑socket描述符等)，那么最大连接数为：8 * 1024 * 1024 / 8 = 1048576个，即约为100w个TCP长连接。<br>但是如果单机建立太多的连接，会报<code>Cant assign requested address</code>的异常，这是因为客户端连接服务端时，操作系统要为每个客户端分配一个端口号，端口号会更快用尽。</p><h4 id="2-127-0-0-1，localhost，0-0-0-0-有什么不同？"><a href="#2-127-0-0-1，localhost，0-0-0-0-有什么不同？" class="headerlink" title="2.127.0.0.1，localhost，0.0.0.0 有什么不同？"></a>2.127.0.0.1，localhost，0.0.0.0 有什么不同？</h4><p>127.0.0.1：本地回环地址，发送到loopback上的数据会被转发到本地应用。</p><p>localhost：指代本地计算机，用于访问绑定在loopback上的服务。localhost是一个主机名，不仅可以指向IPv4的本地回环地址，也可以指向IPv6的本地回环地址[::1]。</p><p>0.0.0.0：一个特殊的目的IP地址，称作不可路由IP地址，它的用途会被特殊规定。通常情况下，当把一个服务绑定到0.0.0.0，相当于把服务绑定到任意的IP地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到0.0.0.0就可以保证服务在多个IP地址上都可以用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-TCP-为什么握手是-3-次、挥手是-4-次？&quot;&gt;&lt;a href=&quot;#1-TCP-为什么握手是-3-次、挥手是-4-次？&quot; class=&quot;headerlink&quot; title=&quot;1.TCP 为什么握手是 3 次、挥手是 4 次？&quot;&gt;&lt;/a&gt;1.TCP 为什么握手是 3 次、挥手是 4 次？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果一个Host主动向另一个Host发起连接，称为SYN，请求同步；&lt;/li&gt;
&lt;li&gt;如果一个Host主动断开请求，称为FIN，请求完成；&lt;/li&gt;
&lt;li&gt;如果一个Host给另一个Host发送数据，称为PSH，数据推送。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://imokkkk.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://imokkkk.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="https://imokkkk.github.io/tags/HTTP/"/>
    
      <category term="TCP" scheme="https://imokkkk.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="https://imokkkk.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://imokkkk.github.io/mysql/"/>
    <id>https://imokkkk.github.io/mysql/</id>
    <published>2021-06-06T08:06:55.156Z</published>
    <updated>2022-06-20T06:28:14.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1.基础篇"></a>1.基础篇</h3><h4 id="1-1-一条SQL查询语句是如何执行的？"><a href="#1-1-一条SQL查询语句是如何执行的？" class="headerlink" title="1.1 一条SQL查询语句是如何执行的？"></a>1.1 一条SQL查询语句是如何执行的？</h4><p><img data-src="../assets/img/0d2070e8f84c4801adbfa03bda1f98d9.png" alt></p><ul><li><p>Server层</p><p>连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。</p><a id="more"></a></li><li><p>存储引擎层</p><p>负责数据的存储和提取。支持InnoDB、MyISAM、Memory等多个存储引擎。MySQL5.5.5版本后默认使用InnoDB。</p></li></ul><ol><li><p>连接器</p><p>连接器负责与客户端建立连接、获取权限、维持和管理连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&#123;ip&#125; -P&#123;port&#125; -u&#123;user&#125; -p</span><br></pre></td></tr></table></figure><ul><li><p>一个用户成功建立连接后，即使使用管理员账户对该用户的权限做了修改，也不会影响已经存在的连接权限，只有新建的连接才会使用新的权限设置。</p></li><li><p>show processlist 可以查看各连接状态</p><p><img data-src="../assets/img/f2da4aa3a672d48ec05df97b9f992fed.png" alt></p><p>“Sleep”表示空闲连接，如果客户端太长时间没动静(wait_timeout，默认8小时)，连接器自动断开。</p></li><li><p>数据库长连接指连接成功后，客户端持续有请求，则一直使用同一个连接；短连接指每次执行完几次查询后就断开连接，下次查询再重新建立。MySQL在执行过程中临时使用的内存是管理在连接对象里的，如果长连接累积下来，会导致内存占用过大。</p><p>解决办法：</p><ul><li>定期断开长连接</li><li>MySQL5.7及以后，可以在每次执行一个比较大的操作后，执行mysql_reset_connection来将连接恢复到刚刚创建完的状态(不需要重连和权限验证)。</li></ul></li></ul></li><li><p>查询缓存</p><p>之前查询过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。但只要有对一个表的更新，那么这个表上的查询缓存就会被全部清除。MySQL8.0版本将查询缓存模块删除掉了。</p><ul><li><p>MySQL提供了”按需使用”的方式，将参数query_cache_type设置为DEMAND，这样对于默认的SQL不使用查询缓存。使用SQL_CACHE显式指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select SQL_CACHE * from T <span class="built_in">where</span> ID=10；</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>分析器</p><p>如果没有命中查询缓存，就要开真正开始执行语句。</p><ol><li><p>词法分析</p><p>把”select”关键字识别出来，把字符串”T”识别为”表名T”，把字符串”ID”识别为”列ID”。</p></li><li><p>语法分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> elect * from t <span class="built_in">where</span> ID=1;</span></span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1</span><br></pre></td></tr></table></figure></li></ol></li><li><p>优化器</p><p>在表里有多个索引的时候，决定使用哪个索引；或者一个语句有多表关联(join)的时候，决定各个表的连接顺序。</p></li><li><p>执行器</p><p>开始执行语句，先判断对这个表T是否有权限(如果命中查询缓存，会在查询缓存返回结果时做权限校验)。如果有权限，就开始执行语句。</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID是否为10，如果不是则跳过，如果是则将这行存在结果集。</li><li>调用引擎接口取”下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>将结果集返回给客户端。</li></ol><p>对于有索引的表，第一次调用的是”满足条件的第一行”这个接口，之后循环取”满足条件的下一行”接口。</p></li></ol><h4 id="1-2-日志系统：一条SQL更新语句是如何执行的"><a href="#1-2-日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="1.2 日志系统：一条SQL更新语句是如何执行的"></a>1.2 日志系统：一条SQL更新语句是如何执行的</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(ID int primary key, c int);</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span></span><br></pre></td></tr></table></figure><p><strong>重要的日志模块：redo log</strong></p><p>WAL(Write-Ahead Logging)：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB。从头开始写，写到末尾就又回到开头循环写。</p><p><img data-src="../assets/img/16a7950217b3f0f4ed02db5db59562a7.png" alt></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos和checkpoint之间空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，这时不能再执行新的更新，得擦掉一些记录，把checkpoint推进一下。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><p><strong>重要的日志模块：binlog</strong></p><p>MySQL整体看包括两块：一块是Server层，它主要做的是MySQL功能层面的事情；还一块是引擎层，负责存储相关的具体事宜。redo log是InnoDB(重做日志)引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)</p><p><strong>为什么会有两份日志？</strong></p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎MyIASM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是以插件形式引入MySQL的，使用另外一套日志系统-redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同：</p><ol><li>redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是”在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p><strong>InnoDB引擎内部执行流程</strong></p><ol><li>执行器先找引擎取ID=2这一行。(ID是主键，引擎直接用树搜索到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。)</li><li>执行器拿到引擎给的行数据，把这个值加1，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成commit状态，更新完成。</li></ol><p>浅色表示在InnoDB内部进行，深色表示在执行器中执行。</p><p><img data-src="../assets/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt></p><h4 id="1-3-事务隔离"><a href="#1-3-事务隔离" class="headerlink" title="1.3 事务隔离"></a>1.3 事务隔离</h4><p>事务：保证一组数据库操作，要么全部成功，要么全部失败。</p><p>ACID(原子性、一致性、隔离性、持久性)</p><p>当数据库上有多个事务同时执行的时候，可能会出现脏读、不可重复读、幻读的问题。SQL标准的事务隔离级别包括：</p><ul><li>读未提交：一个事务还没提交，它做的变更就能被其他事务看到。</li><li>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化：对于同一行记录，”写”会加”写锁”，”读”会加”读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p><img data-src="../assets/img/7dea45932a6b722eb069d2264d0066f8.png" alt></p><ul><li>读未提交：V1 = 2，V2、V3 = 2</li><li>读提交：V1 = 1，V2 = 2，V3 = 2</li><li>可重复读：V1、V2 = 1，V3 = 2；之所以V2还是1，是因为：事务在执行期间看到的数据前后必须一致</li><li>串行化：在事务B执行”将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以V1、V2 = 1，V3 = 2</li></ul><p><strong>事务隔离的实现</strong></p><p>数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。”可重复读”，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图；”读提交”，这个视图是在每个SQL语句开始执行的时候创建的。”读未提交”，直接返回记录上的最新值，没有视图概念；”串行化”，直接用加锁的方式来避免并发访问。</p><p>MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，都可以得到前一个状态。当系统里没有比这个回滚日志更早的read-view的时候，回滚日志会被删除。</p><p>长事务意味着系统里会存在很老的事务视图，这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会导致占用大量存储空间。</p><p><strong>事务的启动方式</strong></p><ol><li>显式启动事务语句，begin或start transaction。配套的语句是commit或者rollback。</li><li>set autocommit = 0，将这个线程的自动提交关掉。意味着如果执行一个select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到主动执行commit或者rollback，或者断开连接。</li></ol><h4 id="1-4-索引"><a href="#1-4-索引" class="headerlink" title="1.4 索引"></a>1.4 索引</h4><p><strong>索引的常见模型</strong></p><ul><li><p>哈希表</p><p>以键-值(key-value)存储数据的结构。多个key经过哈希函数换算，会出现同一个值的情况，此时会拉出一个链表。因为不是有序的，所以哈希索引做区间查询的速度很慢。适用于只有等值查询的场景。</p></li><li><p>有序数组</p><p>支持范围查询，但在插入数据和删除数据时必须挪动后面所有的记录，成本太高。适用于静态存储查询，这类不会再修改的数据。</p></li><li><p>二叉搜索树</p><p><img data-src="../assets/img/04fb9d24065635a6a637c25ba9ddde68.webp" alt></p><p>二叉搜索树的特点：父节点左子树所有节点小于父节点的值，右子树所有的节点大于父节点的值。</p><p>多叉树就是每个节点有多个儿子，儿子的大小保证从左到右递增。索引不止在内存中，还要写到磁盘上。为了尽可能少的读磁盘，就必须让查询过程访问尽量少的数据块。”N叉树”的”N”取决于数据块的大小。</p></li></ul><p><strong>InnoDB的索引模型</strong></p><p>每一个索引在InnoDB中对应一棵B+树。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(</span></span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><p><img data-src="../assets/img/dcda101051f28502bd5c4402b292e38d.webp" alt></p><p>索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也称为聚簇索引。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>select * from T where ID = 500 即主键查询方式，则只需要搜索ID这棵B+树</li><li>select * from T where k = 5 即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次，这个过程称为回表。</li></ul><p><strong>索引维护</strong></p><p>B+树为了维护索引有序性，在插入新值时需要做必要的维护。以上图为例，如果插入新的行ID值为700，则只需要在R5后面插入一个新记录。如果新插入的ID为400，需要逻辑上挪动后面的数据，空出位置。如果R5所在的数据页已满，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为页分裂，性能会下降。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p><p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。</p><p>自增主键：NOT NULL PRIMARY KEY AUTO_INCREMENT。每次插入一条新纪录，都是追加操作，都不涉及挪动记录，也不会触发叶子节点的分裂。</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约２０个字节，而如果用整形做主键，则只需要４个字节。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p><strong>覆盖索引</strong></p><p><img data-src="../assets/img/ds224929.png" alt></p><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。</p><p><strong>最左前缀原则</strong></p><p><img data-src="../assets/img/rrr225205.png" alt></p><p>索引项是按照索引定义里面出现的字段顺序排序的。当查询所有名字是”张三”的人时，可以快速定位到ID4，然后向后遍历。</p><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>如果通过调整顺序，可以少维护一个索引，那么往往优先考虑这个顺序。</p><p><strong>索引下推</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张 %'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>MySQL5.6之前，只能从ID3开始一个个回表，到主键索引上找出数据行，再对比字段值。</p><p>MySQL5.6之后引入索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的数据，减少回表次数。</p><p>无索引下推：回表4次</p><p><img data-src="../assets/img/625230314.png" alt></p><p>有索引下推：在(name，age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过，只需回表2次。</p><p><img data-src="../assets/img/156230553.png" alt></p><h4 id="1-5-全局锁和表锁"><a href="#1-5-全局锁和表锁" class="headerlink" title="1.5 全局锁和表锁"></a>1.5 全局锁和表锁</h4><p>数据库锁设计的初衷是处理并发问题。</p><p><strong>全局锁</strong></p><p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局锁的方法，命令是Flush tables with read lock(FTWRL)。当需要让整个库处于只读状态(不止DML，还包括DDL)时，可以使用该命令。使用场景是，<strong>全库逻辑备份</strong>的时候。</p><p>InnoDB引擎的库推荐使用一致性读(single-transcation)参数，对应用会更友好，全局锁一般在数据库引擎不支持事务时使用。</p><p>为什么不使用set global readonly=true？</p><ol><li>readonly的值会被用作其他逻辑，如判断主库备库。</li><li>异常处理机制有差别，执行FTWRL后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。readonly，如果客户端发生异常，则数据库就会一直保持readonly状态。</li></ol><p><strong>表级锁</strong></p><p>MySQL里面的表级别锁有两种：一种是表锁，一种是元数据锁(meta data lock，MDL)</p><ul><li><p>表锁</p><p>表锁的语法是lock tables..read/write。与FTWRL类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables不仅会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>某个线程A执行lock tables t1 read，t2 write；则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作，连写t1都不允许，自然也不能访问其他表。</p></li><li><p>元数据锁DML</p><p>不需要显示的使用，在访问一个表的时候会被自动加上，保证读写的正确性。</p><p>给一个表加字段，或者修改字段，或者加索引。需要扫描全表的数据。</p><p><strong>如何安全地给小表加字段？</strong></p><p>首先解决长事务的问题，事务不提交，就会一直占着MDL锁。在alter table语句里面设定等待时间，如果在这个指定的等待时间内未拿到MDL锁，则会放弃，不阻塞后面的业务。之后再通过重试命令重复这个过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-6-行锁"><a href="#1-6-行锁" class="headerlink" title="1.6 行锁"></a>1.6 行锁</h4><p>并不是所有的引擎都支持行锁，如MyISAM不支持行锁。行锁就是针对数据表中行记录的锁，比如事务A更新了一行，而这时事务B也要更新一行，则必须等事务A的操作完成后才能进行更新。</p><p><strong>两阶段锁</strong></p><p><img data-src="../assets/img/34234225501.png" alt></p><p>事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行。</p><p><strong>在InnoDB事务中，行锁并不是不需要了就立刻释放，而是要等待事务结束时才能释放。</strong></p><p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p><strong>死锁和死锁检测</strong></p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源的时候，就会导致这几个线程都进入无限等待的状态，称为死锁。</p><p><img data-src="../assets/img/323230138.png" alt></p><ol><li>直接进入等待，直到超时。超时时间参数：innodb_lock_wait_timeout，默认50s</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其它事务得以继续执行。innodb_deadlock_detect：on，默认开启。</li></ol><p>正常情况下使用第二种策略，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，但如果遇到所有事务更新同一行的场景，每个新来的线程都需要判断会不会由于自己加入导致了死锁，会消耗大量的CPU资源。</p><p>如何解决热点行更新导致的性能问题？</p><ol><li>在确保该业务不会出现死锁的情况下，临时取消死锁检测。</li><li>控制并发度。(中间件、在MySQL里进入引擎之前排队)</li><li>将一行改成逻辑上的多行来减少锁冲突，如账户总额等于10个记录值的总和。</li></ol><h4 id="1-7-事务到底是隔离的还是不隔离的？"><a href="#1-7-事务到底是隔离的还是不隔离的？" class="headerlink" title="1.7 事务到底是隔离的还是不隔离的？"></a>1.7 事务到底是隔离的还是不隔离的？</h4><p>当前读：更新数据都是先读后写的，而这个读，只能读当前的值。</p><p>事务的可重复读的能力是怎么实现的？<br>可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读，如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>InnoDB的行数有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。<br>对于可重复读：查询只承认在事务启动前就已经提交完成的数据；<br>对于读提交：查询只承认在语句启动前就已经提交完成的数据；</p><p>为什么表结构不支持”可重复读”?<br>因为表结构没有对应的行数据，也没有row trx_id，因此只能遵循当前读的逻辑</p><h3 id="2-实践篇"><a href="#2-实践篇" class="headerlink" title="2.实践篇"></a>2.实践篇</h3><h4 id="2-1-普通索引和唯一索引该如何选择？"><a href="#2-1-普通索引和唯一索引该如何选择？" class="headerlink" title="2.1 普通索引和唯一索引该如何选择？"></a>2.1 普通索引和唯一索引该如何选择？</h4><p><img data-src="../assets/img/css224736.png" alt></p><p><strong>查询</strong></p><p>select id from T where k=5</p><ul><li>普通索引：查找到满足条件的第一个记录(5，500)后，需要查找下一个记录，直到碰到第一个不满足k=5的记录。</li><li>唯一索引：查找到第一个满足条件的记录后，就会停止检索。</li></ul><p>两者的性能差距：InnoDB的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录从磁盘读出来，而是以页为单位，将其整体读入内存，InnoDB中，每个数据页的大小默认是16KB。对于整形字段，一个数据页可以放近千个key，所以k=5这个记录刚好是数据页最后一个记录的几率会很低。</p><p><strong>更新过程</strong></p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在chang buffer中，在下次查询需要访问这个数据页的时候将数据页读入内存，然后执行change buffer中与这个页有关的参数。</p><p>虽然名字叫做change buffer，实际上它是可以持久化的数据，change buffer在内存中有拷贝，也会被写入磁盘中。</p><p>将change buffer中操作应用到原数据页，得到最新结果的过程称为merge。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭(shutdown)的过程中，也会执行merge操作。</p><p>对于唯一索引，比如插入(4,400)这个记录，需要先判断表中是否存在k=4的记录，而这必须要将数据页读入到内存才能判断。如果已经读入内存了，直接更新内存即可，没必要再使用change buffer。因此，唯一索引的更新不能使用change buffer。</p><p>innodb_change_buffer_max_size: 50    表示change buffer的大小最多只能占用buffer pool的50%。</p><p>插入(4,400)：</p><ul><li>更新的目标页在内存中<ul><li>唯一索引：找到3和5之间的位置，判断没有冲突，插入值。</li><li>普通索引：找到3和5之间的位置，插入值。</li></ul></li><li>更新的目标页不在内存中<ul><li>唯一索引：将数据页读入内存，判断没有冲突，插入值。</li><li>普通索引：将更新记录在change buffer。</li></ul></li></ul><p><strong>change buffer的使用场景</strong><br>因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多，收益越大。即适合于<strong>写多读少</strong>的场景。</p><p><strong>change buffer和redo log</strong><br>insert into t(id,k) values (id1,k1)(id2,k2);<br>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB<br>buffer pool) 中，k2 所在的数据页不在内存中。</p><ol><li>Page1在内存中，直接更新内存。</li><li>Page2不在内存中，将更新记录在change buffer。</li><li>将上述两个动作记录在redo log。</li></ol><p>select * from t where k in (k1, k2)</p><ol><li>读Page1时，直接从内存返回。</li><li>读Page2时，需要把Page2从磁盘读入内存，然后应用change buffer里的操作记录，生成一个正确的版本并返回结果。</li></ol><p>redo log主要节省的是随机写磁盘的IO消耗(转为顺序写)，而change buffer主要节省的是随机读磁盘的IO消耗。</p><h4 id="2-2-MySQL为什么有的时候会选错索引？"><a href="#2-2-MySQL为什么有的时候会选错索引？" class="headerlink" title="2.2 MySQL为什么有的时候会选错索引？"></a>2.2 MySQL为什么有的时候会选错索引？</h4><p><strong>优化器的逻辑</strong></p><p>扫描行数、是否使用临时表、是否排序等因素。</p><p>一个索引上不同的值越多(基数)，这个索引的区分度就越好。</p><p><strong>MySQL是怎样得到索引的基数的？</strong></p><p>采样统计：InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到这个索引的基数。而数据表是会持续更新的，索引统计信息也需要同步改变。所以，当变更的数据行超过1/M的时候，会自动触发重新做一次索引统计。</p><p>innodb_stats_persistent:<br>on：统计信息会持久存储，默认N是20，M是10。<br>off：统计信息只存储在内存中，默认N是8，M是16。</p><p>analyze table t：重新统计索引信息</p><p><strong>索引选择异常和处理</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b betwwen <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li><p>采用force index强行选择一个索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span> <span class="keyword">and</span> b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>修改语句，引导MySQL使用期望的索引</p><p>“order by b limit 1”改成”order by b,a limit 1”，语义逻辑相同。之前优化器选择索引b，因为它认为使用索引b可以避免排序(b本身就是索引，不需要再次进行排序，只需要遍历)，所以即使扫描行数多，也判定为代价更小。”order by b,a”，意味着使用这两个索引都需要排序，因此，扫描行数成了影响索引选择的主要条件，于是，此时优化器选择了只需要扫描1000行的索引a。</p><p>但这种优化方法并不通用。</p></li><li><p>新建一个更合适的索引，来提供给优化器做选择，或者删除掉误用的索引</p></li></ol><h4 id="2-3-怎么给字符串字段加索引？"><a href="#2-3-怎么给字符串字段加索引？" class="headerlink" title="2.3 怎么给字符串字段加索引？"></a>2.3 怎么给字符串字段加索引？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index1(email);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/fdfd222522.png" alt></p><p><img data-src="../assets/img/hgh222605.png" alt></p><p>由于email(6)这个索引结构中每个邮箱字段都只取前6个字节，所以<strong>占用的空间会更小，但可能会增加额外的记录扫描次数。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,emial <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span></span><br></pre></td></tr></table></figure><ul><li><p>如果使用的是index1(即email整个字符串的索引结构)</p><ol><li>从index1索引树找到满足索引值是‘zhangssxyz@xxx.com’的这条记录，取得ID2的值。</li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这条记录加入结果集。</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’zhangssxyz@xxx.com’的条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p></li><li><p>如果使用的是index2(即emai(6)索引结构)</p><ol><li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li><li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’<span class="exturl" data-url="bWFpbHRvOnpoYW5nc3N4eXpAeHh4LmNvbQ==">zhangssxyz@xxx.com<i class="fa fa-external-link-alt"></i></span>’，这行记录丢弃；</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li></ol><p>在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</p></li></ul><p><strong>使用前缀索引，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。</strong></p><p><strong>怎么确定该使用多长的前缀呢？</strong></p><p>区分度越高越好，意味着重复的键值越少。因此可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure><p>依次选取不同长度的前缀的值，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">4</span>)) <span class="keyword">as</span> L4,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">5</span>)) <span class="keyword">as</span> L5,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">6</span>)) <span class="keyword">as</span> L6,<span class="keyword">count</span>(ditstinct <span class="keyword">left</span>(emial,<span class="number">7</span>)) <span class="keyword">as</span> L7 <span class="keyword">from</span> SUser</span><br></pre></td></tr></table></figure><p>使用前缀索引很可能损失区分度，所以需要预先设定一个可以接收的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7都满足，你就可以选择前缀长度为 6。</p><p><strong>前缀索引对覆盖索引的影响</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure><p>与前面例子中的SQL语句相比，这个语句只要求返回id和email字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span>,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com’;</span></span><br></pre></td></tr></table></figure><p>如果使用index1(即email整个字符串的索引结构)的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回表；而如果使用index2(即email(6)索引结构)的话，就不得不回到ID索引再去判断email的值。</p><p>即使将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p><strong>其他方式</strong></p><ol><li><p>使用倒序存储</p><p>如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用hash字段</p><p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc)</span><br></pre></td></tr></table></figure><p>每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能会冲突，所以查询语句where部分要判断id_card的值是否精确相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc=<span class="keyword">crc32</span>(<span class="string">'input_id_card_string'</span>) <span class="keyword">and</span> id_card=<span class="string">'input_id_card_string'</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>使用倒序存储和使用 hash 字段的异同点</strong></p><ol><li>倒叙存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。</li><li>倒序方式每次写和读的时候，都需要额外调一次reverse函数，而hash字段需要额外调一次crc32()函数，单纯从计算复杂度来看，reverse函数额外消耗的CPU资源会更小。</li><li>hash字段方式的查询性能相对更加稳定，因为crc32()算出来的值虽然有冲突的概率，但概率非常小，可以认为每次查询平均扫描行数接近1，而倒序存储方式毕竟还是前缀索引的方式，即还是会增加扫描行数。</li></ol><h4 id="2-4-为啥SQL语句偶尔会变”慢”？"><a href="#2-4-为啥SQL语句偶尔会变”慢”？" class="headerlink" title="2.4 为啥SQL语句偶尔会变”慢”？"></a>2.4 为啥SQL语句偶尔会变”慢”？</h4><p>InnoDB在处理更新语句的时候，只做了写日志这一个磁盘操作(redo log)，在更新内存写完redo log后，就返回给客户端，本次更新成功。</p><p>flush：把内存中的数据写入磁盘的过程</p><p>当内存数据页跟磁盘数据页内容不一致的时候，称这个内存为”脏页”。内存数据写入到磁盘后，内存就和磁盘上的数据页上的数据页的内容就一致了，称为”干净页”。</p><p><img data-src="../assets/img/fdff151353.png" alt></p><p>平时执行很快的操作：写内存和日志<br>偶尔”抖”一下：刷脏页(flush)</p><p><strong>什么情况下会引发数据库的flush操作?</strong></p><ol><li><p>InnoDB的redo log写满了。这时系统会停止所有更新操作，把checkpont往前推进，redo log留出空间可以继续写。</p><p><img data-src="../assets/img/111152005.png" alt></p><p>把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志，对应的所有脏页都flush到磁盘上。</p></li><li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，淘汰一些数据页，空出内存。如果淘汰的是”脏页”，就需要先将脏页写到磁盘。</p></li><li><p>MySQL认为系统”空闲”的时候就刷一点”脏页”。</p></li><li><p>MySQL正常关闭的时候，会把内存的脏页都flush到磁盘上，这样MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</p></li></ol><p><strong>对性能的影响</strong></p><ol><li><p>“redo log 写满了，要 flush 脏页”，这种情况，所有的更新都被堵塞，需要避免。</p></li><li><p>“内存不够用了，要先将脏页写到磁盘”，InnoDB使用缓冲池管理内存，缓冲池中的内存页有3种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页。</p><p>当要读入的数据页没有在内存中的时候，就必须到缓冲池申请一个数据页。这时需要把最久不使用的数据页从内存中淘汰掉。如果淘汰的是一个干净页，就直接释放出来复用；如果是脏页，就必须先刷到磁盘，变成干净页后才能复用。</p><ul><li>一个查询要淘汰的脏页个数太多。</li><li>日志写满，更新全部堵住。</li></ul></li></ol><p><strong>InnoDB刷脏页的控制策略</strong></p><p>参考因素：脏页比例，redo log写盘速度。</p><p>innodb_max_dirty_pages_pct：脏页比例上限，默认75%  F1(M)</p><p>InnoDB每次写日志都有一个序号，当前写入的序号跟checkpoint对应的序号之间的差值，假设为F2(N)(N越大，算出来的值越大)。</p><p>F1(M)和F2(N)的最大值为R，接下来引擎就可以按照innodb_io_capacity定义的能力乘以R%来控制刷脏页的数据。</p><p><img data-src="../assets/img/121154612.png" alt></p><p>合理设置innodb_io_capacity，多关注脏页比例，不要让它接近75%。</p><p>innodb_flush_neighbors，值为1时，对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷(机械硬盘时代，减少随机IO)。值为0时，只刷自己的，MySQL8.0之后，默认为0。</p><h4 id="2-5-为什么表数据删掉一半，表文件大小不变？"><a href="#2-5-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="2.5 为什么表数据删掉一半，表文件大小不变？"></a>2.5 为什么表数据删掉一半，表文件大小不变？</h4><p><strong>参数innodb_file_per_table</strong></p><p>innodb_file_per_table：MySQL5.6.6版本后默认为ON</p><ul><li>OFF：表的数据放在系统共享表空间，也就是跟数据字典放在一起。</li><li>ON：每个InnoDB表数据存储在一个.ibd为后缀的文件中。</li></ul><p>推荐设置为ON，一个表单独存储为一个文件更容易管理，不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。如果放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p><strong>数据删除流程</strong></p><p><img data-src="../assets/img/jhj195615.png" alt><br>假设，我们需要删除掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>InnoDB的数据是按页存储的，如果删除一个数据页上的所有记录，整个数据页就可以被复用了，但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据。而当整个页从B+树里面摘掉以后，可以复用到任何位置。<br>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。</p><p>如果用delete命令删除整个表的数据，所有的数据页都会被标记为可复用。但磁盘上，文件大小不变。</p><p>不止是删除数据会造成空洞，插入数据也会。</p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p><p><img data-src="../assets/img/1212201259.png" alt></p><p>由于page A满了，申请一个新的页面page B来保存数据。页面分裂完成后，page A的末尾就留下了空洞。</p><p><strong>重建表</strong></p><p>新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行行地从表A里读出来再插入到表B中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert table A engine=InnoDB</span><br></pre></td></tr></table></figure><p>MySQL5.6版本开始引入Online DDL(往临时表插入数据的过程中，表A中不能有更新)。</p><p><img data-src="../assets/img/dsd203817.png" alt></p><ol><li>建立一个临时文件，扫描表A主键的所有数据页。</li><li>用数据页中表A的记录生成B+树，存储到临时文件。</li><li>生成临时文件的过程中，将所有对A的操作记录在一个日志文件(row log)中，对应图中state2的状态。</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据与表A相同的数据文件，对应图中state3的状态。</li><li>用临时文件替换表A的数据文件。</li></ol><h4 id="2-6-count-的实现方式"><a href="#2-6-count-的实现方式" class="headerlink" title="2.6 count(*)的实现方式"></a>2.6 count(*)的实现方式</h4><p>MyISAM引擎把一个表的总行数存在了磁盘上，count(*)会直接返回这个数(不含where条件)。</p><p>InnoDB引擎需要把数据一行一行的从引擎里面读出来，然后累计计数。</p><p><strong>为什么InnoDB不像MyISAM一样把数字存放起来？</strong></p><p>和InnoDB的事务设计有关，可重复读是它的默认的隔离级别，通过多版本并发控制(MVCC)实现。每一行记录都要判断自己是否对这个会话可见，因此count(*)，InnoDB只好把数据一行一行的读出依次判断。</p><ul><li>MyISAM表虽然count(*)很快，但不支持事务；</li><li>show table status 命令虽然返回很快，但是不准确；</li><li>InnoDB直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><p><strong>不同的count用法</strong></p><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p><p>原则：</p><ol><li>server原则要什么就什么；</li><li>InnoDB只给必要的值；</li><li>现在的优化器只优化了count(*)的语义取行数。</li></ol><ul><li><p>count(主键id)</p><p>InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空后，按行累加。</p></li><li><p>count(1)</p><p>InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字”1”进去，判断是不可能为空的，按行累加。</p><p>count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p></li><li><p>count(字段)</p><ol><li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li><li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li></ol></li><li><p>count(*)</p><p>不取值。count(*) 肯定不是 null，按行累加。</p></li></ul><p>效率：count(字段)&lt;count(主键id)&lt;count(1)≈count(*)</p><h4 id="2-7-“order-by”是如何工作的？"><a href="#2-7-“order-by”是如何工作的？" class="headerlink" title="2.7 “order by”是如何工作的？"></a>2.7 “order by”是如何工作的？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p> <strong>全字段排序</strong><img data-src="../assets/img/image-20210714220341145.png" alt></p><p>Extra：”Using filesort”表示需要排序，MySQL会给每个线程分配一块内存用于排序，称为sort_buffer。</p><p><img data-src="../assets/img/220736.png" alt></p><ol><li>初始化sort_buffer，确定放入name、city、age三个字段；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name快速排序；</li><li>按照排序结果取前1000行返回给客户端。</li></ol><p>sort_buffer_size：MySQl为排序开辟的内存的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成，否则利用磁盘临时文件辅助排序(外部排序。</p><p>外部排序一般使用归并算法，即将要排序的数据分成12份，每一份单独排序后，将这12个有序文件再合并成一个有序的大文件。如果sort_buffer_size超过了需要排序的数据量的大小，number_of_tmp_files就是0，sort_buffer_size越小，需要分成的份数越多，number_of_tmp_files的值就越大。</p><p>只对原表的数据读了一遍，剩下的操作都是在sort_buffer或临时文件中执行，但如果要查询返回的字段特别多，则需要分成很多临时文件，排序性能很差。</p><p><strong>rowid排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> max_length_for_sort_data = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>如果单行的长度超过这个值，MySQL就认为单行太大，需要换个算法(city、name、age这3个字段的定义总长度36)。新的算法放入sort_buffer的字段，只要排序的列(即name字段)和主键id。</p><ol><li>初始化sort_buffer，确定放入两个字段，即name和id；</li><li>从索引city找到第一个满足city=’杭州’条件的主键id，即图中的ID_X；</li><li>到主键id索引取出整行，取name、id字段，存入sort_buffer中；</li><li>从索引city取下一个记录的主键id；</li><li>重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；</li><li>对sort_buffer中的数据按照字段name快速排序；</li><li>遍历排序结果，取前1000行，并按照id的值回到原表取出city、name和age三个字段返回给客户端。</li></ol><p>rowid多访问了一次表t的主键索引，即步骤7。</p><p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>MySQL之所以要生成临时表并且在临时表上做排序操作，是因为原来的数据都是无序的。</p><p><strong>联合索引</strong></p><p>如在这张表上创建一个city和name的联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city,<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/ds50223.png" alt></p><ol><li>从索引(city,name)找到第一个满足city=’杭州’条件的主键id；</li><li>到主键id索引取出整行，取name、city、age三个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name)取下一个记录主键id；</li><li>重复步骤2、3，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li></ol><p><strong>覆盖索引</strong></p><p>覆盖索引上的信息足够满足查询请求，不需要再回到主键索引上取数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city,<span class="keyword">name</span>,age)</span><br></pre></td></tr></table></figure><ol><li>从索引(city,name,age)找到第一个满足city=’杭州’条件的记录，取出其中的city、name和age这3个字段的值，作为结果集的一部分直接返回；</li><li>从索引(city,name,age)取下一个记录，同样取出这3个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤2，直到查到第1000条记录，或者是不满足city=’杭州’时循环结束。</li></ol><h4 id="2-8-为什么这些SQL语句逻辑相同，但性能差异巨大"><a href="#2-8-为什么这些SQL语句逻辑相同，但性能差异巨大" class="headerlink" title="2.8 为什么这些SQL语句逻辑相同，但性能差异巨大"></a>2.8 为什么这些SQL语句逻辑相同，但性能差异巨大</h4><ol><li><p><strong>条件字段函数操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tradelog`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`operator`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`t_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`t_modified`</span> (<span class="string">`t_modified`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>查询所有年份中7月份的交易记录总数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>下面是t_modified索引的示意图，方框上面的数字就是month()函数对应的值。<img data-src="../assets/img/dd223828.png" alt></p><p>B+树的快速定位能力来源于同一层兄弟节点的有序性，<strong>对索引字段做函数操作，可能会破环索引值的有序性，因此优化器决定放弃走树搜索功能，导致全索引扫描(并不是放弃这个索引)。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span>(t_modified &gt;=<span class="string">'2016-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2016-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2017-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2017-7-1'</span>) <span class="keyword">or</span> (t_modified &gt;=<span class="string">'2018-7-1'</span> <span class="keyword">and</span> t_modified &lt;<span class="string">'2018-7-1'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>隐式类型转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid=<span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>tradeid的字段类型是varchar(32)，而输入的参数是整形，需要做类型转换。</p><p><strong>字符串和数字作比较：将字符串转换成数字</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">CAST</span>(tradeid <span class="keyword">AS</span> signed <span class="built_in">int</span>) = <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>因此触发：对索引字段做函数操作，优化器会放弃走树搜索功能。</p></li><li><p><strong>隐式字符编码转换</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`trade_detail`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`tradeid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`trade step`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 操作步骤 */</span></span><br><span class="line"><span class="string">`step_info`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`tradeid`</span> (<span class="string">`tradeid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure><p>查询id=2的交易的所有操作步骤信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/image-20210722215222511.png" alt></p><ol><li>优化器会先在交易记录表tradelog上查到id=2的行，这个步骤使用了主键索引，row=1表示只扫描一行；</li><li>第2行key=NULL，表示没用上交易详情表trade_detail上的tradeid索引，进行了全表扫描。</li></ol><p>从tradelog表中取tradeid字段，再去trade_detail表里查询匹配字段。因此，tradelog称为驱动表，把trade_detail表称为被驱动表，把tradeid称为关联字段。</p><p><img data-src="../assets/img/image-20210722222051685.png" alt></p><ol><li>根据id在tradelog表中找到L2这一行；</li><li>从L2中取出tradeid字段的值；</li><li>根据tradeid值到trade_detail表中查找条件匹配的行。explain的结果里面第二行的key=NULL表示的就是，这个过程就是通过遍历主键索引的方式，一个个的判断tradeid的值是否匹配。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid=$L2.tradeid.value</span><br></pre></td></tr></table></figure><p>$L2.tradeid.value的字符集就是utf8mb4，字符集utf8mb4是utf8的超集，两个不同类型的字符串比较时，MySQL会把utf8字符串转成utf8mb4字符集再做比较。所以需要将被驱动数据表里的字段一个一个转成utf8mb4，再与L2比较，类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">CONVERT</span>(tradeid <span class="keyword">USING</span> uth8mb4)=$L2.tradeid.value</span><br></pre></td></tr></table></figure><p>再次触发了：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><p><strong>连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =$R4.tradeid.value;</span><br></pre></td></tr></table></figure><p>改写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">operator</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> traideid =<span class="keyword">CONVERT</span>($R4.tradeid.value <span class="keyword">USING</span> utf8mb4);</span><br></pre></td></tr></table></figure><p>CONVERT函数加在输入参数上，可以用上被驱动表的tradeid索引。</p><p><strong>优化：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid=l.tradeid <span class="keyword">and</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol><li><p>把trade_detail表上的tradeid字段的字符集也改成utf8mb4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> trade_detail <span class="keyword">modify</span> tradeid <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">default</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改sql语句，主动把l.tradeid转成utf8，避免了被驱动表上的字符编码转换。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.* <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid=<span class="keyword">CONVERT</span>(l.trade.id <span class="keyword">USING</span> utf8) <span class="keyword">on</span> l.id=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="2-9-为什么我只查一行的语句，也执行这么慢？"><a href="#2-9-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="2.9 为什么我只查一行的语句，也执行这么慢？"></a>2.9 为什么我只查一行的语句，也执行这么慢？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">while(i&lt;=100000)do</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i);</span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><ol><li><p><strong>查询长时间不返回</strong></p><p>大概率表t被锁住了，执行<code>show processlist</code>命令查看当前语句状态。</p><ul><li><p><strong>等MDL锁</strong></p><p><img data-src="../assets/img/image-20210726223343443.png" alt></p><p><code>Wating for table metadata lock</code>状态表示的是，现在有一个线程正在表t上请求或持有MDL写锁，把select语句堵住了。</p><p>找到谁持有MDL锁，然后把它kill掉。<br>通过查询sys.schema_table_lockwaits这张表，直接找出造成阻塞的process id，把这个连接用kill命令断开即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p><strong>等flush</strong></p><p><code>Waiting for table flush</code>表示，有一个线程正要对表t做flush操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;<span class="comment">#只关闭表t</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">table</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;  <span class="comment">#关闭所有打开的表</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>正常情况下，这两个语句执行都很快，可能的情况：有一个flush tables 命令被别的语句堵住了，然后它又堵住了select语句。</code></pre><ul><li><p><strong>等行锁</strong></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;<br>update t set c=c+1 where id=1;</td><td></td></tr><tr><td></td><td>select * from where id=1 lock in share mode;</td></tr></tbody></table><p>show processlist</p><p><img data-src="../assets/img/image-20210727221501088.png" alt></p><p>查询是谁占有了写锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> locked_table,waiting_pid,waiting_query,blocking_trx_id,blocking_pid <span class="keyword">from</span> sys.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">kill</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p><strong>查询慢</strong></p><ul><li><p>查看是否开启慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img data-src="../assets/img/image-20210802212135496.png" alt></p><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>start transaction with consistent snapshot;</td><td></td></tr><tr><td></td><td>update t set c=c+1;//执行100万池</td></tr><tr><td>select * from t where id=1;</td><td></td></tr><tr><td>select * from where id=1 lock in share mode;</td><td></td></tr></tbody></table><p><img data-src="../assets/img/image-20210802212638953.png" alt></p><p>session B更新完100万次，生成了100万个回滚日志(undo log)。(undo log里记录的其实是”把2改成1”，”把3改成2”这样的操作逻辑)</p><p>带lock in share mode的SQL语句，是当前读，因此会直接读到1000001这个结果，所以速度很快；而select * from t where id=1是一致性读，因此需要从1000001开始，依次执行log，执行100万次以后，才将1这个结果返回。</p></li></ol><h4 id="2-10-幻读"><a href="#2-10-幻读" class="headerlink" title="2.10 幻读"></a>2.10 幻读</h4><ul><li><p>幻读有什么问题？</p><ul><li>语义</li><li>数据一致性</li></ul></li><li><p>如何解决幻读？</p><p>产生幻读的原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的”间隙”。</p><p><strong>间隙锁(Gap Lock)</strong></p><p>锁的就是两个值之间的空隙。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/image-20210804221313976.png" alt="批量插入数据"></p><p>当执行<code>select * from t where d=5 for update</code>的时候，就不止给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。即在一行行扫描的过程中，不仅给行加上了行锁，还给行两边的空袭，也加上了间隙锁。</p><p>行锁分为读锁和写锁：</p><p><img data-src="../assets/img/image-20210804221753434.png" alt></p><p>跟行锁有冲突关系的是”另外一个行锁”。</p><p>但跟间隙锁存在冲突关系的，是”往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</p><p>间隙锁和行锁合称next-key lock，next-key-lock解决了幻读的问题，但可能会导致同样的语句锁住更大的范围。</p><p>间隙锁在可重复读隔离级别下才会生效，<strong>把隔离级别设为读提交，就没有间隙锁了。但同时可能会出现数据和日志不一致问题，需要把binlog格式设置为row。</strong></p></li></ul><h4 id="2-11-next-key-lock"><a href="#2-11-next-key-lock" class="headerlink" title="2.11 next-key lock"></a>2.11 next-key lock</h4><ol><li>原则1：加锁的基本单位是next-key lock，前开后闭((5,10])</li><li>原则2：查找过程中访问到的对象才会加锁</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化成行锁</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁</li><li>bug：唯一索引上的范围查询会访问到不满足条件的第一个值为此</li></ol><p>删除数据的时候尽量加limit，不仅可以控制删除数据的条数，让操作更安全，还可减小加锁的范围。</p><p>next-key lock实际上是由间隙锁加行锁实现的。</p><h4 id="2-12-应急提高性能的方法"><a href="#2-12-应急提高性能的方法" class="headerlink" title="2.12 应急提高性能的方法"></a>2.12 应急提高性能的方法</h4><ul><li><p><strong>短连接风暴</strong></p><p>如果使用的是短链接，业务高峰期，连接数暴增。MySQL建立连接成本很高(网络连接3次握手、登录权限判断和获得这个连接的读写权限)。</p><p>数据库处理不及时；机器负载较高时，处理现有请求耗时变长，每个连接保持的时间也更长；连接数上限：max_connections，超过这个值时，会拒绝接下来的连接请求，并报错提示”Too many connections”。</p><ul><li><p><strong>先处理掉那些占着连接但不工作的线程</strong></p><p>max_connections，只要连着就占用一个计数位置。kill connection处理掉不需要保持的连接；设置wait_tineout参数(一个线程空闲wait_timeout这么多秒以后，就会被MySQL直接断开连接)。</p><blockquote><p>优先断开事务外空闲太久的连接，如果这样还不够，再考虑断开事务内的空闲太久的连接。(从 information_schema.innodb_trx 查询事务状态)</p></blockquote><p>kill connection + id，一个客户端处于sleep状态，它的连接被服务端主动断开，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到报错”ERROR 2013 (HY000): Lost connection to<br>MySQL server during query”。</p></li><li><p><strong>减少连接过程的消耗</strong></p><p>让数据库跳过权限验证阶段，重启数据库，并使用-skip-grant-tables参数启动，整个MySQL会跳过所有的权限验证，包括连接过程和语句执行过程，<strong>风险极高</strong>。</p><blockquote><p>MySQL8.0，如果启用-skip-grant-tables参数，MySQL会默认把-skip-networking参数打开，表示数据库只能被本地的客户端连接。</p></blockquote></li></ul></li><li><p><strong>慢查询性能问题</strong></p><p>引发慢查询的可能：</p><ol><li>索引没有设计好</li><li>SQL语句没写好</li><li>MySQL选错索引</li></ol><ul><li><p><strong>索引没有设计好</strong></p><p>紧急创建索引，MySQL5.6之后，创建索引支持Online DDL，直接执行alter table语句。</p><ol><li>在备库B上执行set sql_log_bin=off，即不写binlog，然后执行alter table语句加上索引；</li><li>执行主备切换；</li><li>这时候主库是B，备库是A。在A上执行set sql_bin_log=off，然后执行alter table语句加上索引。</li></ol></li><li><p><strong>SQL语句没写好</strong></p><p>MySQL5.7之后提供了query_rewrite功能，可以把输入的一种语句改写成另外一种模式。</p><p>如语句被错误地写成了 <code>select * from t where id + 1 = 10000</code>，可以通过下面的<br>方式，增加一个语句改写规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br><span class="line"><span class="comment">-- 这个存储过程，让插入的新规则生效，即"查询重写"</span></span><br></pre></td></tr></table></figure><p><img data-src="../assets/img/image-20210823224604330.png" alt></p></li><li><p><strong>MySQL选错索引</strong></p><p>使用查询重写功能，给原来的语句加上force index。</p></li></ul><p>通过以下方式，预先发现问题：</p><ol><li>上线前，在测试环境，把慢查询日志(show log)打开，并把long_query_time设为0。(确保每个语句都会被记录入慢查询日志)</li><li>在测试表里插入线上数据，进行回归测试。</li><li>观察慢查询日志里每类语句的输出，特别留意Rows_examined(每次执行过程中实际扫描的记录数)字段是否与预期一致。</li></ol></li><li><p><strong>QPS突增问题</strong></p><p>业务突然出现高峰或应用程序bug，导致某个语句QPS暴增。</p><ol><li><p>由全新业务的bug导致的，能够确定业务方会下掉这个功能，可以从数据库直接把白名单去掉。(白名单机制)</p></li><li><p>如果使用的是单独的数据库用户，可以用管理员账号把这个用户删掉。(业务账户分离)</p></li><li><p>如果新增的功能和主体功能是部署在一起的，可以通过查询重写功能，单独把这个语句以select 1的结果返回。</p><p>副作用：</p><ul><li>如果别的功能里也使用了这个SQL语句模板，会有误伤。</li><li>很多业务不是一个语句就完成逻辑的，单独把这个语句以select 1的结果返回，可能导致后面的业务逻辑一起失败。</li></ul></li></ol></li></ul><h4 id="2-13-MySQL是如何保证数据不丢失的"><a href="#2-13-MySQL是如何保证数据不丢失的" class="headerlink" title="2.13 MySQL是如何保证数据不丢失的"></a>2.13 MySQL是如何保证数据不丢失的</h4><p>WAL机制(Write-Ahead Logging 先写日志，再写磁盘)，只要redo log和binlog保证持久化到磁盘，就能确保MySQL异常重启后，数据可以恢复。</p><p><strong>binlog的写入机制</strong></p><p>事务执行过程中，先把日志写到binglog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>系统给binlog cache分配了一片内存，每个线程一个，参数binlog_cache_size用于控制单个线程内binlog cache所占内存的大小。如果超过，就要暂存到磁盘。</p><p><img data-src="../assets/img/image-20210906222648205.png" alt="binlog写盘状态"><br>每个线程有自己的binlog cache，但共用同一份binlog文件。<br>write：把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，速度较快。<br>fsync：将数据持久化到磁盘，占用磁盘的IOPS。</p><p>参数sync_binlog：</p><ol><li>sync_binlog=0时，每次提交事务都只write，不fsync；</li><li>sync_binlog=1时，每次提交事务都会执行fsync；</li><li>sync_binlog=N(N&gt;1)时，表示每次提交事务都write，但累积N个事务后才能fsync。</li></ol><p><strong>如果IO出现瓶颈，可以将sync_binlog设为一个较大的值。</strong>但实际考虑到丢失日志量的可控性，常见的是将其设置为100-1000。但是，将sync_binlog设置为N，对应的风险是：如果主机发生异常重启，会丢失最近N个事务的binlog日志。</p><p><strong>redo log的写入机制</strong></p><p>redo log buffer：在事务执行的过程中，生成的redo log是要先写到redo log buffer的。</p><p><img data-src="../assets/img/image-20210906223901216.png" alt="redo log存储状态"></p><ol><li>存在redo log buffer中，物理上是在MySQL进程内存中，图中红色部分。</li><li>写到磁盘(write)，但是没有持久化(fsync)，物理上是在文件系统的page cache里，图中黄色部分。</li><li>持久化到磁盘，对应hard disk，图中绿色部分。</li></ol><p>innodb_flush_log_at_trx_commit参数：</p><ol><li>为0时，表示每次事务提交时都只是把redo log留在redo log buffer中；</li><li>为1时，表示每次事务提交时都将redo log持久化到磁盘。</li><li>为2时，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cahce，然后调用fsync持久化到磁盘。</p><blockquote><p>事务执行中间过程的redo log也是直接卸载redo log buffer中的，这些redo log也会被后台线程一起持久化到磁盘。所以，一个没有提交的事务的redo log，也是可能已经持久化到磁盘的。</p></blockquote><p>除了后台线程的轮询操作，还有两种场景会让一个没有提交的事务的redo log写入到磁盘中：</p><ol><li>redo log buffer占用的空间即将达到innodb_log_buffer_size一半的时候，后台线程会主动写盘。由于这个事务并没有提交，所以这个写盘动作只是write，而没有调用fsync，即只留在了文件系统的page cache。</li><li>并行的事务提交时，顺带将这个事务的redo log buffer持久化到磁盘。</li></ol><p>两阶段提交：时序上redo log先prepare，再写binlog，最后再把redo log commit。</p><p>如果把innodb_flush_log_at_trx_commit设置为1，那么redo log在prepare阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖prepare的redo log，再加上binlog来恢复的。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB就认为redo log在commit的时候就不需要fsync了，只会write到文件系统的page cache中就够了。</p><p><strong>“双1”配置</strong>：sync_binlog和innodb_flush_log_at_trx_commit都设置为1，即<strong>一个事务完整提交前，需要等待两次刷盘，一次是redo log(prepare阶段)，一次是binlog。</strong></p><p><strong>组提交</strong></p><p>日志逻辑序列号(LSN)：单调递增，用来对应redo log的一个个写入点。每次写入长度为length的redo log，LSN的值就会加上length。LSN也会写到InnoDB的数据页中，来确保数据页不会被多次执行重复的redo log。</p><p>三个并发事务在prepare阶段，都写完redo log buffer，持久化到磁盘的过程，对应的LSN分别是50、120和160。</p><p><img data-src="../assets/img/image-20210915222802904.png" alt></p><ol><li>trx1是第一个到达的，会被选为这组的leader；</li><li>等trx1要开始写盘的时候，这个组里已经有了三个事务，这时候LSN也变成了160。</li><li>trx1去写盘的时候，带的就是LSN=160，因此等trx1返回时，所有LSN小于等于160的redo log，都已经被持久化到磁盘；</li><li>这时候trx2和trx3就可以直接返回了。</li></ol><p><strong>一次组提交里面，组员越多，节约磁盘IOPS的效果越好。</strong>在并发更新场景下，第一个事务写完redo log buffer以后，接下来这个fsync越晚调用，组员可能越多，节约IOPS的效果就越好。</p><p><strong>“拖时间”</strong></p><p>两阶段提交：</p><p><img data-src="../assets/img/image-20210915224702007.png" alt="image-20210915224702007"></p><p>其实”写binlog”是分成两步的：</p><ol><li>先把binlog从binlog cache中写到磁盘上的binlog文件；</li><li>调用fsync持久化。</li></ol><p>MySQL为了让组提交的效果更好，把redo log做fsync的时间拖到了步骤1之后，则上图变成了：</p><p><img data-src="../assets/img/image-20210915225004511.png" alt></p><p>这样一来，binlog也可以组提交了，不过通常第3步执行的会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p><p>可以通过binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count来提升binlog组提交的效果。</p><ol><li>binlog_group_commit_sync_delay：延迟多少微妙后才调用fsync；</li><li>binlog_group_commit_sync_no_delay_count：累积多少次以后才调用fsync。</li></ol><p>这两个条件是或的关系，只要一个满足条件就会调用fsync。因此，当 binlog_group_commit_sync_delay 设置为 0 的时候，binlog_group_commit_sync_no_delay_count 也无效了。</p><p><strong>WAL制作得益于</strong>：</p><ol><li>redo log和binlog都是顺序写，磁盘的顺序写比随机写速度要快。</li><li>组提交机制，可以大幅度降低磁盘的IOPS消耗。</li></ol><p><strong>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</strong></p><ol><li>设置binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay_count参数，减少binlog的写盘次数。基于”额外的故意等待”实现，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li><li>将sync_binlog设置为大于1的值(常见的为100-1000)。风险：主机断电时会丢binlog日志。</li><li>将innodb_flush_log_at_trx_commit设置为2。风险：主机断电时会丢binlog日志。(不建议设置成 0。因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。)</li></ol><h4 id="2-14-MySQL是怎么保证主备一致的"><a href="#2-14-MySQL是怎么保证主备一致的" class="headerlink" title="2.14 MySQL是怎么保证主备一致的"></a>2.14 MySQL是怎么保证主备一致的</h4><p><strong>MySQL主备的基本原理</strong></p><p><img data-src="../assets/img/image-20211008220747983.png" alt></p><p>客户端的读写都直接访问节点A，而节点B是A的备库，只是将A的更新都同步过来，到本地执行。需要切换的时候，就切换成状态2。这时客户端读写访问节点B，而节点A是B的备库。</p><p>备库虽然没有被直接访问，但仍建议设为只读(readonly)模式：</p><ol><li>有时一些运营类的查询语句会放到备库上查询，设置为只读可以防止误操作；</li><li>防止切换逻辑有bug，如切换过程中出现双写，造成主备不一致；</li><li>可以通过readonly状态，判断节点的角色。</li></ol><p><code>readonly状态，怎么与主库保持同步更新？</code></p><p>readonly设置对超级(super)权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</p><p><img data-src="../assets/img/image-20211008222439618.png" alt="节点A到B的内部流程"></p><p>备库B跟主库A之间维持了一个长连接，主库A内部有一个线程，专门服务备库B的这个长连接。</p><p>一个事务日志同步的完整过程：</p><ol><li>在备库B上通过chang master命令，设置主库A的IP、端口、用户名、密码，以及从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</li><li>在备库上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread(主要负责与主库建立连接)和sql_thread。</li><li>主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B；</li><li>备库B拿到binlog之后，写到本地文件，称为中转日志(ready log)；</li><li>sql_thread读取中转日志，解析出日志里的命令，并执行。</li></ol><blockquote><p>多线程复制方案的引入，sql_thread演化成了多个线程。</p></blockquote><p><strong>binlog的三种格式对比</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a&gt;=<span class="number">4</span> <span class="keyword">and</span> t_modified&lt;=<span class="string">'2018-11-10'</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li><p>statement</p><p>记录到binlog里的语句原文，在主库执行时，用的是索引a，而在备库执行时，却用了索引t_modified，可能会造成主备不一致。</p></li><li><p>row</p><p>row格式的binlog里没有了SQL语句原文，而是替换成了两个event：Table_map(用于说明接下来操作的表)和Delete_rows(用于定义删除的行为)</p></li><li><p>mixed</p><p>因为有些statement格式的binlog可能会导致主备不一致，所以要使用row格式。但row格式，很占空间。如一个delete语句删掉10万行数据，用statement的话就是一个SQL语句被记录到binlog中，占用几十个字节的空间。但如果是row格式，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</p><p>mixed格式：<strong>MySQL会自己判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式，否则就用statement格式。(线上至少应该把 binlog 的格式设置为 mixed)</strong></p></li></ol><p><strong>恢复数据</strong></p><p>现在越来越多场景要求把MySQL的binlog格式设为row，如<code>恢复数据</code>。</p><p>binlog恢复数据的标准做法：用mysqlbinlog工具解析出来，然后把解析结果整个发给MySQL执行，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog master.000001  <span class="comment">--start-position=2738 --stop-position=2942 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure><p>含义：将master.00001文件里面从2738字节到第2973字节中间这段内容解析出来，放到MySQL去执行。</p><p><strong>循环复制问题</strong></p><p><img data-src="../assets/img/image-20211010224052755.png" alt="MySQL 主备切换流程 -- 双 M 结构"></p><p>双M结构和M-S结构，其实区别只是多了一条线，即：节点A和B之间总是互为主备关系，这样在切换的时候就不用再修改主备关系。</p><p>但如果业务逻辑在A上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（建议把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。</p><ol><li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ol><p>日志执行流程：</p><ol><li>从节点A更新的事务，binlog里面记的都是A的server id；</li><li>传到节点B执行一次后，节点B生成的binlog的server id也是A的server id；</li><li>再传回给节点A，A判断这个server id与自己的相同，就不会再处理这个日志。所以，死循环就断掉了。</li></ol><h4 id="2-15-MySQL是怎么保证高可用的？"><a href="#2-15-MySQL是怎么保证高可用的？" class="headerlink" title="2.15 MySQL是怎么保证高可用的？"></a>2.15 MySQL是怎么保证高可用的？</h4><p> <strong>主备延迟</strong></p><p>主备切换：可能是一个主动运维动作，如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电等。</p><p><strong>同步延迟</strong></p><ol><li>主库A执行完成一个事务，写入binlog，这个时刻记为T1；</li><li>之后传给备库B，备库B接收完成这个binlog的时刻记为T2；</li><li>备库B执行完成这个事务，这个时刻记为T3。</li></ol><p><strong>主备延迟：同一个事务在备库执行完成的时间和主库执行完成的时间之间的差值</strong>，即T3-T1。</p><p>执行<code>show slave status</code>命令，返回结果<code>seconds_behind_master</code>(时间精度：秒)，用于表示当前备库延迟了多少秒。</p><p>seconds_behind_master的计算方法：</p><ol><li>每个事务binlog都有一个时间字段，用于记录主库上写入的时间；</li><li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，即seconds_behind_master。</li></ol><p>主备库机器时间设置不一致，会不会导致主备延迟的值不准确？</p><p>不会，备库连接到主库时，会执行<code>SELECT UNIX_TIMESTAMP()</code>函数来获取当前主库的系统时间，如果不一致，备库在计算seconds_behind_master时会扣掉差值。</p><p>主备延迟主要来源是：<strong>备库接收完binlog和执行完成这个事务之间的时间差</strong>。</p><p><strong>主备延迟的来源</strong></p><ol><li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p><p>对称部署</p></li><li><p>备库压力大</p><p>忽视备库的压力控制，一些分析查询语句在备库耗费了大量的CPU资源，影响了同步速度，造成主备延迟。</p><ol><li>一主多从，多接几个从库，分担读的压力；</li><li>通过binlog输出到外部系统，如Hadoop这类系统，让外部系统提供统计类查询的能力。</li></ol></li><li><p>大事务</p><p>主库上必须等事务执行完成后才写入binlog，再传入给备库。如果一个主库上的语句执行10分钟，那这个事务可能导致主备延迟10分钟。</p><p>如一次性delete大量数据，大表DDL(建议使用gh-ost方案)。</p></li><li><p>备库的并行复制能力</p></li></ol><p>主备切换不同的策略：</p><p><strong>可靠性优先策略</strong></p><p><img data-src="../assets/img/image-20211205225611489.png" alt="MySQL可靠性优先主备切换流程"></p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值(如5秒)继续下一步，否则重试这一步；</li><li>把主库A改成只读状态，即把readonly设为true；</li><li>判断备库B的senconds_behind_master的值，直到这个值变为0；</li><li>把备库B改成可读写状态，即把readonly设为false；</li><li>把业务请求切换到B库。</li></ol><p>不可用时间：步骤2到步骤5，步骤3耗费时间(步骤1保证步骤3尽可能短)。</p><p><strong>可用性优先策略</strong></p><p>步骤4、5调整到最开始执行，及不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写。</p><p>几乎没有不可用时间，可能出现数据不一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>继续执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>假设，现在主库上有大量的更新，导致主备延迟5秒。在插入一条c=4的语句后，发起了主备切换。</p><p><img data-src="../assets/img/image-20211206223345522.png" alt="可用性优先策略，且binlog_format=mixed"></p><ol><li><p>步骤2中，主库A执行完insert语句，插入一行数据(4,4)，之后开始进行主备切换；</p></li><li><p>步骤3中，由于主备之间有5秒延迟，所以备库B还未应用”插入c=4”这个中转日志，就开始接收”插入c=5”的命令；</p></li><li><p>步骤4中，备库B插入了一行数据(4,5)，并且把这个binlog发给主库A；</p></li><li><p>步骤 5 中，备库B执行”插入 c=4”这个中转日志，插入了一行数据(5,4)。而直接在备库B执行的”插入 c=5”这个语句，传到主库 A，就插入了一行新数据((5,5)。</p><p>主库A和备库B上出现了两行不一致的数据。</p></li></ol><p>可用优先策略，设置bnlog_format=row会怎样？</p><p>row格式在记录binlog的时候，会记录新插入的行的所有字段值，最后只会有一行不一致，两边的主备同步的应用线程会报错 duplicate key error 并停止。备库 B 的 (5,4) 和主库 A 的 (5,5) 这两行数据，都不会被对方执行。</p><p><img data-src="../assets/img/image-20211206224759317.png" alt="可用优先策略，且binlog_format=row"></p><p>结论：</p><ol><li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。</li><li>主备切换的可用性优先策略会导致数据不一致。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-基础篇&quot;&gt;&lt;a href=&quot;#1-基础篇&quot; class=&quot;headerlink&quot; title=&quot;1.基础篇&quot;&gt;&lt;/a&gt;1.基础篇&lt;/h3&gt;&lt;h4 id=&quot;1-1-一条SQL查询语句是如何执行的？&quot;&gt;&lt;a href=&quot;#1-1-一条SQL查询语句是如何执行的？&quot; class=&quot;headerlink&quot; title=&quot;1.1 一条SQL查询语句是如何执行的？&quot;&gt;&lt;/a&gt;1.1 一条SQL查询语句是如何执行的？&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;../assets/img/0d2070e8f84c4801adbfa03bda1f98d9.png&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Server层&lt;/p&gt;
&lt;p&gt;连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL的大多数核心服务功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能在这一层实现，如存储过程、触发器、视图等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://imokkkk.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://imokkkk.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://imokkkk.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>代理模式(JDK Proxy与CGLIB Proxy)</title>
    <link href="https://imokkkk.github.io/proxymode/"/>
    <id>https://imokkkk.github.io/proxymode/</id>
    <published>2021-05-23T14:15:34.269Z</published>
    <updated>2021-05-23T14:36:45.692Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1.静态代理"></a>1.静态代理</h3><ol><li><p>售卖香水接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义真实对象和代理对象的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义香水提供商，实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChanelFactory</span> <span class="keyword">implements</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功购买香奈儿品牌的香水，价格是："</span> + price + <span class="string">"元！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>定义代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoHongSellProxy</span> <span class="keyword">implements</span> <span class="title">SellPerfume</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 代理对象内部保存对真实目标对象的引用，控制其它对象对目标对象的访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChanelFactory chanelFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoHongSellProxy</span><span class="params">(ChanelFactory chanelFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chanelFactory = chanelFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellPerfume</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        doSomethingBeforeSell();</span><br><span class="line">        chanelFactory.sellPerfume(price);</span><br><span class="line">        doSomethingAfterSell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBeforeSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小红代理购买香水前的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfterSell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小红代理购买香水后的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>购买香水</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 访问者仅能通过代理对象访问真实目标对象，不可直接访问目标对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChanelFactory chanelFactory = <span class="keyword">new</span> ChanelFactory();</span><br><span class="line">        XiaoHongSellProxy xiaoHongSellProxy = <span class="keyword">new</span> XiaoHongSellProxy(chanelFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 代理对象并不是真正提供服务的对象，它只是替访问者访问目标对象的一个中间人，</span></span><br><span class="line"><span class="comment">         * 真正提供服务的还是目标对象，而代理对象的作用就是在目标对象提供服务之前或之后能够执行额外的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        xiaoHongSellProxy.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">小红代理购买香水前的额外操作...</span><br><span class="line">成功购买香奈儿品牌的香水，价格是：<span class="number">100.0</span>元！</span><br><span class="line">小红代理购买香水后的额外操作...</span><br></pre></td></tr></table></figure></li></ol><p><strong>代理模式的定义：</strong>给目标对象提供一个代理对象，代理对象包含该目标对象，并控制对该目标对象的访问。</p><p><strong>代理模式的目的：</strong>通过代理对象的隔离，可以在对目标对象的访问前后增加额外的业务逻辑，实现功能增强；通过代理对象访问目标对象，可以防止系统大量的直接对目标对象进行不正确的访问。</p><h3 id="2-静态代理与动态代理"><a href="#2-静态代理与动态代理" class="headerlink" title="2.静态代理与动态代理"></a>2.静态代理与动态代理</h3><p><strong>共同点：</strong>都能实现代理模式；代理对象和目标对象都需要实现一个公共接口。</p><p><strong>不同点：</strong></p><ul><li>动态代理产生代理对象的时机是<strong>运行时动态生成</strong>，它没有Java源文件，<strong>直接生成字节码文件实例化代理对象</strong>，而静态代理的代理对象，在<strong>程序编译时</strong>已经写好了Java文件，直接new一个代理对象即可。</li><li>动态代理比静态代理更加稳健，对程序的可维护性和扩展性更加友好。</li></ul><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>面对新的需求时，不需要修改代理对象的代码，只需要新增接口对象，在客户端调用即可完成新的代理。</p><h4 id="3-1-JDK-Proxy"><a href="#3-1-JDK-Proxy" class="headerlink" title="3.1 JDK Proxy"></a>3.1 JDK Proxy</h4><p>JDK提供的一个动态代理机制，涉及到Proxy和InvocationHandler两个核心类。</p><p><strong>代理对象是在程序运行过程中，有代理工厂动态生成，代理对象本身不存在Java源文件。</strong></p><p>代理工厂需要实现InvocationHanlder接口并实现invoke()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellProxyFactory</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行代理后的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行代理前的额外操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 真正执行的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 调用第二个参数method时传入的参数列表值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        Object invokeObject = method.invoke(object, args);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成代理对象需要用到Proxy类，里面的静态方法newProxyInstance可以生成任意一个代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loader 加载动态代理的类的类加载器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 代理类实现的接口，可以传入多个接口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 指定代理类的调用处理程序，即调用接口中的方法时，会找到该代理工厂h，执行invoke()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure><p><strong>新增红酒代理功能：</strong></p><ul><li><p>创建新的红酒供应商和售卖红酒接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 红酒供应商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedWineFactory</span> <span class="keyword">implements</span> <span class="title">SellWine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SellWine</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"成功售卖一瓶红酒，价格："</span> + price + <span class="string">"元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 售卖红酒接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellWine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SellWine</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在客户端实例化一个代理对象，然后向该代理对象购买红酒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// buyChannel();</span></span><br><span class="line">        buyRedWine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ChanelFactory chanelFactory = <span class="keyword">new</span> ChanelFactory();</span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory(chanelFactory);</span><br><span class="line">        SellPerfume sellPerfume = (SellPerfume)Proxy.newProxyInstance(chanelFactory.getClass().getClassLoader(),</span><br><span class="line">            chanelFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        sellPerfume.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyRedWine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化一个红酒供应商</span></span><br><span class="line">        RedWineFactory redWineFactory = <span class="keyword">new</span> RedWineFactory();</span><br><span class="line">        <span class="comment">// 实例化代理工厂，传入红酒供应商引用控制对其的访问</span></span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory(redWineFactory);</span><br><span class="line">        <span class="comment">// 实例化代理对象</span></span><br><span class="line">        SellWine sellWine = (SellWine)Proxy.newProxyInstance(redWineFactory.getClass().getClassLoader(),</span><br><span class="line">            redWineFactory.getClass().getInterfaces(), sellProxyFactory);</span><br><span class="line">        <span class="comment">// 代理售卖红酒</span></span><br><span class="line">        sellWine.SellWine(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong></p><ol><li>JDK动态代理的使用方法<ul><li>代理工厂需要实现InvocationHandle接口，调用代理方法会转向执行invoke()方法。</li><li>生成代理对象需要使用Proxy对象中的newProxyInsatnce()方法，返回对象可强转成传入的其中一个接口，然后调用接口方法即可实现代理。</li></ul></li><li>JDK动态代理的特点<ul><li>目标对象强制需要实现一个接口，否则无法使用JDK动态代理。</li></ul></li></ol><h4 id="3-2-CGLIB"><a href="#3-2-CGLIB" class="headerlink" title="3.2 CGLIB"></a>3.2 CGLIB</h4><p>CGLIB不是JDK自带的动态代理，它需要导入第三方依赖，它是一个字节码生成类库，能够在运行时动态生成代理类对Java类和Java接口扩展。CGLIB不仅能够为Java接口做代理，而且<strong>能够为普通的Java类做代理</strong>，而JDK Proxy只能为实现了接口的Java类做代理。</p><p><strong>CGLIB可以代理没有实现接口的Java类</strong></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CGLIB代理中有两个核心的类：MetondInterceptor接口和Enhancer类，前者是实现一个代理工厂的根接口，后者是创建动态代理对象的类。</p><p>定义代理工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关联真实对象，控制真实对象的访问</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从代理工厂获取一个代理对象实例，等价于创建小红代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置需要增强类的类加载器</span></span><br><span class="line">        enhancer.setClassLoader(object.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类，真实对象</span></span><br><span class="line">        enhancer.setSuperclass(object.getClass());</span><br><span class="line">        <span class="comment">// 设置方法拦截器，代理工厂</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行方法前额外的操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行方法后额外的操作..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 被代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects 被拦截方法的所有入参值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理，用于调用原始的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        doSomethingBefore();</span><br><span class="line">        Object invokeSuperObject = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        doSomethingAfter();</span><br><span class="line">        <span class="keyword">return</span> invokeSuperObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellProxyFactory sellProxyFactory = <span class="keyword">new</span> SellProxyFactory();</span><br><span class="line">        <span class="comment">//获取一个代理实例</span></span><br><span class="line">        ChanelFactory chanelFactoryInstance = (ChanelFactory) sellProxyFactory.getProxyInstance(<span class="keyword">new</span> ChanelFactory());</span><br><span class="line">        chanelFactoryInstance.sellPerfume(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li><p>CGLIB的使用方法</p><ul><li>代理工厂需要<strong>实现MethodInterceptor接口</strong>，并重写方法，<strong>内部关联真实对象</strong>，控制第三者对真实对象的访问；代理工厂内部暴露getInstance(Object object)方法，<strong>用于从代理工厂中获取一个代理对象实例</strong>。</li><li>Enhancer类用于从代理工厂中实例化一个代理对象，给调用者提供代理服务。</li></ul></li><li><p>JDK Proxy和CGLIB的对比</p><table><thead><tr><th></th><th>JDK Proxy</th><th>CGLIB</th></tr></thead><tbody><tr><td>代理工厂实现接口</td><td>InvocationHandler</td><td>MethodInterceptor</td></tr><tr><td>构造代理对象给Client服务</td><td>Proxy</td><td>Enhancer</td></tr></tbody></table><p><strong>不同点：</strong></p><ul><li>CGLIB可以代理大部分类；而JDK Proxy仅能够代理实现了接口的类</li><li>CGLIB采用动态创建被代理类的子类实现方法拦截的方法，所以CGLIB不能代理被final关键字修饰的类和方法。</li></ul></li></ol></li></ol><h3 id="4-动态代理的实际运用"><a href="#4-动态代理的实际运用" class="headerlink" title="4.动态代理的实际运用"></a>4.动态代理的实际运用</h3><p>AOP允许我们<strong>将重复的代码逻辑抽取出来形成一个单独的覆盖层</strong>，在执行代码时可以将覆盖层嵌入到原代码逻辑里面去。</p><p>如下图，method1和method2都需要在方法执行前后记录日志，AOP可以将大量重复的Log.info代码包装到额外的一层，监听方法的执行，当方法被调用时，通用的日志记录层会拦截掉该方法，在该方法调用前后记录日志，这样可以让方法专注于自己的业务逻辑而无需关注其它不必要的信息。</p><p><img data-src="../../../../assets/img/640.gif" alt></p><p>Spring AOP有许多功能：提供缓存、提供日志环绕、事务处理……</p><p><strong>事务</strong></p><p>@Transactional</p><p>每个有关数据库的操作都有保证一个事务内的所有操作，要么全部执行成功，要么全部执行失败，传统的事务失败回滚和成功提交是使用try…catch代码块完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    session = getSqlSessionFactory().openSession(<span class="keyword">false</span>);</span><br><span class="line">    session.update(<span class="string">"..."</span>, <span class="keyword">new</span> Object());</span><br><span class="line">    <span class="comment">// 事务提交</span></span><br><span class="line">    session.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// 事务回滚</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭事务</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个方法都需要写这一段逻辑非常冗余，所以Spring封装了一个注解@Transactional，使用它后，调用方法时会监视方法，如果方法上含有该注解，就会自动把数据库相关操作的代码包裹起来，类似上面一段代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-静态代理&quot;&gt;&lt;a href=&quot;#1-静态代理&quot; class=&quot;headerlink&quot; title=&quot;1.静态代理&quot;&gt;&lt;/a&gt;1.静态代理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;售卖香水接口&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 定义真实对象和代理对象的公共接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SellPerfume&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sellPerfume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; price)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义香水提供商，实现接口&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChanelFactory&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SellPerfume&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sellPerfume&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; price)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;成功购买香奈儿品牌的香水，价格是：&quot;&lt;/span&gt; + price + &lt;span class=&quot;string&quot;&gt;&quot;元！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://imokkkk.github.io/categories/Spring/"/>
    
    
      <category term="代理模式" scheme="https://imokkkk.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络与网络编程</title>
    <link href="https://imokkkk.github.io/65346/"/>
    <id>https://imokkkk.github.io/65346/</id>
    <published>2021-05-08T13:19:59.249Z</published>
    <updated>2023-02-03T08:12:27.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1.软件结构"></a>1.软件结构</h3><h4 id="1-1-C-S结构"><a href="#1-1-C-S结构" class="headerlink" title="1.1 C/S结构"></a>1.1 C/S结构</h4><p>全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。<br><img data-src="../../../../assets/img/1_cs.jpg" alt></p><h4 id="1-2-B-S结构"><a href="#1-2-B-S结构" class="headerlink" title="1.2 B/S结构"></a>1.2 B/S结构</h4><p>全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><a id="more"></a><p><img data-src="../../../../assets/img/2_bs.jpg" alt><br>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h3 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2.网络通信协议"></a>2.网络通信协议</h3><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<br><img data-src="../../../../assets/img/3_tcp_ip.jpg" alt><br>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li><li><strong>OSI七层模型:</strong><br>  应用层    负责对软件提供接口时程序能使用网络服务<br>  表示层    应用程序和网络之间的翻译官<br>  会话层    负责在网络中的两节点之间建立和维持通信<br>  传输层    建立端到端之间的连接，数据的分段和重组<br>  网络层    将网络地址翻译成对应的mac地址，指导数据包的转发<br>  数据链路层    将网络层接收到的数据包封装为特定的数据帧，使其在不可靠的物理链路上进行可靠的数据传递<br>  物理层    建立、维护、断开物理连接。（由底层网络定义协议）</li></ul><h3 id="3-UDP与TCP协议"><a href="#3-UDP与TCP协议" class="headerlink" title="3.UDP与TCP协议"></a>3.UDP与TCP协议</h3><h4 id="3-1-UDP协议"><a href="#3-1-UDP协议" class="headerlink" title="3.1 UDP协议"></a>3.1 UDP协议</h4><p>​    UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。<br><img data-src="../../../../assets/img/106209.png" alt></p><h4 id="3-2-TCP协议"><a href="#3-2-TCP协议" class="headerlink" title="3.2 TCP协议"></a>3.2 TCP协议</h4><p>​    TCP协议是<strong>面向连接</strong>的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。每次连接的创建都需要经过“三次握手”。</p><ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认 </li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 </li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示<br><img data-src="../../../../assets/img/403168.png" alt><br>由于TCP协议的面向连接特性，它可以保证传输数据的安全性，所以是一个被广泛采用的协议，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。</li></ul><h3 id="4-相关面试题"><a href="#4-相关面试题" class="headerlink" title="4.相关面试题"></a>4.相关面试题</h3><ol><li>TCP断开连接的四次挥手<br>第一次挥手：客户端发送一个FIN包（seq=x），进入FIN_WAIT（结束等待）状态<br>第二次挥手：服务器收到FIN包，发回一个ACK包(ack=x+1)，进入CLOSE_WAIT（关闭等待）状态<br>第三次挥手：服务器关闭客户端的连接，并发送一个FIN包(seq=y)，进入LAST_ACK（最后确认）状态<br>第四次挥手：客户端发回ACK(ack=y+1)包确认，发送完毕后，连接断开<br><img data-src="../../../../assets/img/70830403.png" alt></li><li>需要三次握手的原因<br><strong>为了防止失效的连接请求报文突然又传送到服务器产生错误</strong>。假如不三次握手，客户端发送连接确认给服务端就立即建立连接，如果有个连接请求阻塞了很久才到服务端，而此时本来已经关闭了连接的又重新建立了连接，然而等了很久都没有数据发送，这就会白白浪费资源</li><li>Http协议与Https协议</li></ol><ul><li>Http协议即<strong>超文本传输协议</strong>，是一种<strong>基于TCP的应用层协议</strong>，还是一种<strong>无状态协议</strong>。用于服务器和客户端的<strong>数据传输</strong>，客户端和服务器使用<strong>URL</strong>来建立连接和传输数据。客户端发送Http请求给服务器，服务器根据请求返回Html、文本或多媒体文件给客户端</li><li>Https协议是一种安全的Http协议。Http协议是一种明文传输的协议，存在被窃听，信息篡改等安全隐患，在Http协议的基础上加入了SSL或TLS协议，实现了数据的加密传输。因为加上了加密的协议，所以Https的响应速度会比Http慢很多。并不是所有情况下都需要使用Https协议，对于隐私的，重要的信息最好用Https协议，不重要的或者可以公开的信息就没有必要用Https协议</li></ul><ol start="4"><li>Http请求报文和响应报文</li></ol><ul><li>请求报文包括请求行，请求头，空行和请求体（GET请求没有请求体）</li><li>响应报文包括状态行，响应头，空行和响应体</li></ul><ol start="5"><li>Http请求常见状态码</li></ol><ul><li>200 OK，请求成功</li><li>404 Not Found，对应的URL上不存在资源</li><li>405 Method Not Allowed，请求不被允许，即请求方式错误</li><li>500 Internal Server Error，服务器内部错误，发现严重BUG，要及时修复</li></ul><ol start="6"><li>GET请求与POST请求的区别</li></ol><ul><li>GET请求一般用于<strong>获取</strong>服务器上的资源，是<strong>幂等</strong>的。POST请求一般用于对服务器上资源进行<strong>更新</strong>，<strong>非幂等</strong>的（幂等即每次请求返回结果一样）</li><li>GET请求没有请求体，<strong>请求参数跟是在URL后面</strong>的，所以使用GET请求时请求参数用户是可以直接看到的。POST请求有请求体，<strong>请求参数放在请求体</strong>，对用户是不可见的。相对来说POST请求比GET请求更安全</li><li>GET请求的参数<strong>长度有限制</strong>，这是因为URL长度有限导致的。POST请求的参数长度可以认为是<strong>无限制</strong>的</li></ul><ol start="7"><li>TCP 和 UDP的区别</li></ol><ul><li>TCP是一种<strong>面向连接的可靠</strong>传输协议，UDP是<strong>面向无连接的不可靠</strong>传输协议</li><li>TCP支持报文传输，还支持<strong>字节流</strong>的传输。而UDP协议只支持传输报文</li><li>TCP<strong>数据报格式比较复杂</strong>，传输过程数据不容易丢失和出错，而UDP<strong>数据报格式较为简单</strong>，容易丢失</li><li>TCP传输在接收端会进行重排，所以是<strong>有序</strong>的，UDP则<strong>不保证有序</strong></li><li>TCP<strong>速度慢</strong>，UDP<strong>速度快</strong></li><li>TCP有<strong>流量控制和拥塞控制</strong>，而UDP没有</li></ul><ol start="8"><li>应用层协议有哪些</li></ol><ul><li>DNS协议，域名解析系统。基于TCP和UDP的协议，通过DNS可以将域名转换成IP地址</li><li>SMTP协议，电子邮件协议。基于TCP的协议，通过SMTP协议可以发送电子邮件，SMTP通信的过程建立连接、邮件传送、连接释放</li><li>Telnet协议，远程终端协议。基于TCP的协议，通过Telnet协议可以对远程的终端进行控制</li><li>Http协议，超文本传输协议。基于TCP的协议，通过Http协议实现客户端和服务端的数据传输</li><li>FTP协议，文件传输协议。基于TCP的协议，通过FTP协议达到相互传输文件的效果</li></ul><ol start="9"><li>OSI参考模型与TCP/IP参考模型<br>(1) OSI参考模型由7层组成：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>(2) TCP/IP参考模型由4层组成：主机-网络层、网际层、传输层、应用层<br>(3) 对应关系中，OSI参考模型的物理层、数据链路层对应TCP/IP的主机-网络层，网络层对应网际层，传输层对应传输层，会话层、表示层、应用层对应应用层</li><li>cookie 和 session的区别<br>(1) cookie由于把信息保存在客户端中。session把信息保存在服务器中<br>(2) cookie性能更高一点，速度较快，用户的信息存在各自的浏览器中，可以分担服务器的一部分存储工作。session速度较慢，所有用户的信息都存在服务器中，在高并发时必然影响服务器性能<br>(3) cookie有限制大小，在4K以内。session没有限制<br>(4) cookie对用户是透明的，安全性低，不重要的或者可以公开的信息保存在cookie。session对用户是不可见的，安全性高，重要信息应该保存在session</li><li>forward 和 redirect的区别<br>(1) forward为转发，进行forward操作后，请求URL不发生变化，并且会把请求的数据携带到下一个请求中。redirect是重定向，进行redirect操作后，请求URL是发生变化的<br>(2) forward是服务器内部请求转发，不可以请求到其它站点，redirect是服务器通知客户端重新请求，可以请求到其它站点<br>(3) forward速度快，redirect速度慢</li><li>DNS劫持和DNS污染<br>(1) DNS劫持：指用户访问一个域名时，DNS服务器故意将此地址指向一个错误的IP地址的行为。比如进入一个网站显示的却是另外一个网站的内容<br>(2) DNS污染：指用户访问一个域名时，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如国内不能访问Google、YouTube等</li></ol><h3 id="5-TCP通信程序"><a href="#5-TCP通信程序" class="headerlink" title="5.TCP通信程序"></a>5.TCP通信程序</h3><h4 id="5-1-简单的TCP网络程序"><a href="#5-1-简单的TCP网络程序" class="headerlink" title="5.1 简单的TCP网络程序"></a>5.1 简单的TCP网络程序</h4><p><strong>TCP通信分析图解</strong></p><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。<blockquote><p>到此，客户端向服务端发送数据成功。<br><img data-src="../../../../assets/img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg" alt><br>自此，服务端向客户端回写数据。</p></blockquote></li><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       OutputStream out = server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());</span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      InputStream in = client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-文件上传"><a href="#5-2-文件上传" class="headerlink" title="5.2 文件上传"></a>5.2 文件上传</h4><p><strong>文件上传分析图解</strong></p><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。<br><img data-src="../../../../assets/img/6_upload2.jpg" alt></li></ol><p><strong>服务端实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件结构&quot;&gt;&lt;a href=&quot;#1-软件结构&quot; class=&quot;headerlink&quot; title=&quot;1.软件结构&quot;&gt;&lt;/a&gt;1.软件结构&lt;/h3&gt;&lt;h4 id=&quot;1-1-C-S结构&quot;&gt;&lt;a href=&quot;#1-1-C-S结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 C/S结构&quot;&gt;&lt;/a&gt;1.1 C/S结构&lt;/h4&gt;&lt;p&gt;全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。&lt;br&gt;&lt;img data-src=&quot;../../../../assets/img/1_cs.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-2-B-S结构&quot;&gt;&lt;a href=&quot;#1-2-B-S结构&quot; class=&quot;headerlink&quot; title=&quot;1.2 B/S结构&quot;&gt;&lt;/a&gt;1.2 B/S结构&lt;/h4&gt;&lt;p&gt;全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://imokkkk.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="javase" scheme="https://imokkkk.github.io/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://imokkkk.github.io/ThreadPool/"/>
    <id>https://imokkkk.github.io/ThreadPool/</id>
    <published>2021-05-08T13:19:59.242Z</published>
    <updated>2020-11-03T12:25:05.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p><img data-src="../../../../assets/img/11183270.jpg" alt></p><a id="more"></a><p><strong>原理：</strong><br>当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。<br><strong>优点：</strong></p><ol><li>降低资源消耗；</li><li>提高响应速度；</li><li>提高线程的可管理性。</li></ol><p><strong>缺点：</strong>TODO<br><img data-src="../../../../assets/img/184834.jpg" alt></p><h5 id="1-1-四种常用ExecutorService特性"><a href="#1-1-四种常用ExecutorService特性" class="headerlink" title="1.1 四种常用ExecutorService特性"></a>1.1 四种常用ExecutorService特性</h5><table><thead><tr><th>类型</th><th>核心线程数</th><th>最大线程数</th><th>KeepAlive时间(存活时间)</th><th align="center">任务队列</th><th>拒绝策略</th></tr></thead><tbody><tr><td>newCachedThreadPool(可缓存线程池)</td><td>0</td><td>Integer.MAX_VALUE</td><td>60s</td><td align="center">SynchronousQueue</td><td>线程池无限大，当执行第二个任务已经完成，会复用执行第一个任务的线程。</td></tr><tr><td>newFixedThreadPool(定长线程池)</td><td>指定大小</td><td>指定大小(与核心线程数相同)</td><td>0</td><td align="center">LinkedBlockingQueue</td><td>线程池大小固定，没有可用的线程的时候，任务会放在队列等待，队列的长度无限制。</td></tr><tr><td>newSingleThreadExexutor</td><td>1</td><td>1</td><td>0</td><td align="center">LinkedBlockingQueue</td><td>单线程化的线程池，适用于业务逻辑上只允许1个线程进行处理的场景，保证所有任务按照指定顺序FIFO(先进先出)，LIFO(后进先出)，优先级执行。</td></tr><tr><td>newScheduledThreadPool</td><td>指定大小</td><td>Integer.MAX_VALUE</td><td>0</td><td align="center">DelayedWordQueue</td><td>定长线程池，支持定时及周期性任务执行。</td></tr></tbody></table><h5 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h5><p>《阿里巴巴 Java 开发手册》中规定线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。线程池的好处是<strong>减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</strong>。如果不使用线程池，有可能<strong>造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</strong>。而且线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。这样的处理方式能够<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                              <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                              <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong><br><strong>corePoolSize：</strong>核心线程数，指定了线程池中的线程池数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中；</p><p><strong>maximumPoolSize：</strong>指定了线程池中的最大线程数量，这个参数会根据使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量。</p><p>核心和最大线程数大小仅在构建时设置，但也可以使用 <code>setCorePoolSize()</code> 和 <code>setMaximumPoolSize()</code> 进行动态更改。<br><strong>keepAliveTime：</strong>当线程池中的空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁。如果线程池在以后会变得更加活跃，则应构建线程或者使用<code>setKeepAliveTime(long, TimeUnit)</code>方法。</p><p><strong>unit：</strong>keepAliveTime的单位</p><p><strong>workQueue：</strong>阻塞队列(用来保存等待被执行的任务)</p><ol><li>ArrayBlockingQueue：基于数组结构的<strong>有界任务队列</strong>，按照FIFO排序任务。若有新的任务需要执行时，线程会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程数量达到maximumPoolSize，则执行拒绝策略。这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界任务队列的初始容量比较大或者没有达到超负荷状态，线程数将会一直维持在corePoolSize以下，反之，则会以maximumPoolSize为最大线程数上限。</li><li><strong>没有预定义容量</strong>的LinkedBlockingQueue：基于链表结构的<strong>无界任务队列</strong>，按照FIFO排序任务。使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，当线程数达到corePoolSize后就不会再增加了。使用无界任务队列将导致新任务在队列中等待，从而导致maximumPoolSize的值没有任何作用。当使用这种任务队列模式时，一定要注意任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。这种队列方式可以用于平滑瞬时大量请求。</li><li>SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于ArrayBlockingQueue。<strong>直接握手队列</strong>：它将任务交给线程而不需要保留，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此构建新的线程，如果达到maximumPoolSize设置的最大值，则根据设置的handler执行拒绝策略。在这种情况下，需要对程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量避免执行拒绝策略。应注意，当任务持续以平均提交速度大于平均处理速度时，会导致线程数量会无限增长问题。</li><li>PriorityBlockingQueue：具有优先级的无界任务队列。<strong>优先任务队列</strong>：特殊的无界任务队列，无论添加了多少个任务，线程数量都不会超过corePoolSize。其它队列一般是按照FIFO(先进先出)的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。</li></ol><p><strong>threadFactory：</strong>线程工程，用于创建线程。如果未另行指定，则使用Executors.<strong>defaultThreadFactory</strong>默认工厂，使其全部位于同一个ThreadGroup中，并具有相同的NORM_PRIORITY优先级和非守护进程状态。通过不同的ThreadFactory可以更改线程的名称，线程组，优先级，守护进程状态等。privilegedThreadFactory：继承自defaultThreadFactory，主要添加了访问权限校验。</p><p><strong>handler：</strong>拒绝策略，创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但如果出现任务队列已满且线程池创建的线程数达到maximumPoolSize时，这时就需要指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池”超载”的情况。ThreadPoolExecutor自带的拒绝策略如下：</p><ol><li>AbortPolicy：默认策略，丢掉任务直接抛出RejectedExecutionException异常，阻止系统正常工作。</li><li>CallerRunsPolicy：如果线程池的线程池的线程数量达到上限，该策略会把拒绝的任务放在调用者线程当中运行，如果执行程序已关闭，则会丢弃该任务。</li><li>DiscardPolicy：该策略会默默丢弃无法处理的任务，不会抛出任何异常，使用此策略，业务场景中需允许任务的丢失。</li><li>DiscardOldestPolicy：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的。即每次移除队头元素后再尝试入队。</li></ol><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">16</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">testTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testTask testTask = <span class="keyword">new</span> testTask();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(testTask);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;h4 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h4&gt;&lt;p&gt;&lt;img data-src=&quot;../../../../assets/img/11183270.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="https://imokkkk.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://imokkkk.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="https://imokkkk.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(四)处理语音消息</title>
    <link href="https://imokkkk.github.io/35386/"/>
    <id>https://imokkkk.github.io/35386/</id>
    <published>2021-05-08T13:19:59.224Z</published>
    <updated>2020-04-29T02:44:38.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-语音识别接口"><a href="#1-语音识别接口" class="headerlink" title="1.语音识别接口"></a>1.语音识别接口</h3><p>为了实现微信公众号与用户的多样化交互, 本章进行处理用户语音消息的开发.</p><p>开发者进入微信公众平台 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span> —接口权限—对话服务—接受消息—打开接收语音识别结果接口权限</p><a id="more"></a><p><img data-src="../../../../assets/img/162311.jpg" alt></p><p><img data-src="../../../../assets/img/162403.jpg" alt></p><h3 id="2-获取语音识别结果"><a href="#2-获取语音识别结果" class="headerlink" title="2.获取语音识别结果"></a>2.获取语音识别结果</h3><p>请注意，开通语音识别后，用户每次发送语音给公众号时，微信会在推送的语音消息XML数据包中，增加一个<strong>Recognition</strong>字段（注：<code>由于客户端缓存，开发者开启或者关闭语音识别功能，对新关注者立刻生效，对已关注用户需要24小时生效。开发者可以重新关注此帐号进行测试</code>）。</p><p>开启语音识别后的语音XML数据包如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">toUser</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">fromUser</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1357290913<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">voice</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">media_id</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Format</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[<span class="attr">Format</span>] ]&gt;</span><span class="tag">&lt;/<span class="name">Format</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Recognition</span>&gt;</span><span class="tag">&lt; ![<span class="attr">CDATA</span>[腾讯微信团队] ]&gt;</span><span class="tag">&lt;/<span class="name">Recognition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>语音消息参数说明</strong></p><p><img data-src="../../../../assets/img/161521.jpg" alt></p><p>开通语音识别功能以后，用户每次发送语音给微信公众号，微信会在推送语音消息XML数据包中添加一个<code>Recongnition</code>字段，该字段为语音识别出的文本内容.</p><h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><p><strong>实体类VoiceMessage</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiceMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Recognition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MessageUtil</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">voiceMessageToXml</span><span class="params">(VoiceMessage voiceMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="string">"xml"</span>, voiceMessage.getClass());</span><br><span class="line">    <span class="keyword">return</span> xstream.toXML(voiceMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MsgService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MsgService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String respMessage = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            String fromUserName = requestMap.get(<span class="string">"FromUserName"</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            String toUserName = requestMap.get(<span class="string">"ToUserName"</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            String msgType = requestMap.get(<span class="string">"MsgType"</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String content = requestMap.get(<span class="string">"Content"</span>);</span><br><span class="line"></span><br><span class="line">            String recognition = requestMap.get(<span class="string">"Recognition"</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"FromUserName is:"</span> + fromUserName + <span class="string">", ToUserName is:"</span> + toUserName + <span class="string">", MsgType is:"</span> + msgType);</span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_VOICE))&#123;</span><br><span class="line">                System.out.println(recognition);</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">"环境信息"</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    Map map = IoTPopApiUtil.IoTpop();</span><br><span class="line">                    Map ioTpop = JSON.parseObject(JSONObject.toJSONString(map), Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    Object data = ioTpop.get(<span class="string">"data"</span>);</span><br><span class="line">                    String str = data.toString();</span><br><span class="line">                    <span class="keyword">int</span> index=str.indexOf(<span class="string">"["</span>);</span><br><span class="line">                    String result=str.substring(index);</span><br><span class="line">                    String jsonStr = result.substring(<span class="number">0</span>, result.length() - <span class="number">1</span>);</span><br><span class="line">                    JSONArray array = JSONArray.parseArray(jsonStr);</span><br><span class="line">                    List&lt;Pi&gt; pi = JSONObject.parseArray(array.toJSONString(),Pi<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String returnText=<span class="string">"当前温度:"</span>+pi.get(<span class="number">3</span>).getValue()+<span class="string">"°C"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前湿度:"</span>+pi.get(<span class="number">2</span>).getValue()+<span class="string">"%"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前光照强度:"</span>+pi.get(<span class="number">4</span>).getValue()+<span class="string">"Lux"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前气压:"</span>+pi.get(<span class="number">1</span>).getValue()+<span class="string">"hPa"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"当前海拔:"</span>+pi.get(<span class="number">0</span>).getValue()+<span class="string">"m"</span>+<span class="string">"\n"</span></span><br><span class="line">                            +<span class="string">"降雨情况:"</span>+(pi.get(<span class="number">5</span>).getValue()==<span class="number">1</span>?<span class="string">"降雨"</span>:<span class="string">"未降雨"</span>);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    TextMessage text = <span class="keyword">new</span> TextMessage();</span><br><span class="line">                    text.setContent(returnText);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(recognition.indexOf(<span class="string">"天气"</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    NewsMessage newmsg = <span class="keyword">new</span> NewsMessage();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">                    article.setTitle(<span class="string">"天气预报"</span>);</span><br><span class="line">                    article.setDescription(<span class="string">"点击了解未来天气详情..."</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">"https://xxxx.oss-cn-beijing.aliyuncs.com/ep.png"</span>);</span><br><span class="line">                    article.setUrl(<span class="string">"https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=accu&amp;key=4bdfe35a67bb4b53bee844f6ce7a4b5c"</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"error......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p><img data-src="../../../../assets/img/163205.jpg" alt></p><p><img data-src="../../../../assets/img/163500.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-语音识别接口&quot;&gt;&lt;a href=&quot;#1-语音识别接口&quot; class=&quot;headerlink&quot; title=&quot;1.语音识别接口&quot;&gt;&lt;/a&gt;1.语音识别接口&lt;/h3&gt;&lt;p&gt;为了实现微信公众号与用户的多样化交互, 本章进行处理用户语音消息的开发.&lt;/p&gt;
&lt;p&gt;开发者进入微信公众平台 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==&quot;&gt;https://mp.weixin.qq.com/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; —接口权限—对话服务—接受消息—打开接收语音识别结果接口权限&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(五)部署项目到阿里云服务器</title>
    <link href="https://imokkkk.github.io/deployment/"/>
    <id>https://imokkkk.github.io/deployment/</id>
    <published>2021-05-08T13:19:59.223Z</published>
    <updated>2020-05-28T02:18:40.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ul><li>可以正常运行提供服务的项目</li><li>一台云服务器</li></ul><h3 id="2-项目打包"><a href="#2-项目打包" class="headerlink" title="2.项目打包"></a>2.项目打包</h3><p>首先将我们在IDEA下的项目进行打包，这边基于的是maven项目的打包。<br>点击菜单栏 File → Project Structure → Artifacts 添加一个jar</p><a id="more"></a><p><img data-src="../../../../assets/img/212549.jpg" alt></p><p>之后，对添加的jar进行配置<br><img data-src="../../../../assets/img/212555.jpg" alt></p><p>点击右侧竖排菜单栏的maven project 然后点开Lifecycle，先clean再package，注意在打包之前，要将项目的启动端口号改为80，8080端口是本机端口，不适用于服务器。</p><p><img data-src="../../../../assets/img/213308.jpg" alt></p><p>当下方控制器显示BUILD SUCCESS时说明打包成功<br><img data-src="../../../../assets/img/213558.jpg" alt></p><p>这时候我们可以在项目的文件目录下看到多了个target目录，点开目录移动到最下方我们可以看到项目jar包,我们可以从电脑磁盘中将放置该项目的文件夹打开并找到该项目文件。<br><img data-src="../../../../assets/img/213739.jpg" alt><br><img data-src="../../../../assets/img/213759.jpg" alt></p><h3 id="3-导入服务器"><a href="#3-导入服务器" class="headerlink" title="3.导入服务器"></a>3.导入服务器</h3><p>使用FTP工具负责构建完成的项目jar包到云服务器<br><img data-src="../../../../assets/img/214254.jpg" alt></p><h3 id="4-运行项目"><a href="#4-运行项目" class="headerlink" title="4.运行项目"></a>4.运行项目</h3><h4 id="4-1-配置Java运行环境"><a href="#4-1-配置Java运行环境" class="headerlink" title="4.1 配置Java运行环境"></a>4.1 配置Java运行环境</h4><ol><li><p>查看yum库中的Java安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y list java*</span><br></pre></td></tr></table></figure><p>以yum库中java-1.8.0为例, “*”表示将java-1.8.0的所有相关Java程序都安装上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功<br>输入  <code>java -version</code>  <code>javac</code><br><img data-src="../../../../assets/img/214925.jpg" alt></p></li></ol><h4 id="4-2-启动项目"><a href="#4-2-启动项目" class="headerlink" title="4.2 启动项目"></a>4.2 启动项目</h4><p>查询一下80端口是否已开放，开放了80端口后我们就可以启动我们的项目了，通过输入指令：<br>Java -jar [jar包的完整文件名(.jar别忘了加)] 如下图所示。这样我们的项目就开始启动了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar WeChat-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img data-src="../../../../assets/img/214926.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-准备工作&quot;&gt;&lt;a href=&quot;#1-准备工作&quot; class=&quot;headerlink&quot; title=&quot;1.准备工作&quot;&gt;&lt;/a&gt;1.准备工作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以正常运行提供服务的项目&lt;/li&gt;
&lt;li&gt;一台云服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-项目打包&quot;&gt;&lt;a href=&quot;#2-项目打包&quot; class=&quot;headerlink&quot; title=&quot;2.项目打包&quot;&gt;&lt;/a&gt;2.项目打包&lt;/h3&gt;&lt;p&gt;首先将我们在IDEA下的项目进行打包，这边基于的是maven项目的打包。&lt;br&gt;点击菜单栏 File → Project Structure → Artifacts 添加一个jar&lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="https://imokkkk.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目部署" scheme="https://imokkkk.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Spring Boot" scheme="https://imokkkk.github.io/tags/Spring-Boot/"/>
    
      <category term="微信公众号" scheme="https://imokkkk.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(二)自动回复功能实现简单的天气查询</title>
    <link href="https://imokkkk.github.io/39972/"/>
    <id>https://imokkkk.github.io/39972/</id>
    <published>2021-05-08T13:19:59.221Z</published>
    <updated>2020-04-29T02:44:38.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>微信公众平台服务器配置通过后，就能进行下面的开发啦</p><blockquote><p>首先可以查看官方的说明文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0dldHRpbmdfU3RhcnRlZC9PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>普通消息的类型分为7种：</p><a id="more"></a><ol><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地理位置消息</li><li>链接消息</li></ol><p>本文使用的是文本消息与图片消息</p><h3 id="2-图文消息的自动回复"><a href="#2-图文消息的自动回复" class="headerlink" title="2.图文消息的自动回复"></a>2.图文消息的自动回复</h3><h4 id="2-1-文本消息"><a href="#2-1-文本消息" class="headerlink" title="2.1 文本消息"></a>2.1 文本消息</h4><p>文本消息的XML结构是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数包含：<img data-src="../../../../assets/img/203231.jpg" alt></p><p>定义一个BaseMessage，消息基类，封装通用属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息基类（普通用户 -&gt; 公众帐号）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开发者微信号</span></span><br><span class="line">    <span class="keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="comment">// 发送方帐号（一个OpenID）</span></span><br><span class="line">    <span class="keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="comment">// 消息创建时间 （整型）</span></span><br><span class="line">    <span class="keyword">private</span> String CreateTime;</span><br><span class="line">    <span class="comment">// 消息类型（text/image/location/link）</span></span><br><span class="line">    <span class="keyword">private</span> String MsgType;</span><br><span class="line">    <span class="comment">// 消息id，64位整型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> MsgId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位0x0001被标志时，星标刚收到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> FuncFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义文本消息属性TextMessage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="keyword">private</span> String Content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-图片消息"><a href="#2-2-图片消息" class="headerlink" title="2.2 图片消息"></a>2.2 图片消息</h4><p>图片消息的XML结构是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1348831860<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[image]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PicUrl</span>&gt;</span>&lt;![CDATA[this is a url]]&gt;<span class="tag">&lt;/<span class="name">PicUrl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MediaId</span>&gt;</span>&lt;![CDATA[media_id]]&gt;<span class="tag">&lt;/<span class="name">MediaId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>1234567890123456<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数包含：<img data-src="../../../../assets/img/215347.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-图文消息"><a href="#2-3-图文消息" class="headerlink" title="2.3 图文消息"></a>2.3 图文消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Description;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片链接，支持JPG、PNG格式，&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 较好的效果为大图640*320，小图80*80</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String PicUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Title;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点击图文消息跳转链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String Url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; 图文消息 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsMessage</span> <span class="keyword">extends</span> <span class="title">BaseMessage</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图文消息个数，限制为10条以内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ArticleCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多条图文消息信息，默认第一个item为大图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Article&gt; Articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3.功能实现"></a>3.功能实现</h3><h4 id="3-1-工具类MessageUtil"><a href="#3-1-工具类MessageUtil" class="headerlink" title="3.1 工具类MessageUtil"></a>3.1 工具类MessageUtil</h4><ol><li>解析微信发来的请求（xml）</li><li>将响应消息的Java对象转换成xml</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="string">"text"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：音乐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="string">"music"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回消息类型：图文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="string">"news"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="string">"text"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="string">"image"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="string">"link"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：地理位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="string">"location"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：音频</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="string">"voice"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求消息类型：推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="string">"event"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="string">"subscribe"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="string">"unsubscribe"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EVENT_TYPE_CLICK = <span class="string">"CLICK"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xml转换为map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">xmlToMap</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"></span><br><span class="line">        InputStream ins = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = request.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Document doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doc = reader.read(ins);</span><br><span class="line">            Element root = doc.getRootElement();</span><br><span class="line"></span><br><span class="line">            List&lt;Element&gt; list = root.elements();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Element e : list) &#123;</span><br><span class="line">                map.put(e.getName(), e.getText());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ins.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 解析微信发来的请求（XML）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月7日 上午10:04:02</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">parseXml</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将解析结果存储在HashMap中</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 从request中取得输入流</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        <span class="comment">// 读取输入流</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(inputStream);</span><br><span class="line">        <span class="comment">// 得到xml根元素</span></span><br><span class="line">        Element root = document.getRootElement();</span><br><span class="line">        <span class="comment">// 得到根元素的所有子节点</span></span><br><span class="line">        List&lt;Element&gt; elementList = root.elements();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子节点</span></span><br><span class="line">        <span class="keyword">for</span> (Element e : elementList) &#123;</span><br><span class="line">            map.put(e.getName(), e.getText());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public static XStream xstream = new XStream();</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本消息对象转换成xml</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textMessage 文本消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> xml</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">textMessageToXml</span><span class="params">(TextMessage textMessage)</span></span>&#123;</span><br><span class="line"><span class="comment">//        XStream xstream = new XStream();</span></span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, textMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图文消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> newsMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月8日 下午4:14:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">newsMessageToXml</span><span class="params">(NewsMessage newsMessage)</span> </span>&#123;</span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, newsMessage.getClass());</span><br><span class="line">        xstream.alias(<span class="string">"item"</span>, <span class="keyword">new</span> Article().getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(newsMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 图片消息对象转换成xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@param</span> imageMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> dapengniao</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2016年3月9日 上午9:25:51</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">imageMessageToXml</span><span class="params">(ImageMessage imageMessage)</span> </span>&#123;</span><br><span class="line">        xstream.alias(<span class="string">"xml"</span>, imageMessage.getClass());</span><br><span class="line">        <span class="keyword">return</span> xstream.toXML(imageMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象到xml的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> XStream xstream = <span class="keyword">new</span> XStream(<span class="keyword">new</span> XppDriver() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HierarchicalStreamWriter <span class="title">createWriter</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">                <span class="comment">// 对所有xml节点的转换都增加CDATA标记</span></span><br><span class="line">                <span class="keyword">boolean</span> cdata = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startNode</span><span class="params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.startNode(name, clazz);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeText</span><span class="params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cdata) &#123;</span><br><span class="line">                        writer.write(<span class="string">"&lt;![CDATA["</span>);</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                        writer.write(<span class="string">"]]&gt;"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        writer.write(text);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h4><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复<code>文本</code>、<code>图片</code>、<code>图文</code>、<code>语音</code>、<code>视频</code>、<code>音乐</code>）。</p><p>上一篇文章，已经创建了IndexController ，里面的GET方法用来验证token，下面直接加一个POST方法，用于进行消息管理。消息接收<code>POST</code>和微信认证<code>GET</code>是同一个接口（开发者填写的URL）</p><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgProcess</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">// 调用核心业务类接收消息、处理消息</span></span><br><span class="line">    String respMessage = msgService.processRequest(request);</span><br><span class="line">    <span class="comment">// 响应消息</span></span><br><span class="line">    PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        out.print(respMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        out = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MsgService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String respMessage = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// xml请求解析</span></span><br><span class="line">            Map&lt;String, String&gt; requestMap = MessageUtil.xmlToMap(request);</span><br><span class="line">            <span class="comment">// 发送方帐号（open_id）</span></span><br><span class="line">            String fromUserName = requestMap.get(<span class="string">"FromUserName"</span>);</span><br><span class="line">            <span class="comment">// 公众帐号</span></span><br><span class="line">            String toUserName = requestMap.get(<span class="string">"ToUserName"</span>);</span><br><span class="line">            <span class="comment">// 消息类型</span></span><br><span class="line">            String msgType = requestMap.get(<span class="string">"MsgType"</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String content = requestMap.get(<span class="string">"Content"</span>);</span><br><span class="line">            LOGGER.info(<span class="string">"FromUserName is:"</span> + fromUserName + <span class="string">", ToUserName is:"</span> + toUserName + <span class="string">", MsgType is:"</span> + msgType);</span><br><span class="line">            <span class="comment">// 文本消息</span></span><br><span class="line">            <span class="keyword">if</span> (msgType.equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123;</span><br><span class="line">                <span class="comment">//这里根据关键字执行相应的逻辑，只有你想不到的，没有做不到的</span></span><br><span class="line">                <span class="keyword">if</span> (content.indexOf(<span class="string">"天气"</span>)!=-<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//自动回复</span></span><br><span class="line">                    NewsMessage newmsg = <span class="keyword">new</span> NewsMessage();</span><br><span class="line">                    newmsg.setToUserName(fromUserName);</span><br><span class="line">                    newmsg.setFromUserName(toUserName);</span><br><span class="line">                    newmsg.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    newmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);</span><br><span class="line">                    newmsg.setFuncFlag(<span class="number">0</span>);</span><br><span class="line">                    List&lt;Article&gt; articleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">                    article.setTitle(<span class="string">"天气预报"</span>);</span><br><span class="line">                    article.setDescription(<span class="string">"点击了解未来天气详情..."</span>);</span><br><span class="line">                    article.setPicUrl(<span class="string">"https://lwy-image.oss-cn-beijing.aliyuncs.com/ep.png"</span>);</span><br><span class="line">                    article.setUrl(<span class="string">"https://widget-page.heweather.net/h5/index.html?bg=1&amp;md=0123456&amp;lc=auto&amp;key=f1688db9422246fc969a6ba559075097"</span>);</span><br><span class="line">                    articleList.add(article);</span><br><span class="line">                    <span class="comment">// 设置图文消息个数</span></span><br><span class="line">                    newmsg.setArticleCount(articleList.size());</span><br><span class="line">                    <span class="comment">// 设置图文消息包含的图文集合</span></span><br><span class="line">                    newmsg.setArticles(articleList);</span><br><span class="line">                    <span class="comment">// 将图文消息对象转换成xml字符串</span></span><br><span class="line">                    respMessage = MessageUtil.newsMessageToXml(newmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"error......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> respMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试    <img data-src="../../../../assets/img/06215027.jpg" alt></p><blockquote><p>源码参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3pob3VtaW5wei93ZWNoYXRQdWJsaWNBY2NvdW50LQ==">https://github.com/zhouminpz/wechatPublicAccount-<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;微信公众平台服务器配置通过后，就能进行下面的开发啦&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先可以查看官方的说明文档：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0dldHRpbmdfU3RhcnRlZC9PdmVydmlldy5odG1s&quot;&gt;https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;普通消息的类型分为7种：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(三)快递信息查询</title>
    <link href="https://imokkkk.github.io/12221/"/>
    <id>https://imokkkk.github.io/12221/</id>
    <published>2021-05-08T13:19:59.220Z</published>
    <updated>2020-04-29T02:44:38.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-快递查询API"><a href="#1-快递查询API" class="headerlink" title="1.快递查询API"></a>1.快递查询API</h3><p>这里使用的是阿里云全国快递物流查询-快递查询接口:<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXQuYWxpeXVuLmNvbS9wcm9kdWN0cy81NjkyODAwNC9jbWFwaTAyMTg2My5odG1s">https://market.aliyun.com/products/56928004/cmapi021863.html<i class="fa fa-external-link-alt"></i></span></p><p>该接口支持只通过快递运单号查询物流信息, 不需要在额外设置参数. 该种方式95%能自动识别, 填写查询速度会更快, 已经满足一般开发的需求, 并能极大方便开发者的使用.</p><a id="more"></a><p><strong>请求参数说明</strong>    <img data-src="../../../../assets/img/215607.jpg" alt></p><p><strong>返回结果说明</strong>    <img data-src="../../../../assets/img/215818.jpg" alt></p><p>官方提供的示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String host = <span class="string">"https://wuliu.market.alicloudapi.com"</span>;</span><br><span class="line">        String path = <span class="string">"/kdi"</span>;</span><br><span class="line">        String method = <span class="string">"GET"</span>;</span><br><span class="line">        System.out.println(<span class="string">"请先替换成自己的AppCode"</span>);</span><br><span class="line">        String appcode = <span class="string">"833509fd73fe1124838xxxxxxxx"</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">"Authorization"</span>, <span class="string">"APPCODE "</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">"no"</span>, <span class="string">"462587770684"</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        querys.put(<span class="string">"type"</span>, <span class="string">"zto"</span>);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        <span class="comment">//JDK 1.8示例代码请在这里下载：  http://code.fegine.com/Tools.zip</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重要提示如下:</span></span><br><span class="line"><span class="comment">    * HttpUtils请从</span></span><br><span class="line"><span class="comment">    * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/HttpUtils.java</span></span><br><span class="line"><span class="comment">                * 或者直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/HttpUtils.zip</span></span><br><span class="line"><span class="comment">    * 下载</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 相应的依赖请参照</span></span><br><span class="line"><span class="comment">    * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml</span></span><br><span class="line"><span class="comment">                * 相关jar包（非pom）直接下载：</span></span><br><span class="line"><span class="comment">                * http://code.fegine.com/aliyun-jar.zip</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">                HttpResponse response = HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">    <span class="comment">//System.out.println(response.toString());如不输出json, 请打开这行代码，打印调试头部状态码。</span></span><br><span class="line">                <span class="comment">//状态码: 200 正常；400 URL无效；401 appCode错误； 403 次数用完； 500 API网管错误</span></span><br><span class="line">    <span class="comment">//获取response的body</span></span><br><span class="line">          System.out.println(EntityUtils.toString(response.getEntity())); <span class="comment">//输出json</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>正常返回示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"0"</span>,<span class="comment">/* status 0:正常查询 201:快递单号错误 203:快递公司不存在 204:快递公司识别失败 205:没有信息 207:该单号被限制，错误单号 */</span></span><br><span class="line"><span class="attr">"msg"</span>: <span class="string">"ok"</span>,</span><br><span class="line"><span class="attr">"result"</span>: &#123;</span><br><span class="line"><span class="attr">"number"</span>: <span class="string">"780098068058"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"zto"</span>,</span><br><span class="line"><span class="attr">"list"</span>: [&#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-09 11:59:26"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【石家庄市】快件已在【长安三部】 签收,签收人: 本人,感谢使用中通快递,期待再次为您服务!"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-09 09:03:10"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件已到达 【长安三部】（0311-85344265）,业务员 容晓光（13081105270） 正在第1次派件, 请保持电话畅通,并耐心等待"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-08 23:43:44"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件离开 【石家庄】 发往 【长安三部】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-08 21:00:44"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【石家庄市】 快件到达 【石家庄】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-07 01:38:45"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【广州市】 快件离开 【广州中心】 发往 【石家庄】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-07 01:36:53"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【广州市】 快件到达 【广州中心】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-07 00:40:57"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【广州市】 快件离开 【广州花都】 发往 【石家庄中转】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2018-03-07 00:01:55"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【广州市】 【广州花都】（020-37738523） 的 马溪 （18998345739） 已揽收"</span></span><br><span class="line">&#125;],</span><br><span class="line"><span class="attr">"deliverystatus"</span>: <span class="string">"3"</span>, <span class="comment">/* 0：快递收件(揽件)1.在途中 2.正在派件 3.已签收 4.派送失败 5.疑难件 6.退件签收  */</span></span><br><span class="line"><span class="attr">"issign"</span>: <span class="string">"1"</span>,                      <span class="comment">/*  1.是否签收                  */</span></span><br><span class="line"><span class="attr">"expName"</span>: <span class="string">"中通快递"</span>,              <span class="comment">/*  快递公司名称                */</span>       </span><br><span class="line"><span class="attr">"expSite"</span>: <span class="string">"www.zto.com"</span>,           <span class="comment">/*  快递公司官网                */</span></span><br><span class="line"><span class="attr">"expPhone"</span>: <span class="string">"95311"</span>,                <span class="comment">/*  快递公司电话                */</span></span><br><span class="line"><span class="attr">"courier"</span>: <span class="string">"容晓光"</span>,                <span class="comment">/*  快递员 或 快递站(没有则为空)*/</span></span><br><span class="line">                <span class="attr">"courierPhone"</span>:<span class="string">"13081105270"</span>,       <span class="comment">/*  快递员电话 (没有则为空)     */</span></span><br><span class="line">                <span class="attr">"updateTime"</span>:<span class="string">"2019-08-27 13:56:19"</span>, <span class="comment">/*  快递轨迹信息最新时间        */</span></span><br><span class="line">                <span class="attr">"takeTime"</span>:<span class="string">"2天20小时14分"</span>,         <span class="comment">/*  发货到收货消耗时长 (截止最新轨迹)  */</span></span><br><span class="line">                <span class="attr">"logo"</span>:<span class="string">"http://img3.fegine.com/express/zto.jpg"</span> <span class="comment">/* 快递公司LOGO */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失败返回示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"205"</span>,   <span class="comment">/* status状态码见产品详情 */</span></span><br><span class="line"><span class="attr">"msg"</span>: <span class="string">"没有信息"</span>,</span><br><span class="line"><span class="attr">"result"</span>: &#123;</span><br><span class="line"><span class="attr">"number"</span>: <span class="string">"1111ADECD1234"</span>,</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line"><span class="attr">"list"</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误码定义:</p><table><thead><tr><th align="left">错误码</th><th>错误信息</th><th>描述</th></tr></thead><tbody><tr><td align="left">201</td><td>快递单号错误</td><td>status：快递单号错误</td></tr><tr><td align="left">203</td><td>快递公司不存在</td><td>status：快递公司不存在</td></tr><tr><td align="left">204</td><td>快递公司识别失败</td><td>status：快递公司识别失败</td></tr><tr><td align="left">205</td><td>没有信息</td><td>status：没有信息</td></tr><tr><td align="left">207</td><td>该单号被限制，错误单号</td><td>status：该单号被限制，错误单号；一个单号对应多个快递公司，请求须指定快递公司</td></tr><tr><td align="left">0</td><td>正常</td><td>status：正常查询</td></tr></tbody></table><h3 id="2-核心代码"><a href="#2-核心代码" class="headerlink" title="2.核心代码"></a>2.核心代码</h3><p><strong>工具类:</strong></p><ol><li><p>HttpUtils(官方提供)</p><blockquote><p>下载地址 <span class="exturl" data-url="aHR0cDovL2NvZGUuZmVnaW5lLmNvbS9IdHRwVXRpbHMuemlw">http://code.fegine.com/HttpUtils.zip<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>TextUtil  用于判断输入发送的消息是否为英文字母+数字或纯数字(即符合快递运单号基本规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">DecText</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        Pattern p=Pattern.compile(<span class="string">"^[A-Za-z0-9]+$"</span>);    <span class="comment">//正则表达式</span></span><br><span class="line">        Matcher matcher = p.matcher(text);</span><br><span class="line">        <span class="keyword">return</span>  matcher.matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExpressUtil  调用API查询物流信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">QueryExpress</span><span class="params">(String num)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = <span class="string">"https://wuliu.market.alicloudapi.com"</span>;</span><br><span class="line">        String path = <span class="string">"/kdi"</span>;</span><br><span class="line">        String method = <span class="string">"GET"</span>;</span><br><span class="line">        String appcode = <span class="string">"06a9e928218141bxxxxxxx"</span>;  <span class="comment">// !!!替换填写自己的AppCode 在买家中心查看</span></span><br><span class="line">        Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        headers.put(<span class="string">"Authorization"</span>, <span class="string">"APPCODE "</span> + appcode); <span class="comment">//格式为:Authorization:APPCODE 83359fd73fe11248385f570e3c139xxx</span></span><br><span class="line">        Map&lt;String, String&gt; querys = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        querys.put(<span class="string">"no"</span>, num);<span class="comment">// !!! 请求参数</span></span><br><span class="line">        HttpResponse response = HttpUtils.doGet(host, path, method, headers, querys);</span><br><span class="line">        <span class="comment">//System.out.println(response.toString());</span></span><br><span class="line">        <span class="comment">//获取response的body</span></span><br><span class="line">        String str = EntityUtils.toString(response.getEntity());<span class="comment">//输出json</span></span><br><span class="line">        JSONObject jsonObject = JSONObject.parseObject(str);</span><br><span class="line">        <span class="comment">// 获取到key为result的值</span></span><br><span class="line">        String result = jsonObject.getString(<span class="string">"result"</span>);</span><br><span class="line">        jsonObject = JSONObject.parseObject(result);</span><br><span class="line">        <span class="comment">// 获取到key为list的值</span></span><br><span class="line">        String list = jsonObject.getString(<span class="string">"list"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时返回的数据为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:45:12"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何海桃】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:45:12"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件在【浙江嘉善公司】进行装车，扫描员【何海桃】，车签号【】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:42:13"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:42:13"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件在【浙江嘉善公司】进行装包，扫描员【何德文】，袋号【9005261902881】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:41:07"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 19:29:40"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"【浙江嘉善公司】的【公司称重（)】已收件，扫描员【公司出港1】"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"time"</span>: <span class="string">"2020-02-29 18:32:52"</span>,</span><br><span class="line"><span class="attr">"status"</span>: <span class="string">"快件由【浙江嘉善公司】发往【下一站浙江嘉兴转运中心】，扫描员【何德文】"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li></ol><p><strong>MsgService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TextUtil.DecText(content)==<span class="keyword">true</span>)&#123;</span><br><span class="line">                    String str = ExpressUtil.QueryExpress(content);</span><br><span class="line">                    List&lt;HashMap&gt; r = JSON.parseArray(str, HashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = r.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        System.out.println(r.get(i).get(<span class="string">"time"</span>) + <span class="string">":"</span> + r.get(i).get(<span class="string">"status"</span>));</span><br><span class="line">                        String string = r.get(i).get(<span class="string">"time"</span>) + <span class="string">":"</span> + r.get(i).get(<span class="string">"status"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                            stringBuilder.append(string);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            stringBuilder.append(string).append(<span class="string">"\n"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(stringBuilder);</span><br><span class="line">                    <span class="comment">//文本消息</span></span><br><span class="line">                    TextMessage text = <span class="keyword">new</span> TextMessage();</span><br><span class="line">                    text.setContent(stringBuilder+<span class="string">""</span>);</span><br><span class="line">                    text.setToUserName(fromUserName);</span><br><span class="line">                    text.setFromUserName(toUserName);</span><br><span class="line">                    text.setCreateTime(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">                    text.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">                    respMessage = MessageUtil.textMessageToXml(text);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="3-功能测试"><a href="#3-功能测试" class="headerlink" title="3.功能测试"></a>3.功能测试</h3><p><img data-src="../../../../assets/img/68078.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-快递查询API&quot;&gt;&lt;a href=&quot;#1-快递查询API&quot; class=&quot;headerlink&quot; title=&quot;1.快递查询API&quot;&gt;&lt;/a&gt;1.快递查询API&lt;/h3&gt;&lt;p&gt;这里使用的是阿里云全国快递物流查询-快递查询接口:&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tYXJrZXQuYWxpeXVuLmNvbS9wcm9kdWN0cy81NjkyODAwNC9jbWFwaTAyMTg2My5odG1s&quot;&gt;https://market.aliyun.com/products/56928004/cmapi021863.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该接口支持只通过快递运单号查询物流信息, 不需要在额外设置参数. 该种方式95%能自动识别, 填写查询速度会更快, 已经满足一般开发的需求, 并能极大方便开发者的使用.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发(一)开发者接入微信公众号</title>
    <link href="https://imokkkk.github.io/38103/"/>
    <id>https://imokkkk.github.io/38103/</id>
    <published>2021-05-08T13:19:59.218Z</published>
    <updated>2020-04-29T02:44:38.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="微信公众号开发-一-开发者接入微信公众号"><a href="#微信公众号开发-一-开发者接入微信公众号" class="headerlink" title="微信公众号开发(一)开发者接入微信公众号"></a>微信公众号开发(一)开发者接入微信公众号</h4><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>该文章基于<code>JDK1.8</code>  <code>springboot2.1.7.RELEASE</code>环境</p><p>实现开发者第一次接入微信公众号后台的需求</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h3><h4 id="2-1-进入微信公众平台注册账号"><a href="#2-1-进入微信公众平台注册账号" class="headerlink" title="2.1 进入微信公众平台注册账号"></a>2.1 进入微信公众平台注册账号</h4><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>个人用户建议注册订阅号</p><a id="more"></a><h4 id="2-2-内网穿透"><a href="#2-2-内网穿透" class="headerlink" title="2.2 内网穿透"></a>2.2 内网穿透</h4><p>因为要直接用内网本机开发调试，微信网页授权在回调时要访问本机，所以直接做个内网穿透，可以直接在外网访问到本机，做法如下：</p><ol><li><p>登录 <span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24v">https://natapp.cn/<i class="fa fa-external-link-alt"></i></span> （我用的natapp.cn，你可以用其他类似的，个人感觉这个不错）</p></li><li><p>购买隧道：购买后使用方式: </p><blockquote><p> 参考官方教程：<span class="exturl" data-url="aHR0cHM6Ly9uYXRhcHAuY24vYXJ0aWNsZS9uYXRhcHBfbmV3Ymll">https://natapp.cn/article/natapp_newbie<i class="fa fa-external-link-alt"></i></span> </p></blockquote></li></ol><p>使用后会得到natapp分配的网址，如 xxx.natapp.cn，这个地址就可以访问到开发本机。</p><p>   <img data-src="../../../../assets/img/142029.jpg" alt></p><ol start="3"><li><p>下载并配置config.ini, 运行natapp</p><p><img data-src="../../../../assets/img/142853.jpg" alt></p></li></ol><h3 id="3-接入认证成为开发者"><a href="#3-接入认证成为开发者" class="headerlink" title="3.接入认证成为开发者"></a>3.接入认证成为开发者</h3><blockquote><p>可参考微信官方开发文档 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0FjY2Vzc19PdmVydmlldy5odG1s">https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="3-1-填写服务器配置"><a href="#3-1-填写服务器配置" class="headerlink" title="3.1 填写服务器配置"></a>3.1 填写服务器配置</h4><p>登录微信公众号开发平台:<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==">https://mp.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span>    <code>开发</code>—<code>开发者工具</code>—<code>公众平台测试账号</code></p><p><img data-src="../../../../assets/img/144010.jpg" alt></p><ul><li>Tips:</li></ul><ol><li>微信公众号接口必须以<span class="exturl" data-url="aHR0cDovL3huLS1odHRwcy13bTZqLy/lvIDlpLTvvIzliIbliKvmlK/mjIE4MOerr+WPo+WSjDQ0M+err+WPo++8gQ==">http://或https://开头，分别支持80端口和443端口！<i class="fa fa-external-link-alt"></i></span></li><li>这里的url可以选择自己买的服务器地址，记得必须开放80端口去使用！ 或者使用内网映射外网工具生成一个域名地址供给你开发使用，此方法自行百度，如下就是其中一种使用~</li><li>目前提交是无法配置成功的, 不要着急</li></ol><h4 id="3-2-提交验证URL有效性"><a href="#3-2-提交验证URL有效性" class="headerlink" title="3.2 提交验证URL有效性"></a>3.2 提交验证URL有效性</h4><h5 id="3-2-1-搭建SpingBoot工程"><a href="#3-2-1-搭建SpingBoot工程" class="headerlink" title="3.2.1 搭建SpingBoot工程"></a>3.2.1 搭建SpingBoot工程</h5><p>项目结构</p><p><img data-src="../../../../assets/img/144403.jpg" alt></p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>weixin-java-mp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wechat:</span></span><br><span class="line">  <span class="attr">mpAppId:</span> <span class="string">xxxxxxxx</span><span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpAppSecret:</span> <span class="string">xxxxxx</span><span class="comment">#公众平台测试账号---测试号信息, 目前可以不填</span></span><br><span class="line">  <span class="attr">mpToken:</span> <span class="string">xxxxx</span><span class="comment">#与前面在公众平台测试账号---接口配置信息所填写保持一致</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span><span class="comment">#端口号</span></span><br></pre></td></tr></table></figure><p>sha1加密工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sha1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(<span class="string">"sha1"</span>);</span><br><span class="line">            <span class="comment">// 放入加密字符串</span></span><br><span class="line">            digest.update(str.getBytes());</span><br><span class="line">            <span class="comment">// 进行加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] digestMsg = digest.digest();</span><br><span class="line">            <span class="comment">// byte转换16进制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : digestMsg) &#123;</span><br><span class="line">                sb.append(String.format(<span class="string">"%02x"</span>, b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"wechat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatAccountConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mpAppId;</span><br><span class="line">    <span class="keyword">private</span> String mpAppSecret;</span><br><span class="line">    <span class="keyword">private</span> String mpToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/wechat/index"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WechatAccountConfig wechatAccountConfig;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理微信认证：验证服务器地址的有效性，get提交</span></span><br><span class="line"><span class="comment">     * signature: 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span></span><br><span class="line"><span class="comment">     * timestamp 时间戳</span></span><br><span class="line"><span class="comment">     * nonce: 随机数</span></span><br><span class="line"><span class="comment">     * echostr: 随机字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSignature</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"============= 处理微信认证 ==============="</span>);</span><br><span class="line">        <span class="comment">// 拿到微信的请求参数</span></span><br><span class="line">        String signature = request.getParameter(<span class="string">"signature"</span>);</span><br><span class="line">        String timestamp = request.getParameter(<span class="string">"timestamp"</span>);</span><br><span class="line">        String nonce = request.getParameter(<span class="string">"nonce"</span>);</span><br><span class="line">        String echostr = request.getParameter(<span class="string">"echostr"</span>);</span><br><span class="line">        <span class="comment">// TODO 这里的token是微信公众平台上自己所配的！</span></span><br><span class="line">        String token = wechatAccountConfig.getMpToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① 将token、timestamp、nonce三个参数进行字典序排序 b a d c h ==&gt;a b c d h</span></span><br><span class="line">        String[] strArr = &#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="comment">// 字典排序</span></span><br><span class="line">        Arrays.sort(strArr);</span><br><span class="line">        <span class="comment">// ② 将三个参数字符串拼接成一个字符串进行sha1加密</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strArr) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        String sha1Str = SecurityUtil.sha1(sb.toString());</span><br><span class="line">        <span class="comment">// ③ 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">        <span class="keyword">if</span> (sha1Str.equals(signature)) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，就是来自微信请求</span></span><br><span class="line">            <span class="comment">// 若确认此次GET请求来自微信服务器，原样返回echostr参数内容，则接入生效</span></span><br><span class="line">            response.getWriter().println(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeChatService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-测试"><a href="#3-2-2-测试" class="headerlink" title="3.2.2 测试"></a>3.2.2 测试</h5><ol><li>启动该SpringBoot项目</li><li>回到公众平台测试账号—接口配置信息, 点击提交即可</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;微信公众号开发-一-开发者接入微信公众号&quot;&gt;&lt;a href=&quot;#微信公众号开发-一-开发者接入微信公众号&quot; class=&quot;headerlink&quot; title=&quot;微信公众号开发(一)开发者接入微信公众号&quot;&gt;&lt;/a&gt;微信公众号开发(一)开发者接入微信公众号&lt;/h4&gt;&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;该文章基于&lt;code&gt;JDK1.8&lt;/code&gt;  &lt;code&gt;springboot2.1.7.RELEASE&lt;/code&gt;环境&lt;/p&gt;
&lt;p&gt;实现开发者第一次接入微信公众号后台的需求&lt;/p&gt;
&lt;h3 id=&quot;2-准备工作&quot;&gt;&lt;a href=&quot;#2-准备工作&quot; class=&quot;headerlink&quot; title=&quot;2.准备工作&quot;&gt;&lt;/a&gt;2.准备工作&lt;/h3&gt;&lt;h4 id=&quot;2-1-进入微信公众平台注册账号&quot;&gt;&lt;a href=&quot;#2-1-进入微信公众平台注册账号&quot; class=&quot;headerlink&quot; title=&quot;2.1 进入微信公众平台注册账号&quot;&gt;&lt;/a&gt;2.1 进入微信公众平台注册账号&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tLw==&quot;&gt;https://mp.weixin.qq.com/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人用户建议注册订阅号&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tool" scheme="https://imokkkk.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="https://imokkkk.github.io/14808/"/>
    <id>https://imokkkk.github.io/14808/</id>
    <published>2021-05-08T13:19:59.217Z</published>
    <updated>2020-04-29T02:44:38.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 中一般认为有23种设计模式, 下面介绍几种常见的设计模式。总体来说设计模式分为三大类： </p><ul><li>创建型模式, 共5五种：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、原型模式。 </li><li>结构型模式，共7种：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、代理模式、外观模式、桥接模式、组合模式、享元模式。 </li><li>行为型模式，共11种：策略模式、模板方法模式、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><a id="more"></a><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>所谓的单例设计指的是<strong>一个类只允许产生一个实例化对象。</strong><br>最好理解的一种设计模式，分为懒汉式和饿汉式。</p><p><strong>饿汉式</strong>: 构造方法私有化，外部无法产生新的实例化对象，只能通过static方法取得实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在类的内部可以访问私有结构，所以可以在类的内部产生实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * private 声明构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式</strong>: 当第一次去使用Singleton对象的时候才会为其产生实例化对象的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 还未实例化</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当多个线程并发执行 getInstance() 方法时，懒汉式会存在线程安全问题，所以用到了 synchronized 来实现线程的同步，当一个线程获得锁的时候其他线程就只能在外等待其执行完毕。而饿汉式则不存在线程安全的问题。</p><p><strong>适用场景：</strong><br>    单例模式<strong>只允许创建一个对象</strong>，因此<strong>节省内存，加快对象访问速度</strong>，因此<strong>对象需要被公用的场合适合使用</strong>，如多个模块使用同一个数据源连接对象等等。如：<br>    (1) 需要频繁实例化然后销毁的对象。<br>    (2) 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。<br>    (3) 有状态的工具类对象。<br>    (4) 频繁访问数据库或文件的对象。<br>以下都是单例模式的经典使用场景：<br>    (1) 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>    (2) 控制资源的情况下，方便资源之间的互相通信。如线程池等。 </p><h3 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2.观察者模式"></a>2.观察者模式</h3><p>一个对象(subject)被其他多个对象(observer)所依赖。则当一个对象变化时，发出通知，其它依赖该对象的对象都会收到通知，并且随着变化。 </p><h3 id="3-装饰者模式"><a href="#3-装饰者模式" class="headerlink" title="3.装饰者模式"></a>3.装饰者模式</h3><p>对已有的业务逻辑进一步的封装, 使其增加额外的功能, 要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p><p><strong>适用环境:</strong></p><p>​    (1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p><p>​    (2) 处理那些可以撤消的职责。</p><p>​    (3) 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h3><p>适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5.工厂模式"></a>5.工厂模式</h3><h4 id="5-1-简单工厂模式"><a href="#5-1-简单工厂模式" class="headerlink" title="5.1 简单工厂模式"></a>5.1 简单工厂模式</h4><p>简单工厂模式就是把<strong>对类的创建初始化全都交给一个工厂来执行，而用户不需要去关心创建的过程是什么样的</strong>，只用告诉工厂我想要什么就行了。而这种方法的缺点也很明显，<strong>违背了设计模式的开闭原则</strong>，因为如果你要增加工厂可以初始化的类的时候，你必须对工厂进行改建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz开始启动了。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Benz停车了。。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ford</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ford开始启动了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ford停车了。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCarInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Benz"</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> Benz();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Ford"</span>.equals(type)) &#123;</span><br><span class="line">            c = <span class="keyword">new</span> Ford();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car c = Factory.getCarInstance(<span class="string">"Benz"</span>);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.run();</span><br><span class="line">            c.stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"造不了这种汽车。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-工厂方法模式"><a href="#5-2-工厂方法模式" class="headerlink" title="5.2 工厂方法模式"></a>5.2 工厂方法模式</h4><p>设计一个工厂的接口，你想要什么东西，就写个类继承于这个工厂，这样就不用修改什么，直接添加就行了。就相当于，我这个工厂是用来生汽车的，而要什么品牌的汽车具体分到了每个车间，如果新多了一种品牌的汽车，直接新增一个车间就行了。那么问题又来了，如果想要生产大炮怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体产品角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"plane...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broom</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"broom....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Moveable <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroomFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Broom();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VehicleFactory factory = <span class="keyword">new</span> BroomFactory();</span><br><span class="line">        Moveable m = factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-抽象工厂模式"><a href="#5-3-抽象工厂模式" class="headerlink" title="5.3 抽象工厂模式"></a>5.3 抽象工厂模式</h4><p>与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Weapon <span class="title">createWeapon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Food <span class="title">createFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体工厂类，其中Food,Vehicle，Weapon是抽象类，</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">createFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> DefaultFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中一般认为有23种设计模式, 下面介绍几种常见的设计模式。总体来说设计模式分为三大类： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式, 共5五种：&lt;strong&gt;工厂方法模式&lt;/strong&gt;、&lt;strong&gt;抽象工厂模式&lt;/strong&gt;、&lt;strong&gt;单例模式&lt;/strong&gt;、建造者模式、原型模式。 &lt;/li&gt;
&lt;li&gt;结构型模式，共7种：&lt;strong&gt;适配器模式&lt;/strong&gt;、&lt;strong&gt;装饰器模式&lt;/strong&gt;、代理模式、外观模式、桥接模式、组合模式、享元模式。 &lt;/li&gt;
&lt;li&gt;行为型模式，共11种：策略模式、模板方法模式、&lt;strong&gt;观察者模式&lt;/strong&gt;、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="javase" scheme="https://imokkkk.github.io/tags/javase/"/>
    
  </entry>
  
  <entry>
    <title>四种常见的排序算法</title>
    <link href="https://imokkkk.github.io/23116/"/>
    <id>https://imokkkk.github.io/23116/</id>
    <published>2021-05-08T13:19:59.192Z</published>
    <updated>2020-04-29T02:44:38.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p><strong>思想:</strong> 每一趟将待排序序列中最大元素移到最后，剩下的为新的待排序序列, 重复上述步骤直到排完所有元素。这只是冒泡排序的一种, 当然也可以从后往前排</p><p><strong>平均时间复杂度:</strong> O(n^2)     </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p><strong>思想:</strong> 每一趟从待排序序列选择一个最小的元素放在已排好序列的末尾, 剩下的为待排序序列, 重复上述步骤直至完成排序</p><p><strong>平均时间复杂度:</strong> O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//默认第一个是最小的。</span></span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="comment">//记录最小的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="comment">//通过与后面的数据进行比较得出，最小值和下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后将最小值与本次循环的，开始值交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">        <span class="comment">//说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。每次只需要找无需的最小值，做替换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h3><p><strong>思想:</strong> 1. 默认从第二个数据开始比较。</p><p>　　  2.如果第二个数据比第一个小，则交换。然后在用第三个数据比较，如果比前面小，则插入（狡猾）。否则，退出循环</p><p>　　  3.说明：默认将第一数据看成有序列表，后面无序的列表循环每一个数据，如果比前面的数据小则插入（交换）。否则退出</p><p><strong>平均时间复杂度:</strong>  O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//外层循环，从第二个开始比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">//内存循环，与前面排好序的数据比较，如果后面的数据小于前面的则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不小于，说明插入完毕，退出内层循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p><strong>采用分治法的思想：</strong>首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。</p><p><strong>平均时间复杂度:</strong>  O(n*log(n))  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pivot:位索引;p_pos:轴值</span></span><br><span class="line">        <span class="keyword">int</span> pivot, p_pos, i, temp;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            p_pos = low;</span><br><span class="line">            pivot = arr[p_pos];</span><br><span class="line">            <span class="keyword">for</span> (i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">                    p_pos++;</span><br><span class="line">                    temp = arr[p_pos];</span><br><span class="line">                    arr[p_pos] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = arr[low];</span><br><span class="line">            arr[low] = arr[p_pos];</span><br><span class="line">            arr[p_pos] = temp;</span><br><span class="line">            <span class="comment">//分而治之</span></span><br><span class="line">            quickSort(arr, low, p_pos - <span class="number">1</span>);<span class="comment">//排序左半部分</span></span><br><span class="line">            quickSort(arr, p_pos + <span class="number">1</span>, high);<span class="comment">//排序右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">     d.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注-各排序时间复杂度"><a href="#注-各排序时间复杂度" class="headerlink" title="注: 各排序时间复杂度"></a>注: 各排序时间复杂度</h3><table><thead><tr><th>排序方法        平均情况        最好情况            最坏情况        辅助空间        稳定性</th></tr></thead><tbody><tr><td>冒泡排序         O(n^2)                  O(n)               O(n^2)            O(1)                稳定</td></tr><tr><td>选择排序         O(n^2)                 O(n^2)            O(n^2)            O(1)              不稳定</td></tr><tr><td>插入排序         O(n^2)                  O(n)               O(n^2)             O(1)                稳定</td></tr><tr><td>希尔排序O(n*log(n))~O(n^2)      O(n^1.3)       O(n^2)            O(1)              不稳定</td></tr><tr><td>堆排序          O(n<em>log(n))          O(n</em>log(n))       O(n*log(n))         O(1)              不稳定</td></tr><tr><td>归并排序       O(n<em>log(n))        O(n</em>log(n))       O(n*log(n))          O(n)                稳定</td></tr><tr><td>快速排序       O(n<em>log(n))        O(n</em>log(n))            O(n^2)             O(1)              不稳定</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.冒泡排序&quot;&gt;&lt;/a&gt;1.冒泡排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;思想:&lt;/strong&gt; 每一趟将待排序序列中最大元素移到最后，剩下的为新的待排序序列, 重复上述步骤直到排完所有元素。这只是冒泡排序的一种, 当然也可以从后往前排&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均时间复杂度:&lt;/strong&gt; O(n^2)     &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面试" scheme="https://imokkkk.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
