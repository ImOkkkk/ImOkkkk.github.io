<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="bUCDF5pEQe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66522575" charset="UTF-8"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tonymua.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.网络基础1.1 OSI七层模型: 物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层 ​       【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 　　【2】数据链路层：定">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试总结">
<meta property="og:url" content="http://tonymua.top/20365/index.html">
<meta property="og:site_name" content="ImOkkkk BLOG">
<meta property="og:description" content="1.网络基础1.1 OSI七层模型: 物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层 ​       【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 　　【2】数据链路层：定">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-29T02:44:38.133Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试总结">
<meta name="twitter:description" content="1.网络基础1.1 OSI七层模型: 物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层 ​       【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 　　【2】数据链路层：定">

<link rel="canonical" href="http://tonymua.top/20365/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java面试总结 | ImOkkkk BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ImOkkkk BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ImOkkkk BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">When they go low,we go high.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">56</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tonymua.top/20365/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../assets/img/head.jpg">
      <meta itemprop="name" content="ImOkkkk">
      <meta itemprop="description" content="Java开发, 后端开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ImOkkkk BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-08 21:19:59" itemprop="dateCreated datePublished" datetime="2021-05-08T21:19:59+08:00">2021-05-08</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1.网络基础"></a>1.网络基础</h3><p><strong>1.1 OSI七层模型</strong>: 物理层, 数据链路层, 网络层, 传输层, 会话层, 表示层, 应用层</p>
<p>​       【1】物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。</p>
<p>　　【2】数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p>
<a id="more"></a>

<p>　　【3】网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p>
<p>　　【4】传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。</p>
<p>　　【5】会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p>
<p>　　【6】表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</p>
<p>​        【7】应用层： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</p>
<p><img data-src="../../../../assets/img/5492424.jpg" alt></p>
<p><strong>1.2 TCP三次握手</strong></p>
<p>第一次握手：客户端发送SYN包（seq=x），进入SYN_SENT（同步发送）状态<br>第二次握手：服务器收到SYN包，确认SYN并发送ACK包（ack=x+1），同时发送一个SYN包（seq=y），即SYN+ACK包，进入SYN_RECV（同步接收）状态<br>第三次握手：客户端收到SYN+ACK包，发送确认包ACK(ack=y+1），发送完毕后，客户端和服务器进入ESTABLISHED（连接成功）状态</p>
<p><img data-src="../../../../assets/img/2310.png" alt></p>
<p><strong>需要三次握手的原因:为了防止失效的连接请求报文突然又传送到服务器产生错误</strong>。</p>
<p><strong>1.3 TCP四次挥手</strong></p>
<p>第一次挥手：客户端发送一个FIN包（seq=x），进入FIN_WAIT（结束等待）状态<br>第二次挥手：服务器收到FIN包，发回一个ACK包(ack=x+1)，进入CLOSE_WAIT（关闭等待）状态<br>第三次挥手：服务器关闭客户端的连接，并发送一个FIN包(seq=y)，进入LAST_ACK（最后确认）状态<br>第四次挥手：客户端发回ACK(ack=y+1)包确认，发送完毕后，连接断开</p>
<p><img data-src="../../../../assets/img/30403.png" alt></p>
<p><strong>需要四次挥手的原因:确保数据能够完全传输。</strong></p>
<p><strong>1.4 TCP 和 UDP的区别</strong></p>
<p>(1) TCP是一种<strong>面向连接的可靠</strong>传输协议，UDP是面向<strong>无连接的不可靠</strong>传输协议<br>(2) TCP支持报文传输，还支持字节流的传输。而UDP协议只支持传输报文 TCP:20个字节 UDP:8个字节<br>(3) TCP<strong>数据报格式比较复杂</strong>，传输过程数据<strong>不容易丢失和出错</strong>，而<strong>UDP数据报格式较为简单，容易丢失</strong><br>(4) TCP传输在<strong>接收端会进行重排</strong>，所以是<strong>有序</strong>的，UDP则不保证有序<br>(5) TCP速度<strong>慢</strong>，UDP速度<strong>快</strong><br>(6) TCP有流量控制和拥塞控制，而UDP没有</p>
<p><strong>1.5 Get与Post的区别</strong></p>
<p>(1) GET请求一般用于<strong>获取</strong>服务器上的资源，是<strong>幂等</strong>的。POST请求一般用于对服务器上资源进行<strong>更新</strong>，<strong>非幂等</strong>的（幂等即每次请求返回结果一样）<br>(2) GET请求<strong>没有请求体</strong>，请求参数跟是在URL后面的，所以使用GET请求时请求参数用户是可以直接看到的。POST请求有请求体，<strong>请求参数放在请求体</strong>，对用户是不可见的。相对来说POST请求比GET请求<strong>更安全</strong><br>(3) GET请求的<strong>参数长度有限制</strong>，最多只能有1024个字节, 这是因为URL长度有限导致的。POST请求的参数长度可以认为是<strong>无限制</strong>的</p>
<p><strong>1.6 forward 和 redirect的区别</strong></p>
<p>(1) forward为转发，进行forward操作后，请求<strong>URL不发生变化</strong>，并且会<strong>把请求的数据携带到下一个请求中</strong>。redirect是重定向，进行redirect操作后，请求<strong>URL是发生变化</strong>的<br>(2) forward是<strong>服务器内部请求转发</strong>，不可以请求到其它站点，redirect是服务器通知<strong>客户端重新请求</strong>，可以请求到其它站点<br>(3) forward速度<strong>快</strong>，redirect速度<strong>慢</strong></p>
<p><strong>1.7 cookie 和 session的区别</strong></p>
<p>(1) cookie由于把信息保存在<strong>客户端</strong>中。session把信息保存在<strong>服务器</strong>中<br>(2) cookie性能更高一点，速度较<strong>快</strong>，用户的信息存在各自的浏览器中，可以分担服务器的一部分存储工作。session速度较<strong>慢</strong>，所有用户的信息都存在服务器中，在高并发时必然影响服务器性能<br>(3) cookie有限制大小，在<strong>4K以内</strong>。session<strong>没有限制</strong><br>(4) cookie<strong>对用户是透明的，安全性低</strong>，不重要的或者可以公开的信息保存在cookie。session对用户是不可见的，<strong>安全性高</strong>，重要信息应该保存在session</p>
<p><strong>1.8 Http与Https的区别</strong></p>
<p>(1) https协议需要<strong>到CA申请证书</strong>，一般免费证书较少，因而<strong>需要一定费用</strong>。</p>
<p>(2) http是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>SSL加密传输协议</strong>。</p>
<p>(3) http和https使用的是完全不同的连接方式，用的端口也不一样，前者是<strong>80</strong>，后者是<strong>443</strong>。</p>
<p>(4) http的连接很简单，是<strong>无状态</strong>的。Https协议是由<strong>SSL+Http</strong>协议构建的可进行加密传输、身份认证的网络协议，比http协议<strong>安全</strong>。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p>
<p><strong>1.9 在浏览器地址键入URL, 按下回车之后经历的流程</strong></p>
<p>(1) DNS解析(查询缓存)</p>
<p>(2) TCP连接(三次握手)</p>
<p>(3) 发送Http请求</p>
<p>(4) 服务器处理请求并返回Http报文</p>
<p>(5) 浏览器解析渲染页面</p>
<p>(6) 连接结束(四次挥手)</p>
<p><strong>1.10 Http请求常见状态码</strong></p>
<p>(1) 200 OK，请求成功<br>(2) 404 Not Found，对应的URL上不存在资源<br>(3) 405 Method Not Allowed，请求不被允许，即请求方式错误<br>(4) 500 Internal Server Error，服务器内部错误，发现严重BUG，要及时修复</p>
<p><img data-src="../../../../assets/img/210504.jpg" alt></p>
<h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2.数据库"></a>2.数据库</h3><p><strong>2.1 索引的作用？和它的优点缺点是什么？</strong></p>
<p>​    索引就一种特殊的查询表，数据库的搜索可以利用它<strong>加速对数据的检索</strong>。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它<strong>减慢了数据录入的速度</strong>，同时也<strong>增加了数据库的尺寸大小</strong>。</p>
<p><strong>2.2 什么样的字段适合建索引?</strong></p>
<p>(1) 经常被查询的字段</p>
<p>(2) 不为空且字段值不重复</p>
<p>(3) 字段的值不经常被修改</p>
<p><strong>2.3 Hash索引与B+树索引</strong></p>
<p>时间复杂度分别为O(1)和O(logN)</p>
<p>(1) 这和业务场景有关。<strong>只选一个数据，hash更快（o(1)）</strong>。数据库中经常会<strong>选择N条</strong>如果使用hash索引那就是o(n)，这时候由于<strong>B+树索引有序(o(logn))</strong>，且叶子节点上有链表相连，它的查询效率比hash就快很多了</p>
<p>(2) 索引存储在硬盘上，一般来说索引本身很大，不能一次性全部存在内存中，B+树的设计可以<strong>允许数据分批加载</strong>，同时树的<strong>高度较低，查找效率高</strong></p>
<p>(3) 大家都知道硬盘的I/O速度相比内存来说非常慢，而索引是用于加快查询速度的，需要减少I/O操作</p>
<p><strong>2.4 密集索引与稀疏索引的区别</strong></p>
<p>(1) 密集索引文件中的每个搜索码值都对应一个索引值</p>
<p>(2) 稀疏索引文件只为索引码的某些值建立索引项</p>
<p>MyISAM:不管是主键索引，唯一键索引还是普通索引都是稀疏索引</p>
<p>InnoDB:若一个主键被定义, 该主键则作为密集索引; 若没有主键被定义, 该表的第一个唯一非空索引则作为密集索引; 若不满足以上条件, InnoDB内部会生成一个隐藏主键(密集索引); 若主键索引存储相关键位和其对应的主键值, 包含两次查找</p>
<p><strong>2.5 数据库优化方法</strong></p>
<p>(1) 选取最适用的字段属性</p>
<p>(2) 使用连接(JOIN)的方式来代替子查询</p>
<p>(3) 使用联合(UNION)来代替手动创建的临时表</p>
<p>(4) 事务</p>
<p><strong>2.6 数据库ACID的特性</strong></p>
<ul>
<li>原子性:指事务是一个不可分割的工作单位, 事务的操作要么都发生, 要么都不发生</li>
<li>一致性:指事务前后数据的完整性必须保持一致</li>
<li>隔离性:指多个用户并发访问数据库时, 一个用户的事务不能被其他用户的事务所干扰, 多个并发事务之间数据要相互隔离</li>
<li>持久性:指一个事务一旦提交, 它对数据库中数据的改变就是永久性的, 即便数据库发生故障也不应该对其有任何影响</li>
</ul>
<p><strong>2.7 悲观锁与乐观锁</strong></p>
<p><strong>悲观锁</strong>:当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制。</p>
<p><strong>乐观锁</strong>:乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p>
<p><strong>2.8 数据库的三范式</strong> </p>
<ul>
<li><p>第一范式:强调的是列的原子性, 即列不能够再分成其他几列</p>
</li>
<li><p>第二范式:首先是1NF, 另外包含两部分内容, 一是表必须有一个主键; 二是没有包含在主键中的列必须完全依赖于主键, 而不能只依赖于主键的一部分</p>
<p>在1NF基础上, 任何非主属性不依赖与其它非主属性(在2NF基础上消除传递依赖)</p>
</li>
<li><p>第三范式:第三范式是第二范式的一个子集, 即满足第三范式必须满足第二范式</p>
<p>首先是2NF, 另外非主键必须直接依赖于主键, 直接依赖于主键, 不能存在传递依赖. 即不能存在: 非主键列A依赖于非主键列B, 非主键列B依赖于主键的情况</p>
</li>
</ul>
<p><strong>2.9 什么是内联接、左外联接、右外联接？</strong></p>
<p>(1) 内联接（Inner Join）：匹配2张表中相关联的记录。<br>(2) 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。<br>(3) 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。</p>
<p><strong>2.10 数据库隔离级别</strong></p>
<p><strong>脏读</strong>（Read out of invalid data)：指事务A读到了事务B还没有提交的数据，但事务B又进行了回滚，产生了脏数据，事务A读取到的数据就是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p><strong>不可重复读</strong>（Unrepeatable Read)：指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据，即原始读取不可重复。这是由于在查询间隔，被另一个事务修改并提交了。与脏读的区别在于，脏读读取到另一个事务未提交的数据，而不可重复读是读取了前一事务提交的数据。</p>
<p><strong>幻读</strong>（Phantom Read)：指在一个事务的两次查询中数据笔数不一致，例如有一个事务A查询了几列(Row)数据，而另一个事务B却在此时插入了新的几列数据，先前的事务A在接下来的查询中，就会发现有几列数据是它先前所没有的，就好像发生幻觉一样。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted（读未提交）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Read committed（读提交）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>Repeatable read（可重复读）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>Serializable（序列化 ）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p><strong>2.11 MyISAM 和 InnoDB的区别是什么?</strong></p>
<p>(1) MyIASM是<strong>非事务安全</strong>的，而InnoDB是<strong>事务安全</strong>的</p>
<p><strong>(2)</strong> MyIASM<strong>锁的粒度</strong>是<strong>表级</strong>的，而InnoDB支持<strong>行级锁</strong>也支持<strong>表级锁</strong></p>
<p>(3) MyIASM支持<strong>全文</strong>类型索引，而InnoDB不支持全文索引</p>
<p>(4) MyIASM相对简单，<strong>效率上要优于InnoDB</strong>，小型应用可以考虑使用MyIASM</p>
<p>(5) MyIASM表保存成文件形式，<strong>跨平台</strong>使用更加方便</p>
<p>MyISAM适用场景:频繁执行全表count语句; 对数据进行增删改的频率不高, 查询非常频繁; 没有事务</p>
<p>InnoDB适用场景:数据库增删改查都相当频繁; 可靠性要求比较高，要求支持事务</p>
<p><img data-src="../../../../assets/img/415808.png" alt></p>
<p><img data-src="../../../../assets/img/30725.jpg" alt></p>
<p><img data-src="../../../../assets/img/301725.jpg" alt></p>
<p><strong>2.12 InnoDB可重复读隔离级别下如何避免幻读</strong></p>
<p><strong>表象：</strong>快照读（非阻塞读）—伪MVCC</p>
<p><strong>内在：</strong>next-key锁（行锁+gap锁）</p>
<p>对主键索引或者唯一索引会用Gap锁吗</p>
<ul>
<li>如果where条件全部命中，则不会用Gap锁，只会加记录锁</li>
<li>如果where条件部分命中或者全不命中，则会加Gap锁</li>
</ul>
<p><strong>2.13 关键语法</strong></p>
<p>(1) group by:满足”select子句中的列名必须为分组列或列函数”; 列函数对于group by 子句定义的每个组各返回一个结果</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select student_id,count(course_id),sum(score),course_id </span><br><span class="line"><span class="keyword">from</span> score </span><br><span class="line">group by student_id</span><br><span class="line"></span><br><span class="line">select s.student_id,stu.name,count(s.course_id),sum(s.score)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	score s,</span><br><span class="line">	student stu</span><br><span class="line">where s.<span class="attribute">student_id</span>=stu.student_id</span><br><span class="line">group by s.student_id</span><br></pre></td></tr></table></figure>

<p>(2) having:通常与group by子句一起使用; where过滤行, having过滤组; 出现在同一sql的顺序: where&gt;group by&gt;having</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student_id,<span class="keyword">avg</span>(score) </span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(score)&gt;<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> stu.student_id,stu.name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	student stu,</span><br><span class="line">	score s </span><br><span class="line"><span class="keyword">where</span> stu.student_id=s.student_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s.student_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*)&lt;(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course)</span><br></pre></td></tr></table></figure>

<h3 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3.Redis"></a>3.Redis</h3><p><strong>3.1 Memcache与Redis的区别</strong></p>
<ul>
<li>Memcache:代码层次类似hash, 支持简单数据类型, 不支持数据持久化存储, 不支持主从, 不支持分片</li>
<li>Redis:数据类型丰富, 支持数据磁盘持久化存储, 支持主从, 支持分片</li>
</ul>
<p><strong>3.2 为什么Redis能这么快</strong></p>
<p>(1) <strong>完全基于内存</strong>, 绝大部分请求是纯粹的内存操作, 执行效率高</p>
<p>(2) 数据结构简单, 对数据操作也简单</p>
<p>(3) <strong>采用单线程, 避免了频繁的上下文切换</strong>. 单线程也能处理高并发请求, 想多核也可以启动多实例</p>
<p>(4) <strong>采用了非阻塞I/O多路复用机制</strong></p>
<p><strong>3.3 Redis的数据类型</strong></p>
<ul>
<li>String:最基本的数据类型, 二进制安全</li>
<li>Hash:String元素组成的字典, 适用于存储对象</li>
<li>List:列表, 按照String元素插入顺序排序</li>
<li>Set:String元素组成的无序集合, 通过哈希表实现, 不允许重复</li>
<li>ZSet(Sorted Set):通过分数来为集合中的成员进行从小到大的排序</li>
</ul>
<p><img data-src="../../../../assets/img/2205963.png" alt></p>
<p><strong>3.4 从海量数据里查询某一固定前缀的key</strong></p>
<p>注意:摸清数据规模, 即问清楚数据边界</p>
<p>KEYS pattern：查找所有符合给定模式pattern的key</p>
<p>缺点：</p>
<ul>
<li>KEYS指令一次性返回所有匹配的key；</li>
<li>键的数量过大会使得服务卡顿；</li>
</ul>
<p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong></p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程；</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历；</li>
<li>不保证每次执行都返回某个给定数量的元素，支持模糊查询；</li>
<li>对于增量式迭代命令，一次返回的数量不可控，只能是大概率符合count参数；</li>
</ul>
<p><strong>3.5 何通过Redis实现分布式锁</strong></p>
<p>set key value[EX seconds] [PX milliseconds] [NX|XX]</p>
<ul>
<li>EX seconds：设置键的过期时间为second（秒）</li>
<li>PX milliseconds：设置键的过期时间为millisecond（毫秒）</li>
<li>NX：只在键不存在的时候，才对键进行设置操作，效果等同于setnx</li>
<li>XX：只在键已存在的时候，才对键进行设置操作</li>
<li>SET操作成功完成时，返回OK，否则则返回nil</li>
</ul>
<p>代码实现例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String result = redisService.set(lockKey,requestId,SET_IF_NOT_EXIST,</span><br><span class="line">                                 SET_WITH_WITH_EXPIRE_TIME,expireTime);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"OK"</span>.equals(result))&#123;</span><br><span class="line">    <span class="comment">//执行独占资源逻辑</span></span><br><span class="line">    doOcuppiedWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.6 如何应对缓存穿透和缓存雪崩问题</strong></p>
<ul>
<li>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</li>
</ul>
<p>(1) 利用<strong>互斥锁</strong>，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</p>
<p>(2) 采用<strong>异步更新策略</strong>，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</p>
<p>(3) 提供一个能迅速<strong>判断请求是否有效的拦截机制</strong>，比如，利用<strong>布隆过滤器</strong>，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<ul>
<li>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</li>
</ul>
<p>(1) 给缓存的<strong>失效时间</strong>，加上一个<strong>随机值</strong>，避免集体失效。</p>
<p>(2) 使用<strong>互斥锁</strong>，但是该方案吞吐量明显下降了。</p>
<p>(3) <strong>双缓存</strong>。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。</p>
<p><strong>3.7 Redis和数据库双写一致性问题</strong></p>
<p>​    一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。首先，采取正确更新策略，<strong>先更新数据库，再删缓存。</strong>其次，因为可能存在删除缓存失败的问题，提供一个<strong>补偿措施</strong>即可，例如利用<strong>消息队列</strong>。</p>
<p><strong>3.8  如何使用Redis做异步队列</strong></p>
<p>(1) 使用List作为队列，RPUSH生产消息，LPOP消费消息。</p>
<ul>
<li>缺点：没有等待队列中有值就直接消费；</li>
<li>弥补：可以在应用层引入Sleep机制去调用LPOP重试</li>
</ul>
<p>(2) BLPOP key [key …] timeout：阻塞直到队列有消息就能够返回或超时</p>
<ul>
<li>缺点：只能供一个消费者消费</li>
</ul>
<p>(3) pub/sub：主题发布-订阅模式</p>
<p>​    发送者（publish）发送消息，订阅者（subscribe）接收消息；订阅者可以订阅任意数量的频道（Topic）；</p>
<ul>
<li>缺点：消息的发布是无状态的，无法保证可达性，即发送完该消息无法保证该消息被接收到。若想解决该问题需要使用专业的消息队列，例如Kafka等。</li>
</ul>
<p><img data-src="../../../../assets/img/4553977.png" alt></p>
<p><strong>3.9 Redis如何做持久化</strong></p>
<p>(1) RDB(快照)持久化:保存某个时间点的全量数据快照</p>
<p>(2) AOF(Append-Only-File)持久化：保持写状态</p>
<p><strong>RDB和AOF的优缺点</strong>：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>RDB</td>
<td>全量数据快照，文件小，恢复快</td>
<td>无法保存最近一次快照之后的数据，会丢失这部分的数据</td>
</tr>
<tr>
<td>AOF</td>
<td>可读性高，适合保存增量数据，数据不易丢失</td>
<td>文件体积大，恢复时间长</td>
</tr>
</tbody></table>
<p>(3) RDB-AOF混合持久化方式</p>
<p>​    在Redis 4.0之后推出了混合持久化方式，而且作为默认的配置方式。先以RDB方式从管道写全量数据再使用AOF方式从管道追加。AOF文件先半段是RDB形式的全量数据，后半段是Redis命令形式的增量数据。</p>
<p>​    <strong>BGSAVE做镜像全量持久化，AOF做增量持久化。</strong>因为BGSAVE需要耗费大量的时间，不够实时，在停机的时候会造成大量数据丢失，这时需要AOF配合使用。在Redis实例重启的时候，会使用BGSAVE持久化文件重新构建内容，再使用AOF重放近期的操作指令，来实现完整恢复重启之前的状态。</p>
<p><strong>3.10 使用Pineline的好处</strong></p>
<p>(1) Pineline和Linux的管道类似；</p>
<p>(2) Redis基于请求/响应模型，单个请求处理需要一一应答；</p>
<p>(3) Pineline批量执行指令，节省了多次I/O往返的时间；</p>
<p>(4) 有顺序依赖的指令建议分批发送；</p>
<p><strong>3.11Redis的同步机制</strong></p>
<p> Redis使用主从同步</p>
<p>(1) 第一阶段:与master建立连接</p>
<p>(2) 第二阶段:向master发送同步请求(SYNC)</p>
<p>(3) 第三阶段:接受master发来的RDB数据</p>
<p>(4) 第四阶段:载入RDB文件</p>
<h3 id="4-Java底层知识-JVM"><a href="#4-Java底层知识-JVM" class="headerlink" title="4.Java底层知识: JVM"></a>4.Java底层知识: JVM</h3><p><strong>4.1 Java平台无关性如何实现?</strong></p>
<p><img data-src="../../../../assets/img/193843.jpg" alt></p>
<p>​    Java源码首先被编译成字节码, 再由不同平台进行解析, Java语言在不同的平台上运行时不需要进行重新编译, Java虚拟机在执行字节码的时候, 把字节码转换成具体平台上的机器指令</p>
<p><strong>4.2 JVM整体组成</strong></p>
<ul>
<li>类加载器(ClassLoader):依据特定格式, 加载class文件到内存</li>
<li>执行引擎(Execution Engine):对命令进行解析</li>
<li>本地库接口(Native Interface):融合不同开发语言的原生库为Java所用</li>
<li>运行时数据区(Runtime Data Area):JVM内存空间结构模型</li>
</ul>
<p><strong>4.3 类从编译到执行的过程</strong></p>
<p>(1) 编译器将Hello.java源文件编译成Hello.class字节码文件</p>
<p>(2) ClassLoder将字节码文件转为JVM中的Class<hello>对象</hello></p>
<p>(3) JVM利用Class<hello>对象实例化为Hello对象</hello></p>
<p><strong>4.4 反射的实现与作用</strong></p>
<p>​    Java语言编译之后会生成一个.class文件, 反射就是通过字节码文件找到某一个类, 类中的方法以及属性等. 反射的实现主要借助以下四个类: Class: 类的对象, Constructor:类的构造方法, Field:类中的属性对象, Method:类中的方法对象</p>
<p>作用:反射机制指的是程序在运行时能获取自身的信息. 在Java中, 只要给定类的名字, 那么就可以通过反射机制来获取类的所有信息</p>
<p><strong>4.5 类的装载过程</strong></p>
<p>(1) 加载:通过ClassLoader加载class文件字节码, 生成Class对象</p>
<p>(2) 链接: 校验:检查加载的class的正确性和安全性</p>
<p>​                准备:为类变量分配存储空间并设置类变量初始值</p>
<p>​                解析:JVM将常量池内的符号引用转换为直接引用</p>
<p>(3) 初始化:执行类变量赋值和静态代码块</p>
<p><strong>4.6 loadClass() 和 forName() 的区别</strong></p>
<p>类的装载方式有两种:(1) 隐式装载: 程序在运行过程中当碰到通过new等方式生成对象时, 隐式调用类装载器加载对应的类到JVM中; (2) 显式装载: 通过class.forname()等方法, 显示加载需要的类</p>
<p>使用 loadClass() 方法获得的 Class 对象<strong>只完成了类加载过程中的第一步：加载，后续的操作均未进行。</strong></p>
<p>使用 Class.forName() 方法获得 Class 对象是已经<strong>执行完初始化</strong>的了</p>
<p><strong>4.7 JVM运行时数据区组成(Java内存模型)</strong></p>
<ul>
<li><p>程序计数器(Program Counter Register):当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。</p>
</li>
<li><p>虚拟机栈(JVM Stacks):Java 方法执行的内存模型：存储局部变量表，操作数栈，动态链接，方法出口等信息。生命周期与线程相同。</p>
</li>
<li><p>本地方法栈(Native Method Stack):作用与虚拟机栈类似，不同点本地方法栈为 native 方法执行服务，虚拟机栈为虚拟机执行的 Java 方法服务。</p>
</li>
<li><p>堆(Heap):存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域。</p>
</li>
<li><p>方法区(Methed Area):用于存储虚拟机加载的类信息，常量，静态变量等数据。</p>
<p><strong>线程私有的</strong>:程序计数器, 虚拟机栈, 本地方法栈</p>
<p><strong>线程共享的</strong>:方法区, 堆, 直接内存</p>
</li>
</ul>
<p><strong>4.8 元空间(MetaSpace) 相比永久代(PermGen)的优势</strong></p>
<p>JDK8后去除了永久代</p>
<p><strong>区别:</strong>元空间使用本地内存, 而永久代使用的是JVM的内存</p>
<ul>
<li>字符串常量池存放在永久代中, 容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定, 给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其它JVM如Jrockit的集成</li>
</ul>
<p><strong>4.9 JVM三大性能调优参数-Xms -Xmx -Xss的含义</strong></p>
<ul>
<li>-Xss:规定了每个线程虚拟机栈(堆栈)的大小</li>
<li>-Xms:堆的初始值</li>
<li>-Xmx:堆能达到的最大值</li>
</ul>
<p><strong>4.10 Java内存模型中堆和栈的区别</strong></p>
<p>静态存储:编译时确定每个数据目标在运行时的存储空间需求</p>
<p>栈式存储:数据区需求在编译时未知, 运行时模块入口前确定</p>
<p>堆式存储:编译时或运行时模块入口都无法确定, 动态分配</p>
<p>联系:引用对象, 数组时, 栈定义变量保存堆中目标的首地址</p>
<p><strong>区别:</strong>(1) 管理方式: 栈自动释放, 堆需要GC</p>
<p>​         (2) 空间大小: 栈比堆小</p>
<p>​         (3) 碎片相关: 栈产生的碎片远小于堆</p>
<p>​         (4) 分配方式: 栈支持静态和动态分配, 而堆仅支持动态分配</p>
<p>​         (5) 效率: 栈的效率比堆高</p>
<h3 id="5-Java底层知识-GC相关"><a href="#5-Java底层知识-GC相关" class="headerlink" title="5.Java底层知识: GC相关"></a>5.Java底层知识: GC相关</h3><p><strong>5.1 垃圾回收算法</strong></p>
<ul>
<li><p><strong>标记-清除算法</strong></p>
<p>标记:从根集合进行扫描, 对存活的对象进行标记</p>
<p>清除:对堆内存从头到尾进行线性遍历, 回收不可达对象内存</p>
</li>
<li><p><strong>复制算法</strong></p>
<p>分为对象面和空闲面, 对象在对象面上创建, 存活的对象被从对象面复制到空闲面, 将对象面所有对象内存清除</p>
<p>特点:解决碎片化问题; 顺序分配内存, 简单高效; 适用于对象存活率低的场景</p>
</li>
<li><p><strong>标记-整理算法</strong></p>
<p>标记:从根集合进行扫描, 对存活的对象进行标记</p>
<p>清除:移动所有存活的对象, 且按照内存地址次序依次排列, 然后将末端内存地址以后的内存全部回收</p>
<p>特点:避免内存的不连续性; 不用设置两块内存互换; 适用于存活率高的场景</p>
</li>
<li><p><strong>分代收集算法</strong></p>
<p>垃圾回收算法的组合拳; <strong>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</strong></p>
<p>目的:提高JVM的回收效率</p>
<p><strong>年轻代</strong>:尽可能快速的收集掉那些声明周期短的对象</p>
<p>对象如何晋升到老年代: (1) 经历一定Minor次数依然存活的对象 (2) Survivor区中存放不下的对象 (3) 新生成的大对象(-XX:+PretenuerSizeThreshold)</p>
<p><strong>常用的调优参数:</strong>-XX:SurvivorRatio:Eden和Survivor的比值, 默认8:1    -XX:NewRatio:老年代和年轻代内存大小比例    -XX:MaxTenuringThreshoid:对象从年轻代晋升到老年代经过GC次数的最大阈值</p>
<p>老年代:存放生命周期较长的对象; 标记-清理算法, 标记-整理算法</p>
<p>Full GC比Minor GC慢, 但执行频率低</p>
<p>触发Full GC的条件:<strong>老年代空间不足;</strong> <strong>永久代空间不足(JDK8之前);</strong>CMS GC时出现promotion failed, concurrent mode failure;Minor GC晋升到老年代的平均大小大于老年代的剩余空间;<strong>调用System.gc();</strong>使用RMI来进行RPC或管理JDK应用, 每小时执行一次Full GC</p>
</li>
</ul>
<p><strong>5.2 常见垃圾收集器</strong></p>
<ul>
<li><p>年轻代常见的垃圾收集器</p>
<p>(1) Serial收集器(-XX:+UseSerialGC, 复制算法):单线程收集, 进行垃圾收集时, 必须暂停所有工作线程; 简单高效, Client模式下默认的年轻代收集器</p>
<p>(2) ParNew收集器(-XX:UseParNewGC, 复制算法):多线程收集, 特点和Serial收集器一样; 单核执行效率不如Serial, 在多核下执行才有优势</p>
<p>(3) Parallel Scavenge收集器(-XX:+UseParallelGC, 复制算法):比起关注用户线程停顿时间, 更关注系统的吞吐量; 在多核下执行才有优势, Server模式下默认的年轻代收集器</p>
</li>
<li><p>老年代常见的垃圾收集器</p>
<p>(1) Serial Old收集器(-XX:+UseSerialOldGC, 标记-整理算法):单线程收集, 进行垃圾收集时, 必须暂停所有工作线程; 简单高效, Client模式下默认的老年代收集器</p>
<p>(2) Parallel Old收集器(-XX:+UseParallelOldGC, 标记-整理算法):多线程, 吞吐量优先</p>
<p>(3) <strong>CMS收集器</strong>(-XX:+UseConcMarkSweepGC, 标记-清除算法):初始标记:stop-the-world; 并发标记:并发追溯标记, 程序不会停顿; 并发预清理:查找执行并发标记阶段从年轻代晋升到老年代的对象; 重新标记:暂停虚拟机, 扫描CMS堆中的剩余对象; 并发清理:清理垃圾对象, 程序不会停顿; 并发重置:重置CMS收集器的数据结构</p>
</li>
<li><p>G1收集器(-XX:+UseG1GC, 复制+标记-整理算法)</p>
<p>将整个Java堆内存划分成多个大小相等的Region; 年轻代和老年代不再物理隔离</p>
<p>特点:并行和并发; 分代收集; 空间整合; 可预测的停顿</p>
</li>
</ul>
<p><img data-src="../../../../assets/img/144731.jpg" alt></p>
<p>​        注:相互连线表示可以共存</p>
<p><strong>5.3 Object的finalize()方法的作用是否与C++的析构函数是否相同</strong></p>
<p>(1) 与C++的析构函数不同, 析构函数调用确定, 而它的是不确定的</p>
<p>(2) 将未被引用的对象放置于F-Queue队列</p>
<p>(3) 方法执行随时可能终止</p>
<p>(4) 给予对象最后一次重生的机会</p>
<p><strong>5.4 Java中的各种引用有什么用</strong></p>
<ul>
<li><p>强引用:最普遍的引用: Oject obj=new Object(); 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象; 通过将对象设置为null来弱化引用, 使其被回收</p>
</li>
<li><p>软引用:对象处于有用但非必须的状态; 只要当内存空间不足时, GC会回收该引用的对象的内存; 可以用来实现高速缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str= <span class="keyword">new</span> String(<span class="string">"abc"</span>);	<span class="comment">//强引用</span></span><br><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);	<span class="comment">//软引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>弱引用:非必须的对象, 比软引用更弱一些; GC时会被回收; 被回收的概率也不大,因为GC线程优先级比较低; 适用于引用偶尔被使用且不影响垃圾收集的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakRef=<span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚引用:不会决定对象的生命周期; 任何时候都可能被垃圾收集器回收; 跟踪对象被垃圾收集器回收的活动, 起哨兵作用; 必须和引用队列ReferenceQueue联合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">ReferenceQueue queue=<span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference ref=<span class="keyword">new</span> PhantomReference(str,queue);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>引用类型</th>
<th>被垃圾回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软引用</td>
<td>在内存不足时</td>
<td>对象缓存</td>
<td>内存不足时终止</td>
</tr>
<tr>
<td>弱引用</td>
<td>在垃圾回收时</td>
<td>对象缓存</td>
<td>GC运行后终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>Unknown</td>
<td>标记, 哨兵</td>
<td>Unknown</td>
</tr>
</tbody></table>
</li>
<li><p>引用队列:无实际存储结构, 存储逻辑依赖于内部节点之间的关系来表达; 存储关联的且被GC的软引用, 弱引用以及虚引用</p>
</li>
</ul>
<h3 id="6-多线程与并发"><a href="#6-多线程与并发" class="headerlink" title="6.多线程与并发"></a>6.多线程与并发</h3><p><strong>6.1 进程和线程的区别</strong></p>
<p>(1) 线程不能看做独立应用, 而进程可看作独立应用</p>
<p>(2) 进程有独立的地址空间, 相互不影响, 线程只是进程的不同执行路径</p>
<p>(3) 线程没有独立的地址空间, 多进程的程序比多线程程序健壮</p>
<p>(4) 进程的切换比线程的切换开销大</p>
<p>进程是执行着的应用程序, 而线程是进程内部的一个执行序列. 一个进程可以有多个线程, 线程又叫做轻量级进程</p>
<p><strong>6.2 Java进程和线程的关系</strong></p>
<p>(1) Java对操作系统提供的功能进行封装, 包括进程和线程</p>
<p>(2) 运行一个程序会产生一个进程, 进程包含至少一个线程</p>
<p>(3) 每个进程对应一个JVM实例, 多个线程共享JVM里的堆</p>
<p>(4) Java采用单线程编程模型, 程序会自动创建主线程</p>
<p>(5) 主线程可以创建子线程, 原则上要后于子线程</p>
<p><strong>6.3 Thread中的start和run方法的区别</strong></p>
<p>调用start()方法会创建一个新的子线程并启动, run()方法只是Thread的一个普通方法的调用</p>
<p><strong>6.4 Thread和Runable是什么关系</strong></p>
<p>Thread是实现了Runnable接口的类, 使得run支持多线程; 因类的单一继承, 推荐多使用Runnable接口</p>
<p><strong>6.5 如何给run()方法传参</strong></p>
<p>(1) 构造函数传参</p>
<p>(2) 成员变量传参</p>
<p>(3) 回调函数传参</p>
<p><strong>6.6 如何实现处理线程的返回值</strong></p>
<p>(1) 主线程等待法</p>
<p>(2) 使用Thread类的join()阻塞当前线程以等待子线程处理完毕</p>
<p>(3) 通过Callable接口实现: 通过FutureTask或者线程池获取</p>
<p><strong>6.7 线程的状态</strong></p>
<ul>
<li>新建(New):创建后尚未启动的线程的状态</li>
<li>运行(Runnable):包含Running和Ready</li>
<li>无限期等待(Waiting):不会被分配CPU执行时间, 需要显式的被唤醒</li>
<li>限期等待(Timed Waiting):在一定时间后会由系统自动的唤醒</li>
<li>阻塞(Blocked):等待获取排它锁</li>
<li>结束(Terminated):已终止线程的状态, 线程已经结束执行</li>
</ul>
<p><strong>6.8 sleep() 和 wait() 有什么区别</strong></p>
<ul>
<li><p>基本差别</p>
<p>sleep是Thread类的方法, wait是Object类中定义的方法</p>
<p>sleep()方法可以在任何地方使用, wait()方法只能在synchornized方法或synchronized块中使用</p>
</li>
<li><p>最主要的本质区别</p>
<p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是<strong>监控状态依然保持</strong>，到时后会<strong>自动恢复</strong>。<strong>调用sleep不会释放对象锁</strong>。<br>wait是Object类的方法，对此对象调用wait方法导致本线程<strong>放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象发出<strong>notify方法（或notifyAll）</strong>后本线程才进入<strong>对象锁定池</strong>准备获得对象锁进入运行状态。</p>
</li>
</ul>
<p><strong>6.9 notify()与notifyAll()的区别</strong></p>
<p>notifyAll会让所有等待池的线程全部进入锁池去竞争获取锁的机会; notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p>
<p><strong>6.10 sleep()和yield()有什么区别</strong></p>
<p>(1) sleep()方法给其他线程运行机会时<strong>不考虑线程的优先级</strong>，因此会给低优先级的线程以运行的机会；yield()方法只会给<strong>相同优先级或更高优先级</strong>的线程以运行的机会</p>
<p>(2) 线程执行sleep()方法后转入<strong>阻塞</strong>（blocked）状态，而执行yield()方法后转入<strong>就绪</strong>（ready）状态</p>
<p>(3) sleep()方法声明抛出<strong>InterruptedException</strong>，而yield()方法没有声明任何异常</p>
<p>(4) sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的<strong>可移植性</strong></p>
<p><strong>6.11 如何中断线程</strong></p>
<p>调用interupt(), 通知线程应该中断了(<strong>需要被调用的线程配合中断</strong>)</p>
<p>(1) 如果线程处于被阻塞状态, 那么线程将立即退出被阻塞状态, 并抛出一个InterruptedException异常(在正常运行任务时, 经常检查本线程的中断标志位, 如果被设置了中断标志就自行停止线程)</p>
<p>(2) 如果线程处于正常活动状态, 那么会将该线程的中断标志设置为true. 被设置中断标志的线程将继续正常运行, 不受影响</p>
<p><strong>6.12 线程安全问题</strong></p>
<p><strong>主要诱因:</strong>存在共享资源(也称临界资源); 存在多条线程共同操作这些共享数据</p>
<p><strong>解决方法:</strong>同一时刻有且只要一个线程在操作共享数据, 其他线程必须等到该线程处理完数据后再对共享数据进行操作</p>
<p><strong>6.13 如何保证线程安全？</strong></p>
<p>(1) 通过合理的时间调度，避开共享资源的存取冲突</p>
<p>(2) 在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源</p>
<p><strong>6.14 如何确保N个线程可以访问N个资源同时又不导致死锁</strong></p>
<p>指定获取锁的顺序, 并强制线程按照指定的顺序获取锁</p>
<p><img data-src="../../../../assets/img/101106.jpg" alt></p>
<p><strong>6.15 synchronized和ReentrantLock(再入锁)的区别</strong></p>
<p>(1) synchronized是关键字, ReentrantLock是类</p>
<p>(2) ReentrantLock可以对获取锁的等待时间进行设置, 避免死锁</p>
<p>(3) ReentrantLock可以获取各种锁的信息</p>
<p>(4) ReentrantLock可以灵活的实现多路通知</p>
<p>主要相同点:Lock能完成synchronized所实现的所有功能</p>
<p>主要不同点:Lock有比synchronized更精确的线程语义和更好的性能(竞争激烈的情况下); synchronized会自动释放锁, Lock需要手动在finally从句中释放</p>
<p><strong>6.16 volatile和synchronized的区别</strong></p>
<p>(1) volatile本质是在告诉JVM当前变量在寄存器(工作内存)中的值是不确定的, 需要从主内存中读取; synchronized则是锁定当前变量, 只有当前线程可以访问该变量, 其它线程被阻塞住直到该线程完成变量操作为止</p>
<p>(2) volatile仅能使用在变量级别; synchronized则可以使用在变量, 方法和类级别</p>
<p>(3) volatile仅能实现变量的修改可见性, 不能保证原子性; 而synchronized则可以保证变量修改的可见性和原子性</p>
<p>(4) volatile不会造成线程的阻塞; synchronized可能会造成线程阻塞</p>
<p>(5)volatile标记的变量不会被编译器优化; synchronized标记的变量可以被编译器优化</p>
<p><strong>6.17 为什么使用线程池</strong></p>
<p>(1) 降低资源消耗</p>
<p>(2) 提高响应速度</p>
<p>(3) 提高线程的可管理性</p>
<p><strong>6.18 Java线程池</strong></p>
<p><strong>ThreadPoolExecutor的构造函数</strong></p>
<ul>
<li>corePoolSize: 核心线程数量</li>
<li>maximumPoolSize: 线程不够用时能够创建的最大线程数</li>
<li>workQueue: 任务等待队列</li>
<li>keepAliveTime: 抢占的顺序不一定, 随机 </li>
<li>threadFactory: 创建线程, Executeors.defaultThreadFactory()</li>
</ul>
<p><img data-src="../../../../assets/img/200520.jpg" alt></p>
<p><strong>线程池的状态</strong></p>
<ul>
<li>RUNNING: 能接受新提交的任务, 并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN: 不再接受新提交的任务, 但可以处理存量任务</li>
<li>STOP: 不再接受新提交的任务, 也不处理存量任务</li>
<li>TIDYING: 所有的任务都已终止</li>
<li>TERMINATED: terminated()方法执行完后进入该状态</li>
</ul>
<p><img data-src="../../../../assets/img/68251a.jpg" alt></p>
<p><strong>线程池的大小如何选定</strong></p>
<ul>
<li>CPU密集型: 线程数=核数或核数+1</li>
<li>I/O密集型: 线程数=CPU核数*(1+平均等待时间/平均工作时间)</li>
</ul>
<p><strong>6.19 Java中有几种线程池</strong></p>
<ul>
<li>newFixedThreadPool创建一个指定工作线程数量的线程池, 每当提交一个任务就创建一个工作线程, 如果工作线程数量达到线程池初始的最大数, 则将提交的任务存入到池队列中</li>
<li>newCachedThreadPool创建一个可缓存的线程池. 特点:(1) 工作线程的创建数量几乎没有限制(其实也是有限制的, 数目为Interger.MAX_VALUE), 这样可灵活的往线程池中添加线程 (2) 如果长时间没有往线程中提交任务, 即如果工作线程空闲了指定的时间(默认1分钟), 则改工作线程将自动终止. 终止后, 如果你又提交了新的任务, 则线程池重新创建一个工作线程</li>
<li>newSingleThreadExecutor创建一个单线程化的Executor, 即只创建唯一的工作者线程来执行任务, 如果这个线程异常结束, 会有另一个来取代它, 保证顺序执行</li>
<li>newScheduThreadPool创建一个定长的线程池, 而且支持定时的以及周期性的任务执行, 类似于Timer</li>
</ul>
<h3 id="7-异常与常用类库"><a href="#7-异常与常用类库" class="headerlink" title="7.异常与常用类库"></a>7.异常与常用类库</h3><p><strong>7.1 Error和Exception的区别</strong></p>
<p><img data-src="../../../../assets/img/203934.jpg" alt></p>
<p>Error:程序无法处理的系统错误, 编译器不做检查; Exception:程序可以处理的异常, 捕获后可能恢复</p>
<p>前者是程序无法处理的错误, 后者是可以处理的异常</p>
<p>RuntimeException:不可预知的, 程序应当自行避免; 非RuntimeException:可预知的, 从编译器校验的异常</p>
<p><strong>7.2 常见Error以及Exception</strong></p>
<p>RuntimeException:(1) NullPointerException-空指针引用异常    (2) ClassCastException-类型强制转换异常    (3) IllegalArgumentException-传递非法参数异常    (4) IndexOutOfBoundsException-下标越界异常    (5) NumberFormatException-数字格式异常 </p>
<p>非RuntimeException:(1) ClassNotFoundException-找不到指定class的异常    (2) IOException-IO操作异常</p>
<p>Error:(1) NoClassDefFoundError-找不到class定义的异常    (2)StackoverflowError-深递归导致栈被耗尽而抛出的异常    (3)OutOfMemoryError-内存溢出异常</p>
<p><strong>7.3 Java异常的处理原则</strong></p>
<ul>
<li>具体明确: 抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因</li>
<li>提早抛出: 应尽可能早的发现并抛出异常, 便于精确定位问题</li>
<li>延迟捕获: 异常的捕获和处理应尽可能延迟, 让掌握更多信息的作用域来处理异常</li>
</ul>
<p><img data-src="../../../../assets/img/215009.jpg" alt></p>
<p><strong>7.4 Collection体系</strong></p>
<p><img data-src="../../../../assets/img/215731.jpg" alt></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>请作者喝瓶肥宅快乐水</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/img/vxpay.jpg" alt="ImOkkkk 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/img/alipay.jpg" alt="ImOkkkk 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/面试/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/multithreading/" rel="prev" title="Java并发编程">
      <i class="fa fa-chevron-left"></i> Java并发编程
    </a></div>
      <div class="post-nav-item">
    <a href="/jvmAndgc/" rel="next" title="JVM&垃圾回收">
      JVM&垃圾回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-网络基础"><span class="nav-text">1.网络基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数据库"><span class="nav-text">2.数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Redis"><span class="nav-text">3.Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Java底层知识-JVM"><span class="nav-text">4.Java底层知识: JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Java底层知识-GC相关"><span class="nav-text">5.Java底层知识: GC相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-多线程与并发"><span class="nav-text">6.多线程与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-异常与常用类库"><span class="nav-text">7.异常与常用类库</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ImOkkkk"
      src="/../assets/img/head.jpg">
  <p class="site-author-name" itemprop="name">ImOkkkk</p>
  <div class="site-description" itemprop="description">Java开发, 后端开发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vNjA2MjE3MjIyNC8=" title="Weibo → https://weibo.com/6062172224/"><i class="fab fa-weibo fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvbnltdWE=" title="GitHub → https://github.com/tonymua"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx3eTA4YUBmb3htYWlsLmNvbQ==" title="E-Mail → mailto:lwy08a@foxmail.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <a href="https://beian.miit.gov.cn/" target="_blank">皖ICP备19022525号-1</a>
  <div class="beian"><span class="exturl" data-url="aHR0cDovL3d3dy5iZWlhbi5taWl0Lmdvdi5jbg==">皖ICP备19022525号-1 </span>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImOkkkk</span>
</div><script color="0,137,108" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://tonymua.top/20365/',]
      });
      });
  </script>

</body>
</html>
