<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="code-wyV34cCXc4" />
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="bUCDF5pEQe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=66522575" charset="UTF-8"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"imokkkk.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Docker原理 Chroot 改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。  NameSpace 对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。  Cgroup 限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。">
<meta name="keywords" content="Docker,Kubernetes,云原生">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker+Kubernetes">
<meta property="og:url" content="https://imokkkk.github.io/docker/index.html">
<meta property="og:site_name" content="ImOkkkk BLOG">
<meta property="og:description" content="Docker原理 Chroot 改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。  NameSpace 对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。  Cgroup 限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-09-09T08:54:26.016Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker+Kubernetes">
<meta name="twitter:description" content="Docker原理 Chroot 改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。  NameSpace 对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。  Cgroup 限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。">

<link rel="canonical" href="https://imokkkk.github.io/docker/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Docker+Kubernetes | ImOkkkk BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="ImOkkkk BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ImOkkkk BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">When they go low,we go high.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">36</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">41</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://imokkkk.github.io/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../assets/img/head.jpg">
      <meta itemprop="name" content="ImOkkkk">
      <meta itemprop="description" content="Java开发, 后端开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ImOkkkk BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker+Kubernetes
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 14:22:51" itemprop="dateCreated datePublished" datetime="2022-06-20T14:22:51+08:00">2022-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云原生/" itemprop="url" rel="index"><span itemprop="name">云原生</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li><p><strong>Chroot</strong></p>
<p>改变进程及其子进程外显的根目录，chroot设置根目录的程序，不能够对这个之外的文件进行访问，外部也不能读取、更改它的内容。</p>
</li>
<li><p><strong>NameSpace</strong></p>
<p>对内核资源进行隔离，容器中的进程只可以访问当前容器命名空间的资源(进程ID，主机名、用户、文件名等)。</p>
</li>
<li><p><strong>Cgroup</strong></p>
<p>限制隔离进程的资源使用(CPU、内存、磁盘、网络等)。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="容器的5种状态"><a href="#容器的5种状态" class="headerlink" title="容器的5种状态"></a>容器的5种状态</h3><p>初建、运行、停止、暂停、删除。</p>
<p><img data-src="../assets/img/image-20220413161321391.png" alt></p>
<h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>与服务端交互：</p>
<ol>
<li>Docker命令</li>
<li>REST API</li>
<li>SDK</li>
</ol>
<h3 id="Docker服务端"><a href="#Docker服务端" class="headerlink" title="Docker服务端"></a>Docker服务端</h3><p>dockerd(Docker Daemon)：负责响应和处理来自客户端的请求，然后将其转化为具体操作。</p>
<p>containerd：通过containerd-shim启动并管理runC</p>
<p>runC：用来运行容器的轻量级工具</p>
<h3 id="docker-attach-exec"><a href="#docker-attach-exec" class="headerlink" title="docker attach/exec"></a>docker attach/exec</h3><p>docker attach：给一个正在运行的容器分配了stdin、stdout、stderr，所有终端窗口同(显示一样的内容；同时阻塞)，使用exit退出时原容器也会退出，可以使用Ctrl+C。</p>
<p>docker exec：相当于fork了一个和容器相同NameSpace的进程。</p>
<h2 id="镜像与容器的区别"><a href="#镜像与容器的区别" class="headerlink" title="镜像与容器的区别"></a>镜像与容器的区别</h2><p>docker image inspect &lt; image &gt; 查看镜像分层</p>
<p><strong>镜像中的层都是只读的，容器在镜像上多了一个读写层。</strong></p>
<p>docker commit 可以基于运行时的容器生成新的镜像，将读写层数据写到新的镜像中。</p>
<p><strong>所有写入或修改运行时容器的数据都存储在读写层，当容器停止运行时，读写层的数据也会同时删除掉。</strong></p>
<p>写时复制：因为镜像层的数据是只读的，所以我们运行同一个镜像的多个容器副本时，可以共享镜像存储层，节省磁盘。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p><img data-src="../assets/img/image-20220429133157063.png" alt></p>
<p>将镜像层(只读)组织成多个目录(branch)，运行时容器文件作为一层容器层(读写)覆盖在镜像层之上，最后通过联合挂载技术呈现。</p>
<p><strong>联合挂载：</strong>同一个挂载点同时挂载多个文件系统，将挂载点的源目录与挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层文件和目录。</p>
<h3 id="OverlayFS"><a href="#OverlayFS" class="headerlink" title="OverlayFS"></a>OverlayFS</h3><p><img data-src="../assets/img/image-20220429141408096.png" alt></p>
<p>将镜像层(只读)称为lowerdir，容器层(读写)称为upperdir，最后联合挂载为mergedir，在容器上的改动，在upperdir、mergeddir中都会体现。</p>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><h3 id="docker0网桥"><a href="#docker0网桥" class="headerlink" title="docker0网桥"></a>docker0网桥</h3><p><img data-src="../assets/img/image-20220524114018238.png" alt></p>
<p>启动Docker Daemon进程之后，会多出一个docker0的网卡，连接容器网段和宿主机网段，IP: 172.17.0.1/16(可修改)。</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>Docker会在宿主机系统上增加一些iptables规则，用来管理Docker容器与容器之间及外界的通信。</p>
<ul>
<li>外界访问Docker是通过iptables做DNAT实现的，DNAT将SNAT中的Source转成Destiantion，表示目的地址转换。</li>
</ul>
<h2 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h2><ul>
<li><p><strong>bridge模式</strong></p>
<p>默认网络模式，所有Docker容器连接到docker0网桥或自定义网桥上，所有的Docker容器处于同一个子网。</p>
</li>
<li><p><strong>host模式</strong></p>
<p>Docker容器和宿主机使用同一个网络协议栈(同一个network namespace)，和宿主机共享网卡、IP、端口等信息。性能更好，但没做网络隔离。</p>
</li>
<li><p><strong>overlay模式</strong></p>
<p>在多个Docker Daemon之间创建一个分布式网络，允许容器之间加密通讯，需要处理容器之间和主机之间的网络包。</p>
</li>
<li><p>macvlan模式</p>
<p>网卡虚拟化技术，可以在同一个物理网卡上虚拟出多个网卡，通过不同的Mac地址在数据链路层进行网络数据的转发。</p>
</li>
<li><p>none模式</p>
<p>除了自带的IO网卡(loopback 127.0.0.1)外没有其它任何网卡、IP等信息，需要自己添加网卡。</p>
</li>
</ul>
<h2 id="容器间网络通信：link"><a href="#容器间网络通信：link" class="headerlink" title="容器间网络通信：link"></a>容器间网络通信：link</h2><p>将新创建出来的Docker容器与已有的容器之间创建一个安全通道来做数据交互。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 --name mysql mysql:latest</span><br><span class="line">docker run --name busybox --link mysql:mysql busybox:latest </span><br><span class="line"><span class="meta">#</span><span class="bash">--link name or id:<span class="built_in">alias</span>，第一个参数是目标容器的名字或者ID，第二个<span class="built_in">alias</span>相当于在busybox Docker容器中访问MySQL Docker容器的host。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>host文件修改</p>
<p>容器/etc/hosts文件中多了一条<code>172.17.0.2 mysql e47e603ffb17</code>记录</p>
</li>
<li><p>环境变量</p>
<p>通过link建立连接之后，会在接收容器额外设置一些环境变量保存源容器的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ # env | grep MYSQL</span><br><span class="line">MYSQL_PORT_33060_TCP=tcp://172.17.0.2:33060</span><br><span class="line">MYSQL_ENV_MYSQL_MAJOR=8.0</span><br><span class="line">MYSQL_PORT_3306_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_ENV_MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">MYSQL_ENV_GOSU_VERSION=1.7</span><br><span class="line">MYSQL_PORT_3306_TCP_PORT=3306</span><br><span class="line">MYSQL_PORT_3306_TCP_PROTO=tcp</span><br><span class="line">MYSQL_PORT_33060_TCP_ADDR=172.17.0.2</span><br><span class="line">MYSQL_PORT=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_3306_TCP=tcp://172.17.0.2:3306</span><br><span class="line">MYSQL_PORT_33060_TCP_PORT=33060</span><br><span class="line">MYSQL_ENV_MYSQL_VERSION=8.0.19-1debian9</span><br><span class="line">MYSQL_PORT_33060_TCP_PROTO=tcp</span><br><span class="line">MYSQL_NAME=/busybox/mysql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Docker数据存储模式"><a href="#Docker数据存储模式" class="headerlink" title="Docker数据存储模式"></a>Docker数据存储模式</h2><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>Volume会把文件存储在宿主机的指定位置(Linux：/var/lib/docker/volumes/)，这些文件只能由Docker进程修改。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-4-5-centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test -v my-vol:/data nginx:latest</span><br><span class="line">[root@VM-4-5-centos ~]# docker run -d --name test --mount type=volume,src=myvol,target=/data nginx:latest</span><br></pre></td></tr></table></figure>

<p>-v/–volume：volume的名字(匿名可忽略):容器内的挂载点</p>
<p>type=volume,src=&lt; VOLUME-NAME&gt;,dst=&lt; CONTAINER-PATH&gt;,volume-driver=local</p>
<h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>可以将文件存储到宿主机的任意位置，而且别的应用程序也可以修改。</p>
<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>只支持linux，只会将数据存储在宿主机的内存中，并不会落盘，容器停止，数据就会被清除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --name test --mount type=tmpfs,target=/data,tmpfs-mode=1770 nginx:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>tmpfs-size：指定tmpfs的大小，默认不受限制，单位byte</li>
<li>tmpfs-mode：Linux系统的文件模式，默认1777，任何用户都可以写</li>
</ul>
<h2 id="为什么说Docker是单进程模型？"><a href="#为什么说Docker是单进程模型？" class="headerlink" title="为什么说Docker是单进程模型？"></a>为什么说Docker是单进程模型？</h2><p>不管是在容器还是虚拟机中都有一个1号进程(容器：entrypoint启动进程；虚拟机：systemd进程)，然后其它进程都是1号进程的子进程，或子进程的子进程等等。</p>
<h3 id="回收子进程资源"><a href="#回收子进程资源" class="headerlink" title="回收子进程资源"></a>回收子进程资源</h3><ol>
<li>父进程通过系统调用wait()或waitpid()来等待子进程结束，从而回收子进程的资源；</li>
<li>异步：子进程结束之后向父进程发送SIGCCHILD信号，基于此父进程注册一个SIGCHILD信号的处理函数进行子进程的资源回收。</li>
</ol>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，并且父进程没有对子进程残留的资源进行回收，就会产生僵尸进程。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程先于子进程退出，产生孤儿进程。虚拟机会将孤儿进程的父进程设置为1号进程即systemd进程，然后由systemd对孤儿进程的资源进行回收，而容器的1号进程为entrypoint启动进程，无法处理。</p>
<p><strong>如何避免？</strong></p>
<p>Kubernetes：可以将多个容器编排到一个pod里，共享同一个Linux NameSpace，本质是k8s实例化出一个pause镜像，其它容器加入这个镜像实例化出的NameSpace实现NameSpace共享。</p>
<p>pod中的1号进程变成了pause，其它容器的entrypoint变成了1号进程的子进程。</p>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>用于容器化应用的<strong>容器化应用、自动化部署、扩缩容、管理。</strong></p>
<p><strong>核心功能</strong></p>
<ul>
<li>服务发现和负载均衡</li>
<li>自动装箱</li>
<li>自动修复</li>
<li>存储编排</li>
<li>应用自动发布与回滚</li>
<li>配置管理</li>
<li>批任务执行</li>
<li>弹性伸缩</li>
</ul>
<p><strong>核心概念</strong></p>
<ul>
<li><p>Pod</p>
<p>Kubernetes中的最小调度单元，一个Pod可以由多个容器组成，同一个Pod内容器之间没有进行隔离。容器和Pod间的关系，类似进程组和进程。</p>
</li>
<li><p>Deployment</p>
<p>启动多个应用实例时(启动多个相同的Pod)，Deployment可以理解为一组Pod的管理器。</p>
</li>
<li><p>Service</p>
<p>服务发现和负载均衡是通过Service来做的，Service可以关联一组Pod，Service对象创建成功之后会映射到一个域名和固定的IP，只需要访问这种情况就可以通过这个固定的IP就可以访问后端的Pod中运行的应用了。</p>
</li>
<li><p>Configmap</p>
<p>创建和管理不同环境的配置，将配置和应用解耦。</p>
</li>
<li><p>NameSpace</p>
<p>资源的逻辑空间，包括鉴权、资源管理等。Kubernetes中的每个资源，如Pod、Depolement、Service等都有一个NameSpace属主，不同NameSpace的资源不能跨NameSpace访问，NameSpace内的资源要求命令唯一性。</p>
</li>
</ul>
<h2 id="资源隔离：NameSpace"><a href="#资源隔离：NameSpace" class="headerlink" title="资源隔离：NameSpace"></a>资源隔离：NameSpace</h2><p>同一个namesace内的资源必须保证名字唯一，不同namespace内的资源可以名字相同。(资源：Pod、Deployment、Service等)</p>
<p>Kubernetes自动创建的3个NameSpace：</p>
<ol>
<li>default；</li>
<li>kube-system；</li>
<li>kube-public</li>
</ol>
<p><strong>为Namespace设置资源配额</strong></p>
<p>resource quota资源文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">quota</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">hard:</span></span><br><span class="line">      <span class="attr">configmaps:</span> <span class="string">"20"</span></span><br><span class="line">      <span class="attr">limits.cpu:</span> <span class="string">"4"</span></span><br><span class="line">      <span class="attr">limits.memory:</span> <span class="string">10Gi</span></span><br><span class="line">      <span class="attr">persistentvolumeclaims:</span> <span class="string">"10"</span></span><br><span class="line">      <span class="attr">pods:</span> <span class="string">"30"</span></span><br><span class="line">      <span class="attr">requests.storage:</span> <span class="string">10Ti</span></span><br><span class="line">      <span class="attr">secrets:</span> <span class="string">"60"</span></span><br><span class="line">      <span class="attr">services:</span> <span class="string">"40"</span></span><br><span class="line">      <span class="attr">services.loadbalancers:</span> <span class="string">"50</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kybectl apply -f resourcequota.yaml -n myNamespace</span><br></pre></td></tr></table></figure>

<p><strong>为Nmaespace设置资源限制</strong></p>
<p>为了避免单个容器或者pod用光node上的所有可用资源。</p>
<p>LimitRange资源对象</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">limit-mem-cpu-per-container</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">max:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"800m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"1Gi"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"100m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"99Mi"</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"700m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"900Mi"</span></span><br><span class="line">  <span class="attr">defaultRequest:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"110m"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">"111Mi"</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Container</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f limitrange.yaml -n myNamespace</span><br></pre></td></tr></table></figure>

<p><strong>查看pod的资源情况</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k8s kubectl describe pods myapp-pod -n myNamespace</span><br></pre></td></tr></table></figure>

<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><ol>
<li><p>解决task co-scheduling的问题</p>
<p>Pod中的容器被自动安排到集群中的同一个物理或虚拟机上，并可以一起进行调度。</p>
</li>
<li><p>管理</p>
</li>
<li><p>资源共享和通信</p>
<p>Pod 内的容器之间没有进行资源隔离，可以进行资源共享和通信。</p>
</li>
</ol>
<p><strong>Pod的生命周期</strong></p>
<ul>
<li>挂起(Pending)：Pod已被Kubernetes接受，但有一个或多个容器镜像尚未创建。(调度Pod的时间、通过网络下载镜像的时间)</li>
<li>运行中(Running)：该Pod已经绑定到了一个节点上，Pod中所有容器都已被创建，至少有一个容器正在运行或处于启动或重启状态。</li>
<li>成功(Succeeded)：Pod中的所有容器都被成功终止了，并且不会再重启。</li>
<li>失败(Failed)：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。</li>
<li>未知(Unknown)：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>
<p><strong>常用参数</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#表示 api 对象的版本（比如 Pod 就是一种 api 对象）</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#表明 api 对象类型，Pod 对应的 kind 是 Pod</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">#包含一些元信息，比如 name 、 labels 等</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment">#定义了 Pod 的一些描述信息，重要信息都是在 spec 这里进行描述的，比如：</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment">#containers：Pod 中运行的容器的镜像列表，可以包含多个</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>command</p>
</li>
<li><p><strong>affinity</strong></p>
<ul>
<li>nodeAffinity：描述了 Pod 和 Node 之间的调度关系，比如把 Pod 调度到含有指定的标签的 Node 节点上；<ul>
<li>requiredDuringSchedulingIgnoredDuringExecution：Pod必须部署到满足条件的节点上，如果没有满足条件的节点，就不停重试。</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署。</li>
</ul>
</li>
<li>podAffinity：描述了 Pod 之间的调度关系，比如将某两种 Pod 调度到指定的节点上；</li>
<li>podAntiAffinity：和 podAffinity 正好相反，这个叫反亲和，比如让某两种 Pod 不要调度到同一个节点。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;label-name&gt;</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&lt;value&gt;</span></span><br><span class="line">    <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:latest</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo Hello Kubernetes! &amp;&amp; sleep 3600'</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hostAliases</p>
</li>
<li><p>Init Container</p>
<p>Pod可以包含多个容器，需要某个或某几个容器优于其他容器启动。</p>
<ol>
<li>init container总是运行到完成；</li>
<li>每个init container运行完成，下一个容器才会运行，如果有多个init container，则按顺序启动；</li>
<li>如果init container运行失败，Kubernetes会不断重启Pod，直到init container成功为止，除非restartPolicy值为Never。</li>
</ol>
</li>
</ul>
<h2 id="配置管理ConfigMap和Secret"><a href="#配置管理ConfigMap和Secret" class="headerlink" title="配置管理ConfigMap和Secret"></a>配置管理ConfigMap和Secret</h2><ul>
<li>ConfigMap：普通配置存储；</li>
<li>Secret：密文存储，如数据库密码等。</li>
</ul>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>不同环境对应不同的配置，将镜像和配置分离。</p>
<p><strong>创建</strong></p>
<ol>
<li><p>通过目录</p>
</li>
<li><p>通过文件</p>
</li>
<li><p>通过环境变量文件</p>
</li>
<li><p>直接编写configmap</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">ui.properties:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">color.good=purple</span></span><br><span class="line">    <span class="string">color.bad=yellow</span></span><br><span class="line">    <span class="string">allow.textmode=true</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ui-config-file</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编写configmap对象的yaml文件</span></span><br><span class="line">kubectl apply -f .\ui.yaml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用</strong></p>
<ol>
<li><p>环境变量</p>
</li>
<li><p>通过volume挂载</p>
</li>
</ol>
<p><strong>使用限制</strong></p>
<ol>
<li>ConfigMap是通过etcd存储的(实际上kubernetes中所有API对象都是存储在etcd中的)，etcd的value默认限制1M大小；</li>
<li>更新问题。环境变量：需要重启pod；volume挂载方式：10s左右更新。</li>
</ol>
<h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h3><p>Secret对象类型一般用于保存敏感信息，如密码、令牌和ssh key等。</p>
<p><strong>创建</strong></p>
<ol>
<li><p>kubectl命令行；</p>
</li>
<li><p>直接编写Secret</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MWYyZDFlMmU2N2Rm</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">user-password-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f .\db-user-pass.yaml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用</strong></p>
<ol>
<li><p>环境变量</p>
</li>
<li><p>通过volume挂载</p>
</li>
</ol>
<h2 id="容器化守护进程DaemonSet"><a href="#容器化守护进程DaemonSet" class="headerlink" title="容器化守护进程DaemonSet"></a>容器化守护进程DaemonSet</h2><p>DaemonSet：控制Daemon Pod</p>
<p>Daemon Pod：</p>
<ul>
<li>这个Pod运行在Kubernetes集群中的每一个节点(Node)上；</li>
<li>每个节点只能运行一个Daemon Pod实例；</li>
<li>当有新的节点(Node)加入到Kubernetets集群时，Daemon Pod会自动被拉起；</li>
<li>当有旧节点被删除时，其上运行的Daemon Pod也被删除。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>存储守护进程，如glusted或者ceph；</li>
<li>日志收集进程，如fluentd或者filebeat；</li>
<li>监控守护进程，如Prometheus的node-exporter；</li>
</ul>
<p><strong>创建</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">fluentd</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl get pod</span><br><span class="line">NAME                READY   STATUS    RESTARTS      AGE</span><br><span class="line">fluentd-app-ts8p2   1/1     Running   1 (14m ago)   19h</span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl get daemonset</span><br><span class="line">NAME          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">fluentd-app   1         1         1       1            1           &lt;none&gt;          19h</span><br><span class="line"><span class="meta">#</span><span class="bash">DESIRED：期望运行的Pod实例的个数；CURRENT：当前运行的Pod实例的个数；READY：状态ready的Pod实例的个数</span></span><br></pre></td></tr></table></figure>

<p><strong>只在某些指定的节点上面运行Pod</strong></p>
<ol>
<li>指定.spec.template.spec.nodeSelector，DaemonSet将在能够与Node Selector匹配的节点上创建Pod；</li>
<li>指定.spec.template.spec.affinity，DaemonSet 将在能够与 nodeAffinity 匹配的节点上创建 Pod。</li>
</ol>
<ul>
<li><p>nodeSelector示例：</p>
<ol>
<li><p>给某个节点打上特定的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\daemonSet&gt; kubectl label nodes docker-desktop daemonset-label=master</span><br><span class="line">node/docker-desktop labeled</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 DaemonSet 的 yaml 文件中指定 nodeSelector</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">daemonset-label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>nodeAffinity示例</p>
<p>4种策略：</p>
<ul>
<li>requiredDuringSchedulingIgnoredDuringExecution：表示 Pod 必须部署到满足条件的节点上，如果没有满足条件的节点，就不停重试；</li>
<li>requiredDuringSchedulingRequiredDuringExecution：类似 requiredDuringSchedulingIgnoredDuringExecution ，不过如果节点标签发生了变化，不再满足pod指定的条件，则重新选择符合要求的节点；</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：表示优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署；</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：表示优先部署到满足条件的节点上，如果没有满足条件的节点，就忽略这些条件，按照正常逻辑部署。其中RequiredDuringExecution表示如果后面节点标签发生了变化，满足了条件，则重新调度到满足条件的节点。</li>
</ul>
</li>
</ul>
<p><strong>DaemonSet工作原理</strong></p>
<p>控制器会不断检查状态是不是预期的，如果不是预期的就会做一些处理。</p>
<p>DaemonSet Controller：遍历所有的Node，状态有如下情况：</p>
<ul>
<li>没有指定的Pod在运行，需要创建；</li>
<li>有指定的Pod在运行，可能有多个 需要将多余的Pod删除；</li>
<li>正好有一个指定的Pod在运行。</li>
</ul>
<h2 id="ReplicationController和ReplicaSet"><a href="#ReplicationController和ReplicaSet" class="headerlink" title="ReplicationController和ReplicaSet"></a>ReplicationController和ReplicaSet</h2><h3 id="RepicationController"><a href="#RepicationController" class="headerlink" title="RepicationController"></a>RepicationController</h3><p>RepicationController确保集群内任何时刻都有指定的Pod副本处于运行状态，监控管理集群内跨多个节点的多个Pod。</p>
<p><strong>工作原理</strong></p>
<p>ReplicationController会监听Kubernetes集群内运行的Pod个数，如果多于指定副本数，则删除多余的Pod；如果少于指定的副本数，则启动缺少的Pod。即使只需要一个Pod，也建议使用ReplicationController来创建Pod。</p>
<h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>下一代的Replication Controller，支持新的基于集合的选择器(Deployment，DaemonSet也支持)。</p>
<p><strong>动态伸缩</strong></p>
<ol>
<li><p>修改ReplicaSet中的.spec.replicas字段来实现运行的Pod的个数伸缩限制，更新完yaml文件后直接kubectl apply重新应用一下即可；</p>
</li>
<li><p>结合HorizontalPodAutoscaler(水平Pod缩放器)，HPA可以基于CPU利用率(或其它)自动伸缩replication controller、deployment和replica set中的Pod数量。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span> <span class="comment">#hpa的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-scaler</span> <span class="comment">#hpa的名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment">#指定目标类型为ReplicaSet</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">frontend</span> <span class="comment">#指定目标ReplicaSet为frontend</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">3</span> <span class="comment">#最少pod副本为3 </span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod副本为10</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">50</span> <span class="comment">#设定cpu百分比，超过50%就增加pod数量</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>类似ReplicaSet，更新和扩缩容操作上更加友好。</p>
<p><strong>创建</strong></p>
<p>Deployment 创建的过程会首先创建一个 ReplicaSet，然后由 ReplicaSet 间接创建Pod。Deployment 负责管理 ReplicaSet，ReplicaSet 负责管理 Pod。</p>
<p><strong>更新</strong></p>
<p>Deployment 的更新实际上就是两个 ReplicaSet(OldReplicatSets、NewReplicaSets) 通过StrategyType 做更新的过程。</p>
<p><strong>回滚</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看历史版本</span></span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\deployment&gt; kubectl rollout history deployment nginx-deployment</span><br><span class="line"><span class="meta">#</span><span class="bash">显示每个版本具体的行为</span></span><br><span class="line">PS C:\Users\Desktop\KubernetesConfigFiles\deployment&gt; kubectl rollout history deployment nginx-deployment  --revision=2</span><br><span class="line"><span class="meta">#</span><span class="bash">回滚到上一次修改的版本</span></span><br><span class="line">kubectl rollout undo deployment nginx-deployment </span><br><span class="line"><span class="meta">  #</span><span class="bash">回滚到指定的某个版本</span></span><br><span class="line">kubectl rollout undo deployment nginx-deployment --to-revisoin=1</span><br></pre></td></tr></table></figure>

<p><strong>缩放Deployment</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">扩容</span></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas=7</span><br><span class="line"><span class="meta">#</span><span class="bash">缩容</span></span><br><span class="line">kubectl scale deployment nginx-deployment --replicas=3</span><br><span class="line"><span class="meta">#</span><span class="bash">水平自动缩放 Pod，根据 cpu 使用率来进行自动缩放。</span></span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure>

<h2 id="批处理：Job和CronJob"><a href="#批处理：Job和CronJob" class="headerlink" title="批处理：Job和CronJob"></a>批处理：Job和CronJob</h2><p>CronJob 是Job 的定时调度。</p>
<p>Pod 作为 Kubernetes 的基本调度单位，Job 的执行最后也是通过 Pod 来运行的。</p>
<p>通过Job去初始化环境，通过CronJob去定时清理集群中的某些资源。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>通过Job去初始化环境，通过CronJob去定时清理集群中的某些资源。</p>
<p><strong>创建</strong></p>
<p>通过 perl 计算 pi 的小数点后两千位数，并输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">perl</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">["perl",</span> <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>并行度：</p>
<ul>
<li>非并行任务：只会启动一个Pod，Pod成功结束就表示Job正常完成了；</li>
<li>带有固定competion数目的并行任务：spec.completions 定义 Job 至少要完成的 Pod 数据，即 Job 的最小完成数；</li>
<li>具有工作队列的并行任务：通过参数 spec.parallelism 指定一个 Job 在任意时间最多可以启动运行的 Pod数。</li>
</ul>
<p><strong>清理</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete jobs pi</span><br></pre></td></tr></table></figure>

<p>自动清理</p>
<p>TTL(Time To Live)：存活时间</p>
<p>在Job的spec中增加参数ttlSecondsAfterFinished(Job结束之后的存活时间)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi-with-ttl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>

<h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>类似于Linux的Crontab，不过CronJob的周期性任务是相对于整个Kubernetes集群。</p>
<p><strong>创建</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cronjob-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">"*/2 * * * *"</span>  <span class="comment">#每隔 2 分钟输出当前时间和一串文本信息 “Hello from the Kubernetes cluster”</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">            <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<p><strong>清理</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete cronjob cronjob-demo</span><br></pre></td></tr></table></figure>

<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>ReplicaController、Deployment等都是Kubernetes中的控制器，控制循环，不断比较资源的状态是不是期望状态，如果不是期望状态，则执行一些动作，否则什么都不做。</p>
<p><strong>状态</strong></p>
<ul>
<li><p>当前状态</p>
<p>Kubernetes可以认为是一种server-agent架构，server可以是API Server等，agent是运行在每个Node上的kubelet。kubelet通过心跳汇报其所在节点上运行的容器状态和节点状态。</p>
</li>
<li><p>期望状态</p>
<p>Kubernetes中的所有API对象都会提交给API Server，然后保存到ETCD中。期望状态来源于YAML文件，也是存储在ETCD中。控制器不直接与ETCD交互，而是通过API Server来中转。ETCD提供watch机制。</p>
<ol>
<li>Deployment 控制器从 API Server 获取到所有带有特定标签的 Pod，并统计数目，这个就是实际状态；</li>
<li>Deployment 对象中的 Replica 字段的值是期望状态；</li>
<li>Deployment 控制器比较这两个状态，然后根据比较结果来决定是创建新的 Pod，还是删除已有的 Pod。</li>
</ol>
</li>
</ul>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>Deployment不能用来管理有状态的应用，它认为所有代理的后端的Pod是相同的。</p>
<p>有状态的应用：</p>
<ol>
<li>后端的多个Pod的角色是不同的，如Zookeeper有一个Leader节点，剩下都是Follower；</li>
<li>状态是存储和应用之间绑定的，如Hadoop中的HDFS会启动很多个DataNode，每个DataNode存储的数据是有区别的。</li>
</ol>
<p><strong>工作原理</strong></p>
<p>控制的Pod拥有唯一的标识，包括顺序标识、稳定的网络标识和稳定的存储，启动周标识就是固定的，重启之后也不会发生变化。</p>
<ul>
<li><p>顺序标识</p>
<p>对具有N个Pod副本的StatefulSet，StatefulSet会为每个Pod分配一个固定的名字，如&lt; statefulset-name&gt;-x，其中 x 介于 0 和 N-1 之间。正如我们上面看到的 Pod 的名称 web-0、web-1、web-2。</p>
</li>
<li><p>网络标识</p>
<p>Stateful通过Headless Service控制Pod的网络标识，网络标识的格式为<code>$(服务名称).$(命名空间).svc.cluster.local</code>，其中<code>cluster.local</code>是集群域。一旦Pod创建成功，就会得到一个匹配的DNS子域，格式为<code>$(pod名称).$(所属服务的 DNS 域名)</code>，其中所属服务由StatefulSet的spec中的serviceName域来设定。由于Pod的名称的固定，所以每个Pod对应的DNS子域也是固定的。</p>
</li>
<li><p>稳定存储</p>
<p>Kubernetes为每个VolumeClaimTemplate域创建一个PV。如果没有声明 StorageClass，就会使用默认的 StorageClass。当Pod被调度以及重新调度(比如Pod重启或Node节点挂掉)到节点上时，它的volumeMounts会挂载与其PersistentVolumeClaims相关联的PV。</p>
<p>当Pod或者StatefulSet被删除时，Pod之前使用的PV并不会自动删除，需要手动删除。</p>
</li>
</ul>
<p><strong>部署和扩缩容</strong></p>
<ul>
<li>对于包含 N 个 Pod 副本的 StatefulSet，当部署时，Pod 按 0，1，…，N-1 的顺序依次被创建的。</li>
<li>当删除 StatefulSet 时，Pod 按 N-1，…，1，0 的顺序被逆序终止的。</li>
<li>当缩放操作应用到某个 Pod 之前，它前面的所有 Pod 必须是 Running 和 Ready 状态，所谓前面的 Pod 的意<br>思是序号小于当前 Pod 的序号。</li>
<li>在 Pod 终止之前，所有序号大于该 Pod 的 Pod 都必须完全关闭。</li>
</ul>
<h2 id="使用Service访问一组特定的Pod"><a href="#使用Service访问一组特定的Pod" class="headerlink" title="使用Service访问一组特定的Pod"></a>使用Service访问一组特定的Pod</h2><p>Service可以理解为一种访问一组特定Pod的策略。</p>
<p>如Pod 运行了 3 个副本，并且是无状态的。前端访问该应用程序时，不需要关心实际是调用了那个 Pod 实例。通过Service解耦，Service 与后端的多个 Pod 进行关联（通过 selector），前端只需要访问Service 即可。</p>
<p><strong>创建</strong></p>
<p>对80端口的TCP请求转发到标签<code>app=nginx</code>的并且使用TCP端口80的Pod上</p>
<p>ClusterIP 类型的 Service 只能在集群内部进行访问</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>多端口Service</strong></p>
<p><strong>设置固定IP</strong></p>
<p>在 Service 的定义中通过参数 <code>spec.clusterIP</code> 指定自己的clusterIP。</p>
<p><strong>服务发现</strong></p>
<p>TODO</p>
<p><strong>Headless Service</strong></p>
<p>拥有ClusterIP的Service，会自动做负载均衡。</p>
<p>指定负载均衡策略：指定ClusterIP的值为None，此时创建出来的Service则为Headless Service。这个时候做服务发现时，这个Service返回的为后端的Pod列表。</p>
<h2 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h2><ul>
<li>ClusterIP：默认的 Service Type，通过集群的内部 IP 暴露服务，只能在集群内部进行访问；</li>
<li>NodePort：通过每个 Node 上面的某个端口 （NodePort）暴露服务。通过该端口的请求会自动路由到后端的ClusterIP 服务，这个 ClusterIP 服务是自动创建的。通过 NodePort，我们可以在集群外部访问我们的服务，但是，在生产环境上面并不建议使用 NodePort；</li>
<li>LoadBalancer：使用云厂商提供的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到<br>NodePort 和 ClusterIP 服务；</li>
<li>ExternalName：通过返回 CNAME 将服务映射到 externalName 字段中的内容；</li>
<li>Ingress：严格来说，Ingress 不是一种服务类型，而是用来充当集群的服务的入口点。Ingress 可以将路由规<br>则整合到一个资源中，然后通过同一个 IP 地址暴露多个服务。</li>
</ul>
<p><strong>NodePort</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">30001</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get service</span></span><br><span class="line">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class="line">nginx-service ClusterIP 10.0.213.149 &lt;none&gt; 80/TCP 7h26m</span><br><span class="line">nginx-service-nodeport NodePort 10.0.8.178 &lt;none&gt; 30001:31633/TCP 1s #前面表示 ClusterIP 对应的端口，也就是 30001；后面的表示 Node 本地对应的端口，是 31633。</span><br></pre></td></tr></table></figure>

<p>NodePort 类型的 Service 后端还是通过 ClusterIP 来实现。</p>
<p>Node本地对应的端口为一个区间随机生成的，默认为30000-32767，可以通过参数–service-node-port-range来指定。</p>
<p>指定NodePort：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">30001</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30002</span>  <span class="comment">#保证指定的值处于参数 --service-node-port-range 指定的区间内</span></span><br></pre></td></tr></table></figure>

<ul>
<li>NodePort：Node节点本地启动的用来监听和转发请求的端口，每个节点上都会启动；</li>
<li>Port：NodePort类型的Service自动创建的ClusterIP的端口；</li>
<li>TargetPort：ClusterIP转发的目标端口。</li>
</ul>
<p>所以对于NodePort类型的Service，外部的请求顺序是：<strong>NodePort -&gt; Port -&gt; TargetPort</strong></p>
<p><strong>Ingress</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.example.com</span>  <span class="comment">#host：服务暴露的域名；</span></span><br><span class="line">    <span class="attr">http:</span>  <span class="comment">#http：路由转发协议，可以是 http 或者 https</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span>  <span class="comment">#path：路由 router</span></span><br><span class="line">        <span class="attr">backend:</span> <span class="comment">#backend：后端服务，主要包括服务名称和服务端口</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        <div class="reward-container">
  <div>请作者喝瓶肥宅快乐水</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/img/vxpay.jpg" alt="ImOkkkk 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/img/alipay.jpg" alt="ImOkkkk 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"><i class="fa fa-tag"></i> Docker</a>
              <a href="/tags/Kubernetes/" rel="tag"><i class="fa fa-tag"></i> Kubernetes</a>
              <a href="/tags/云原生/" rel="tag"><i class="fa fa-tag"></i> 云原生</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/computernetwork/" rel="prev" title="计算机网络">
      <i class="fa fa-chevron-left"></i> 计算机网络
    </a></div>
      <div class="post-nav-item">
    <a href="/javaobjectsize/" rel="next" title="一个Java对象的大小怎么计算？">
      一个Java对象的大小怎么计算？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker"><span class="nav-text">Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心概念"><span class="nav-text">核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#容器的5种状态"><span class="nav-text">容器的5种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker客户端"><span class="nav-text">Docker客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker服务端"><span class="nav-text">Docker服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-attach-exec"><span class="nav-text">docker attach/exec</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像与容器的区别"><span class="nav-text">镜像与容器的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AUFS"><span class="nav-text">AUFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OverlayFS"><span class="nav-text">OverlayFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker网络"><span class="nav-text">Docker网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker0网桥"><span class="nav-text">docker0网桥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iptables"><span class="nav-text">iptables</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络模式"><span class="nav-text">网络模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器间网络通信：link"><span class="nav-text">容器间网络通信：link</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker数据存储模式"><span class="nav-text">Docker数据存储模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volumes"><span class="nav-text">Volumes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bind-mounts"><span class="nav-text">bind mounts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tmpfs"><span class="nav-text">tmpfs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么说Docker是单进程模型？"><span class="nav-text">为什么说Docker是单进程模型？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回收子进程资源"><span class="nav-text">回收子进程资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#僵尸进程"><span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程"><span class="nav-text">孤儿进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes"><span class="nav-text">Kubernetes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源隔离：NameSpace"><span class="nav-text">资源隔离：NameSpace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod"><span class="nav-text">Pod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置管理ConfigMap和Secret"><span class="nav-text">配置管理ConfigMap和Secret</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigMap"><span class="nav-text">ConfigMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Secret"><span class="nav-text">Secret</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器化守护进程DaemonSet"><span class="nav-text">容器化守护进程DaemonSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReplicationController和ReplicaSet"><span class="nav-text">ReplicationController和ReplicaSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RepicationController"><span class="nav-text">RepicationController</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaSet"><span class="nav-text">ReplicaSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deployment"><span class="nav-text">Deployment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理：Job和CronJob"><span class="nav-text">批处理：Job和CronJob</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Job"><span class="nav-text">Job</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CronJob"><span class="nav-text">CronJob</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制器"><span class="nav-text">控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StatefulSet"><span class="nav-text">StatefulSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Service访问一组特定的Pod"><span class="nav-text">使用Service访问一组特定的Pod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service类型"><span class="nav-text">Service类型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ImOkkkk"
      src="/../assets/img/head.jpg">
  <p class="site-author-name" itemprop="name">ImOkkkk</p>
  <div class="site-description" itemprop="description">Java开发, 后端开发</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vNjA2MjE3MjIyNC8=" title="Weibo → https://weibo.com/6062172224/"><i class="fab fa-weibo fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvbnltdWE=" title="GitHub → https://github.com/tonymua"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmx3eTA4YUBmb3htYWlsLmNvbQ==" title="E-Mail → mailto:lwy08a@foxmail.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <a href="https://beian.miit.gov.cn/" target="_blank">皖ICP备19022525号-1</a>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ImOkkkk</span>
</div><script color="0,137,108" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://imokkkk.github.io/docker/',]
      });
      });
  </script>

</body>
</html>
